<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>é‡ç”Ÿä¹‹MTå¤§å†’é™©</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            text-align: center;
            background-color: #222;
            color: white;
            margin: 0;
            padding: 20px;
            overflow: hidden;
        }
        #game-container {
            position: relative;
            width: 800px;
            height: 500px;
            margin: 0 auto;
            background-color: #333;
            border: 3px solid #555;
            overflow: hidden;
        }
        #player {
            position: absolute;
            width: 40px;
            height: 50px;
            z-index: 10;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        #player::before {
            content: 'ğŸ§™â€â™‚ï¸';
            font-size: 35px;
            animation: fly 1s ease-in-out infinite alternate;
        }
        
        @keyframes fly {
            0% { transform: translateY(0px) rotate(-2deg); }
            100% { transform: translateY(-8px) rotate(2deg); }
        }
        #door {
            position: absolute;
            width: 60px;
            height: 100px;
            background: linear-gradient(135deg, #2c2c2c 0%, #1a1a1a 50%, #000 100%);
            border: 5px solid #8B4513;
            border-radius: 10px 10px 0 0;
            right: 20px;
            bottom: 0;
            z-index: 5;
            box-shadow: inset 0 0 20px rgba(0,0,0,0.8);
        }
        
        #door::before {
            content: 'ğŸšª';
            position: absolute;
            font-size: 40px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            opacity: 0.8;
        }
        
        #door::after {
            content: '';
            position: absolute;
            width: 8px;
            height: 8px;
            background: #FFD700;
            border-radius: 50%;
            right: 8px;
            top: 45%;
            box-shadow: 0 0 5px rgba(255, 215, 0, 0.5);
        }
        .trap {
            position: absolute;
            background-color: #8B4513;
            border: 2px solid #654321;
            z-index: 2;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
        }
        
        .trap::before {
            content: "ğŸ§±";
        }
        .level-info {
            font-size: 24px;
            margin: 10px 0;
        }
        #progress-info {
            font-size: 18px;
            color: #FFD700;
            font-weight: normal;
        }
        .controls {
            margin: 20px 0;
        }
        button {
            padding: 10px 20px;
            font-size: 16px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin: 0 10px;
        }
        button:hover {
            background-color: #45a049;
        }
        
        /* å…³å¡é€‰æ‹©å™¨æ ·å¼ */
        #level-select {
            background-color: rgba(0,0,0,0.9);
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 100;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
        }
        
        #level-select.hidden {
            display: none !important;
        }
        
        #level-buttons {
            display: grid;
            grid-template-columns: repeat(10, 60px);
            gap: 10px;
            margin: 20px;
            max-height: 300px;
            overflow-y: auto;
        }
        
        .level-btn {
            width: 60px;
            height: 60px;
            border-radius: 10px;
            font-size: 16px;
            font-weight: bold;
        }
        
        .level-btn.unlocked {
            background-color: #4CAF50;
            border: 2px solid #45a049;
        }
        
        .level-btn.current {
            background-color: #FFD700;
            color: #333;
            border: 2px solid #FFA500;
        }
        
        .level-btn.locked {
            background-color: #666;
            color: #999;
            cursor: not-allowed;
            border: 2px solid #555;
        }
        
        #close-select-btn {
            background-color: #f44336;
            margin-top: 20px;
        }
        
        #close-select-btn:hover {
            background-color: #da190b;
        }
        
        #reset-progress-btn {
            background-color: #ff9800;
        }
        
        #reset-progress-btn:hover {
            background-color: #e68900;
        }
        
        /* å¸®åŠ©é¢æ¿æ ·å¼ */
        #help-modal {
            background-color: rgba(0,0,0,0.95);
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 200;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            color: white;
            padding: 20px;
            overflow-y: auto;
        }
        
        #help-modal.hidden {
            display: none !important;
        }
        
        #help-modal h3 {
            color: #FFD700;
            margin-bottom: 20px;
            font-size: 28px;
        }
        
        #trap-guide {
            max-width: 800px;
            width: 100%;
        }
        
        .level-themes {
            max-width: 800px;
            width: 100%;
            margin-bottom: 30px;
            background-color: rgba(255,255,255,0.1);
            padding: 20px;
            border-radius: 10px;
        }
        
        .level-themes h4 {
            color: #FFD700;
            margin-bottom: 15px;
            font-size: 22px;
            border-bottom: 2px solid #FFD700;
            padding-bottom: 5px;
        }
        
        .theme-item {
            display: grid;
            grid-template-columns: 120px 1fr;
            gap: 15px;
            align-items: center;
            padding: 8px;
            margin-bottom: 5px;
            background-color: rgba(255,255,255,0.05);
            border-radius: 6px;
            border-left: 4px solid #9C27B0;
        }
        
        .theme-range {
            font-weight: bold;
            color: #9C27B0;
            font-size: 14px;
            text-align: center;
        }
        
        .theme-desc {
            color: #E0E0E0;
            font-size: 14px;
            line-height: 1.4;
        }
        
        .trap-category {
            margin-bottom: 30px;
            background-color: rgba(255,255,255,0.1);
            padding: 20px;
            border-radius: 10px;
        }
        
        .trap-category h4 {
            color: #FFD700;
            margin-bottom: 15px;
            font-size: 22px;
            border-bottom: 2px solid #FFD700;
            padding-bottom: 5px;
        }
        
        .trap-item {
            display: grid;
            grid-template-columns: 40px 150px 1fr;
            gap: 15px;
            align-items: center;
            padding: 10px;
            margin-bottom: 8px;
            background-color: rgba(255,255,255,0.05);
            border-radius: 8px;
            border-left: 4px solid #4CAF50;
        }
        
        .trap-icon {
            font-size: 24px;
            text-align: center;
        }
        
        .trap-name {
            font-weight: bold;
            color: #FFD700;
            font-size: 16px;
        }
        
        .trap-desc {
            color: #E0E0E0;
            font-size: 14px;
            line-height: 1.4;
        }
        
        #close-help-btn {
            background-color: #f44336;
            margin-top: 30px;
            padding: 15px 30px;
            font-size: 18px;
        }
        
        #close-help-btn:hover {
            background-color: #da190b;
        }
        
        /* éŸ³ä¹æ§åˆ¶æŒ‰é’®æ ·å¼ */
        #music-toggle-btn {
            background-color: #9C27B0;
        }
        
        #music-toggle-btn:hover {
            background-color: #7B1FA2;
        }
        

        

        #message {
            font-size: 24px;
            height: 30px;
            margin: 10px 0;
            color: #FFD700;
        }
        .hidden {
            display: none;
        }
        .spike {
            position: absolute;
            width: 30px;
            height: 30px;
            background-color: #696969;
            bottom: 0;
            z-index: 2;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            border-radius: 50% 50% 50% 50% / 60% 60% 40% 40%;
        }
        
        .spike::before {
            content: "âš¡";
        }
        .moving-trap {
            position: absolute;
            width: 40px;
            height: 40px;
            background-color: #FF6347;
            border: 2px solid #DC143C;
            border-radius: 50%;
            z-index: 2;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
        }
        
        .moving-trap::before {
            content: "ğŸ”¥";
        }
        
        /* æ–°çš„é™·é˜±ç±»å‹æ ·å¼ */
        .invisible-trap {
            position: absolute;
            background-color: rgba(128, 128, 128, 0.1);
            border: 2px dashed rgba(128, 128, 128, 0.3);
            z-index: 2;
            transition: opacity 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
        }
        
        .invisible-trap::before {
            content: "ğŸ‘»";
            opacity: 0.3;
        }
        
        .invisible-trap.revealed {
            background-color: rgba(105, 105, 105, 0.8);
            border: 2px solid #696969;
        }
        
        .invisible-trap.revealed::before {
            opacity: 1;
        }
        
        .teleport-trap {
            position: absolute;
            width: 50px;
            height: 50px;
            background: radial-gradient(circle, #9C27B0, #673AB7);
            border-radius: 50%;
            z-index: 2;
            animation: teleportPulse 2s ease-in-out infinite;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
        }
        
        .teleport-trap::before {
            content: "ğŸŒ€";
        }
        
        @keyframes teleportPulse {
            0%, 100% { transform: scale(1); opacity: 0.7; }
            50% { transform: scale(1.2); opacity: 1; }
        }
        
        .hunter-trap {
            position: absolute;
            width: 35px;
            height: 35px;
            background-color: #FF4500;
            border-radius: 50%;
            z-index: 2;
            border: 3px solid #FF6347;
            animation: hunterGlow 1s ease-in-out infinite alternate;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
        }
        
        .hunter-trap::before {
            content: "ğŸ¯";
        }
        
        @keyframes hunterGlow {
            0% { box-shadow: 0 0 5px #FF4500; }
            100% { box-shadow: 0 0 15px #FF4500, 0 0 25px #FF4500; }
        }
        
        .blink-trap {
            position: absolute;
            background-color: #00BCD4;
            z-index: 2;
            animation: blinkTrap 3s ease-in-out infinite;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            border-radius: 50%;
        }
        
        .blink-trap::before {
            content: "ğŸ’«";
        }
        
        @keyframes blinkTrap {
            0%, 40% { opacity: 1; }
            50%, 90% { opacity: 0; }
            100% { opacity: 1; }
        }
        
        .gravity-trap {
            position: absolute;
            width: 60px;
            height: 60px;
            background: radial-gradient(circle, rgba(0,0,0,0.8), rgba(0,0,0,0.3));
            border: 3px solid #333;
            border-radius: 50%;
            z-index: 2;
            animation: gravityPull 2s ease-in-out infinite;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
        }
        
        .gravity-trap::before {
            content: "ğŸ•³ï¸";
        }
        
        @keyframes gravityPull {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
        
        .split-trap {
            position: absolute;
            width: 45px;
            height: 45px;
            background-color: #32CD32;
            border: 2px solid #228B22;
            z-index: 2;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
        }
        
        .split-trap::before {
            content: "ğŸ’¥";
        }
        
        .mirror-trap {
            position: absolute;
            width: 40px;
            height: 40px;
            background: linear-gradient(45deg, #C0C0C0, #808080);
            border-radius: 50%;
            z-index: 2;
            border: 2px solid #999;
            animation: mirrorShine 2s linear infinite;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
        }
        
        .mirror-trap::before {
            content: "ğŸª";
        }
        
        @keyframes mirrorShine {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .freeze-trap {
            position: absolute;
            width: 40px;
            height: 40px;
            background: linear-gradient(45deg, #00E5FF, #0277BD);
            border-radius: 50%;
            z-index: 2;
            animation: freezeEffect 1.5s ease-in-out infinite;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
        }
        
        .freeze-trap::before {
            content: "ğŸ§Š";
        }
        
        @keyframes freezeEffect {
            0%, 100% { transform: scale(1); filter: hue-rotate(0deg); }
            50% { transform: scale(0.9); filter: hue-rotate(90deg); }
        }
        
        .bounce-trap {
            position: absolute;
            width: 40px;
            height: 40px;
            background: linear-gradient(45deg, #FF1493, #FF69B4);
            border-radius: 50%;
            z-index: 2;
            animation: bounceEffect 1s ease-in-out infinite;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
        }
        
        .bounce-trap::before {
            content: "ğŸ€";
        }
        
        @keyframes bounceEffect {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
        }
        
        .shrink-trap {
            position: absolute;
            width: 40px;
            height: 40px;
            background: linear-gradient(45deg, #FFD700, #FFA500);
            border-radius: 50%;
            z-index: 2;
            animation: shrinkEffect 2s ease-in-out infinite;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
        }
        
        .shrink-trap::before {
            content: "ğŸ”";
        }
        
        @keyframes shrinkEffect {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(0.5); }
        }
        
        .speed-trap {
            position: absolute;
            width: 40px;
            height: 40px;
            background: linear-gradient(45deg, #00FF00, #32CD32);
            border-radius: 50%;
            z-index: 2;
            animation: speedEffect 0.5s linear infinite;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
        }
        
        .speed-trap::before {
            content: "âš¡";
        }
        
        @keyframes speedEffect {
            0% { transform: rotate(0deg) scale(1); }
            100% { transform: rotate(360deg) scale(1.1); }
        }
        
        .clone-trap {
            position: absolute;
            width: 40px;
            height: 40px;
            background: linear-gradient(45deg, #8A2BE2, #9370DB);
            border-radius: 50%;
            z-index: 2;
            animation: cloneEffect 1.5s ease-in-out infinite;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
        }
        
        .clone-trap::before {
            content: "ğŸ‘¥";
        }
        
        @keyframes cloneEffect {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.5; transform: scale(1.2); }
        }
        
        /* ç‰¹æ®Šå…³å¡æœºåˆ¶æ ·å¼ */
        .collectible {
            position: absolute;
            width: 30px;
            height: 30px;
            background: radial-gradient(circle, #FFD700, #FFA500);
            border-radius: 50%;
            z-index: 3;
            animation: collectibleFloat 2s ease-in-out infinite;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            border: 2px solid #FF8C00;
        }
        
        .collectible::before {
            content: "ğŸ’";
        }
        
        @keyframes collectibleFloat {
            0%, 100% { transform: translateY(0px) scale(1); }
            50% { transform: translateY(-8px) scale(1.1); }
        }
        
        .key-item {
            position: absolute;
            width: 25px;
            height: 25px;
            background: linear-gradient(45deg, #FFD700, #FFC107);
            border-radius: 5px;
            z-index: 3;
            animation: keyGlow 1.5s ease-in-out infinite;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
        }
        
        .key-item::before {
            content: "ğŸ—ï¸";
        }
        
        @keyframes keyGlow {
            0%, 100% { box-shadow: 0 0 5px #FFD700; }
            50% { box-shadow: 0 0 15px #FFD700, 0 0 25px #FFC107; }
        }
        
        .teleporter {
            position: absolute;
            width: 60px;
            height: 60px;
            background: radial-gradient(circle, rgba(138, 43, 226, 0.8), rgba(75, 0, 130, 0.6));
            border-radius: 50%;
            z-index: 2;
            animation: teleporterPulse 2s ease-in-out infinite;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            border: 3px solid #9370DB;
        }
        
        .teleporter::before {
            content: "ğŸŒ€";
        }
        
        @keyframes teleporterPulse {
            0%, 100% { transform: scale(1); opacity: 0.8; }
            50% { transform: scale(1.2); opacity: 1; }
        }
        
        .switch {
            position: absolute;
            width: 40px;
            height: 40px;
            background: linear-gradient(45deg, #4CAF50, #45a049);
            border-radius: 10px;
            z-index: 3;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            border: 2px solid #388E3C;
            cursor: pointer;
        }
        
        .switch.activated {
            background: linear-gradient(45deg, #FF5722, #D84315);
            border-color: #BF360C;
        }
        
        .switch::before {
            content: "ğŸ”˜";
        }
        
        .switch.activated::before {
            content: "ğŸ”´";
        }
        
        .moving-platform {
            position: absolute;
            width: 80px;
            height: 20px;
            background: linear-gradient(45deg, #795548, #5D4037);
            border-radius: 10px;
            z-index: 2;
            border: 2px solid #4E342E;
        }
        
        /* é»‘æš—æ¨¡å¼ */
        .dark-mode {
            background: radial-gradient(circle at var(--light-x, 50%) var(--light-y, 50%), 
                        rgba(255,255,255,0.3) 0%, 
                        rgba(255,255,255,0.1) var(--light-radius, 100px), 
                        rgba(0,0,0,0.9) calc(var(--light-radius, 100px) + 20px));
        }
        
        /* ç©å®¶éšå½¢æ•ˆæœ */
        .player-invisible {
            opacity: 0.3;
            filter: blur(1px);
        }
        
        /* é‡åŠ›ç¿»è½¬æ•ˆæœ */
        .gravity-flipped {
            transform: scaleY(-1);
        }
        
        /* æ»‘å†°æ•ˆæœ */
        .slippery-mode .player {
            transition: all 0.1s ease-out;
        }
        
        /* æ—¶é—´é™åˆ¶æ˜¾ç¤º */
        .timer-display {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255, 0, 0, 0.8);
            color: white;
            padding: 5px 10px;
            border-radius: 15px;
            font-weight: bold;
            font-size: 16px;
            z-index: 10;
        }
        
        .timer-warning {
            animation: timerBlink 0.5s ease-in-out infinite;
        }
        
        @keyframes timerBlink {
            0%, 100% { background: rgba(255, 0, 0, 0.8); }
            50% { background: rgba(255, 100, 100, 0.8); }
        }
        
        /* çˆ†ç‚¸ç‰¹æ•ˆ */
        .explosion {
            position: absolute;
            width: 100px;
            height: 100px;
            z-index: 15;
            pointer-events: none;
        }
        
        .explosion::before {
            content: 'ğŸ’¥';
            font-size: 80px;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            animation: explode 0.8s ease-out;
        }
        
        @keyframes explode {
            0% {
                transform: translate(-50%, -50%) scale(0.1);
                opacity: 1;
            }
            50% {
                transform: translate(-50%, -50%) scale(1.2);
                opacity: 1;
            }
            100% {
                transform: translate(-50%, -50%) scale(1.5);
                opacity: 0;
            }
        }
        
        /* è¿‡å…³ç‰¹æ•ˆ */
        .level-complete {
            position: absolute;
            width: 100px;
            height: 100px;
            z-index: 15;
            pointer-events: none;
        }
        
        .level-complete::before {
            content: 'âœ¨';
            font-size: 60px;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            animation: sparkle 1s ease-out;
        }
        
        @keyframes sparkle {
            0% {
                transform: translate(-50%, -50%) scale(0.5) rotate(0deg);
                opacity: 1;
            }
            50% {
                transform: translate(-50%, -50%) scale(1.2) rotate(180deg);
                opacity: 1;
            }
            100% {
                transform: translate(-50%, -50%) scale(1.5) rotate(360deg);
                opacity: 0;
            }
        }
    </style>
</head>
<body>
    <h1>é‡ç”Ÿä¹‹MTå¤§å†’é™©</h1>
    <div class="level-info">
        ç¬¬ <span id="level">1</span> å…³ 
        <span id="progress-info">(æœ€é«˜è®°å½•: ç¬¬ <span id="max-level">1</span> å…³)</span>
    </div>
    <div id="message"></div>
    <div id="game-container">
        <div id="player"></div>
        <div id="door"></div>
        <!-- é™·é˜±å°†ç”±JSåŠ¨æ€ç”Ÿæˆ -->
    </div>
    <div class="controls">
        <button id="restart-btn">é‡æ–°å¼€å§‹å½“å‰å…³</button>
        <button id="next-btn" class="hidden">ä¸‹ä¸€å…³</button>
        <button id="level-select-btn">é€‰æ‹©å…³å¡</button>
        <button id="sound-toggle-btn">ğŸ”Š éŸ³æ•ˆ</button>
        <button id="music-toggle-btn">ğŸµ éŸ³ä¹</button>
        <button id="help-btn">â“ é™·é˜±è¯´æ˜</button>
        <button id="reset-progress-btn">é‡ç½®è¿›åº¦</button>
    </div>
    <div id="level-select" class="hidden">
        <h3>é€‰æ‹©å…³å¡ (å·²è§£é”: ç¬¬1-<span id="unlocked-levels">1</span>å…³)</h3>
        <div id="level-buttons"></div>
        <button id="close-select-btn">å…³é—­</button>
    </div>
    
    <div id="help-modal" class="hidden">
        <h3>ğŸ¯ é™·é˜±è¯´æ˜æŒ‡å—</h3>
        <div class="level-themes">
            <h4>ğŸ“– é‡ç”Ÿä¹‹è·¯</h4>
            <div class="theme-item">
                <span class="theme-range">ç¬¬1-2å…³</span>
                <span class="theme-desc">ğŸŒ… è§‰é†’åºç«  - æ³•å¸ˆä»æ²‰ç¡ä¸­è‹é†’ï¼Œè®°å¿†å¼€å§‹å¤è‹</span>
            </div>
            <div class="theme-item">
                <span class="theme-range">ç¬¬3-10å…³</span>
                <span class="theme-desc">ğŸ‘» å¹»è±¡è¿·å®« - è™šå®éš¾è¾¨çš„å¹»å¢ƒè€ƒéªŒæ„ŸçŸ¥åŠ›</span>
            </div>
            <div class="theme-item">
                <span class="theme-range">ç¬¬11-20å…³</span>
                <span class="theme-desc">ğŸ§Š å†°å°çŒåœº - å¯’å†°ä¸è¿½çŒè€…çš„è‡´å‘½èˆè¹ˆ</span>
            </div>
            <div class="theme-item">
                <span class="theme-range">ç¬¬21-30å…³</span>
                <span class="theme-desc">ğŸ’¥ å´©åç©ºé—´ - ç°å®åˆ†è£‚ï¼Œé‡åŠ›å¤±æ§çš„æ··æ²Œä¸–ç•Œ</span>
            </div>
            <div class="theme-item">
                <span class="theme-range">ç¬¬31-40å…³</span>
                <span class="theme-desc">ğŸª é•œåƒä¸–ç•Œ - åœ¨åè½¬çš„ç°å®ä¸­å¯»æ‰¾çœŸç›¸</span>
            </div>
            <div class="theme-item">
                <span class="theme-range">ç¬¬41-60å…³</span>
                <span class="theme-desc">âš¡ æ—¶ç©ºä¹±æµ - æ—¶é—´ä¸ç©ºé—´çš„æ‰­æ›²æ”¹å˜ä¸€åˆ‡</span>
            </div>
            <div class="theme-item">
                <span class="theme-range">ç¬¬61-80å…³</span>
                <span class="theme-desc">ğŸŒ€ å¾ªç¯æ·±æ¸Š - å¤šé‡å¾ªç¯äº¤ç»‡ï¼Œè€ƒéªŒæ„å¿—åŠ›</span>
            </div>
            <div class="theme-item">
                <span class="theme-range">ç¬¬81-100å…³</span>
                <span class="theme-desc">ğŸ”¥ ç»ˆæè¯•ç‚¼ - æ‰“ç ´å¾ªç¯çš„æœ€åè€ƒéªŒï¼Œé‡ç”Ÿåœ¨å³</span>
            </div>
        </div>
        <div id="trap-guide">
            <div class="trap-category">
                <h4>åŸºç¡€é™·é˜±</h4>
                <div class="trap-item">
                    <span class="trap-icon">ğŸ§±</span>
                    <span class="trap-name">çŸ©å½¢é™·é˜±</span>
                    <span class="trap-desc">é™æ€éšœç¢ç‰©ï¼Œè§¦ç¢°å³æ­»ï¼Œéœ€è¦ç»•è¡Œ</span>
                </div>
                <div class="trap-item">
                    <span class="trap-icon">âš¡</span>
                    <span class="trap-name">å°–åˆºé™·é˜±</span>
                    <span class="trap-desc">åœ°é¢å°–åˆºï¼Œè§¦ç¢°å³æ­»</span>
                </div>
                <div class="trap-item">
                    <span class="trap-icon">ğŸ”¥</span>
                    <span class="trap-name">ç§»åŠ¨é™·é˜±</span>
                    <span class="trap-desc">ä¼šåœ¨åœºæ™¯ä¸­ç§»åŠ¨çš„ç«çƒï¼Œè§¦ç¢°å³æ­»</span>
                </div>
            </div>
            
            <div class="trap-category">
                <h4>ç‰¹æ®Šé™·é˜± (ç¬¬3å…³å¼€å§‹å‡ºç°)</h4>
                <div class="trap-item">
                    <span class="trap-icon">ğŸ‘»</span>
                    <span class="trap-name">éšå½¢é™·é˜±</span>
                    <span class="trap-desc">é è¿‘æ—¶æ‰æ˜¾ç°ï¼Œè§¦ç¢°å³æ­»</span>
                </div>
                <div class="trap-item">
                    <span class="trap-icon">ğŸŒ€</span>
                    <span class="trap-name">ä¼ é€é™·é˜±</span>
                    <span class="trap-desc">éšæœºä¼ é€ç©å®¶åˆ°å…¶ä»–ä½ç½®</span>
                </div>
                <div class="trap-item">
                    <span class="trap-icon">ğŸ¯</span>
                    <span class="trap-name">è¿½è¸ªé™·é˜±</span>
                    <span class="trap-desc">ä¸»åŠ¨è¿½è¸ªç©å®¶ï¼Œè§¦ç¢°å³æ­»</span>
                </div>
                <div class="trap-item">
                    <span class="trap-icon">ğŸ§Š</span>
                    <span class="trap-name">å†°å†»é™·é˜±</span>
                    <span class="trap-desc">å†»ç»“ç©å®¶3ç§’æ— æ³•ç§»åŠ¨</span>
                </div>
                <div class="trap-item">
                    <span class="trap-icon">ğŸ’¥</span>
                    <span class="trap-name">åˆ†è£‚é™·é˜±</span>
                    <span class="trap-desc">è§¦ç¢°ååˆ†è£‚æˆ4ä¸ªå°é™·é˜±</span>
                </div>
                <div class="trap-item">
                    <span class="trap-icon">ğŸ•³ï¸</span>
                    <span class="trap-name">é‡åŠ›é™·é˜±</span>
                    <span class="trap-desc">å¸å¼•ç©å®¶åˆ°ä¸­å¿ƒç„¶åçˆ†ç‚¸</span>
                </div>
                <div class="trap-item">
                    <span class="trap-icon">ğŸª</span>
                    <span class="trap-name">é•œåƒé™·é˜±</span>
                    <span class="trap-desc">ä¸ç©å®¶åšç›¸åç§»åŠ¨ï¼Œè§¦ç¢°å³æ­»</span>
                </div>
                <div class="trap-item">
                    <span class="trap-icon">ğŸ’«</span>
                    <span class="trap-name">é—ªçƒé™·é˜±</span>
                    <span class="trap-desc">å®šæœŸæ¶ˆå¤±å’Œå‡ºç°ï¼Œéšå½¢æ—¶æ— å®³</span>
                </div>
                <div class="trap-item">
                    <span class="trap-icon">ğŸ€</span>
                    <span class="trap-name">å¼¹è·³é™·é˜±</span>
                    <span class="trap-desc">æŠŠç©å®¶å¼¹é£åˆ°éšæœºä½ç½®</span>
                </div>
                <div class="trap-item">
                    <span class="trap-icon">ğŸ”</span>
                    <span class="trap-name">ç¼©å°é™·é˜±</span>
                    <span class="trap-desc">è®©ç©å®¶å˜å°5ç§’</span>
                </div>
                <div class="trap-item">
                    <span class="trap-icon">âš¡</span>
                    <span class="trap-name">åŠ é€Ÿé™·é˜±</span>
                    <span class="trap-desc">è®©ç©å®¶ç§»åŠ¨é€Ÿåº¦ç¿»å€5ç§’</span>
                </div>
                <div class="trap-item">
                    <span class="trap-icon">ğŸ‘¥</span>
                    <span class="trap-name">å…‹éš†é™·é˜±</span>
                    <span class="trap-desc">åˆ›å»ºè·Ÿéšç©å®¶çš„åˆ†èº«</span>
                </div>
            </div>
            
            <div class="trap-category">
                <h4>ç‰¹æ®Šå…³å¡æœºåˆ¶</h4>
                <div class="trap-item">
                    <span class="trap-icon">ğŸ’</span>
                    <span class="trap-name">æ”¶é›†æŒ‘æˆ˜</span>
                    <span class="trap-desc">æ”¶é›†æ‰€æœ‰æ°´æ™¶æ‰èƒ½é€šå…³</span>
                </div>
                <div class="trap-item">
                    <span class="trap-icon">ğŸ—ï¸</span>
                    <span class="trap-name">é’¥åŒ™é—¨</span>
                    <span class="trap-desc">æ”¶é›†é’¥åŒ™è§£é”é€šå…³æ¡ä»¶</span>
                </div>
                <div class="trap-item">
                    <span class="trap-icon">â°</span>
                    <span class="trap-name">æ—¶é—´é™åˆ¶</span>
                    <span class="trap-desc">åœ¨é™å®šæ—¶é—´å†…åˆ°è¾¾é—¨å£</span>
                </div>
                <div class="trap-item">
                    <span class="trap-icon">ğŸŒ‘</span>
                    <span class="trap-name">é»‘æš—æ¨¡å¼</span>
                    <span class="trap-desc">åªèƒ½çœ‹åˆ°ç©å®¶å‘¨å›´çš„å°èŒƒå›´</span>
                </div>
                <div class="trap-item">
                    <span class="trap-icon">ğŸ”„</span>
                    <span class="trap-name">åå‘æ§åˆ¶</span>
                    <span class="trap-desc">æ–¹å‘é”®è¢«åè½¬</span>
                </div>
                <div class="trap-item">
                    <span class="trap-icon">ğŸ§Š</span>
                    <span class="trap-name">æ»‘å†°æ¨¡å¼</span>
                    <span class="trap-desc">åœ°é¢å¾ˆæ»‘ï¼Œæœ‰æƒ¯æ€§æ•ˆæœ</span>
                </div>
                <div class="trap-item">
                    <span class="trap-icon">ğŸŒ€</span>
                    <span class="trap-name">ä¼ é€é—¨</span>
                    <span class="trap-desc">è¸©ä¸Šå»ä¼šä¼ é€åˆ°éšæœºä½ç½®</span>
                </div>
                <div class="trap-item">
                    <span class="trap-icon">ğŸ”˜</span>
                    <span class="trap-name">æœºå…³å¼€å…³</span>
                    <span class="trap-desc">æ¿€æ´»æ‰€æœ‰å¼€å…³æ‰èƒ½é€šå…³</span>
                </div>
                <div class="trap-item">
                    <span class="trap-icon">ğŸ”„</span>
                    <span class="trap-name">é‡åŠ›ç¿»è½¬</span>
                    <span class="trap-desc">ä¸Šä¸‹æ–¹å‘è¢«é¢ å€’</span>
                </div>
                <div class="trap-item">
                    <span class="trap-icon">ğŸ‘»</span>
                    <span class="trap-name">éšå½¢çŠ¶æ€</span>
                    <span class="trap-desc">ç©å®¶å˜å¾—åŠé€æ˜</span>
                </div>
                <div class="trap-item">
                    <span class="trap-icon">ğŸ’¨</span>
                    <span class="trap-name">é£åŠ›æ•ˆæœ</span>
                    <span class="trap-desc">é£ä¼šæ¨åŠ¨ç©å®¶ç§»åŠ¨</span>
                </div>
                <div class="trap-item">
                    <span class="trap-icon">ğŸš€</span>
                    <span class="trap-name">ç§»åŠ¨å¹³å°</span>
                    <span class="trap-desc">å¯ä»¥ç«™åœ¨ä¸Šé¢ç§»åŠ¨çš„å¹³å°</span>
                </div>
            </div>
        </div>
        <button id="close-help-btn">å…³é—­</button>
    </div>

    <script>
        // æ¸¸æˆçŠ¶æ€
        const gameState = {
            currentLevel: 1,
            maxLevel: 100,
            maxUnlockedLevel: 1, // æœ€é«˜è§£é”å…³å¡
            player: { x: 50, y: 250 },
            isMoving: false,
            gameOver: false,
            traps: [],
            movingTraps: [],
            specialTraps: [], // ç‰¹æ®Šé™·é˜±æ•°ç»„
            playerFrozen: false, // ç©å®¶æ˜¯å¦è¢«å†°å†»
            freezeEndTime: 0, // å†°å†»ç»“æŸæ—¶é—´
            levelLayouts: {}, // å­˜å‚¨æ¯å…³çš„é™·é˜±å¸ƒå±€
            // ç‰¹æ®Šå…³å¡æœºåˆ¶
            specialMechanics: {
                isInvisible: false,        // ç©å®¶éšå½¢
                isReversed: false,         // åå‘æ§åˆ¶
                isGravityFlipped: false,   // é‡åŠ›ç¿»è½¬
                collectibles: [],          // æ”¶é›†å“
                keys: 0,                   // é’¥åŒ™æ•°é‡
                requiredKeys: 0,           // éœ€è¦çš„é’¥åŒ™æ•°é‡
                timeLimit: 0,              // æ—¶é—´é™åˆ¶ï¼ˆç§’ï¼‰
                startTime: 0,              // å…³å¡å¼€å§‹æ—¶é—´
                isDarkMode: false,         // é»‘æš—æ¨¡å¼
                lightRadius: 100,          // å…‰ç…§åŠå¾„
                isSlippery: false,         // æ»‘å†°æ¨¡å¼
                momentum: { x: 0, y: 0 },  // æ»‘å†°åŠ¨é‡
                teleporters: [],           // ä¼ é€é—¨
                switches: [],              // å¼€å…³
                movingPlatforms: [],       // ç§»åŠ¨å¹³å°
                windForce: { x: 0, y: 0 }  // é£åŠ›
            }
        };

        // æœ¬åœ°å­˜å‚¨ç›¸å…³å‡½æ•°
        function saveProgress() {
            try {
                localStorage.setItem('wizardGame_maxLevel', gameState.maxUnlockedLevel);
                localStorage.setItem('wizardGame_currentLevel', gameState.currentLevel);
            } catch (e) {
                console.log('æ— æ³•ä¿å­˜è¿›åº¦:', e);
            }
        }

        function loadProgress() {
            try {
                const savedMaxLevel = localStorage.getItem('wizardGame_maxLevel');
                const savedCurrentLevel = localStorage.getItem('wizardGame_currentLevel');
                
                if (savedMaxLevel) {
                    gameState.maxUnlockedLevel = parseInt(savedMaxLevel);
                }
                if (savedCurrentLevel) {
                    gameState.currentLevel = Math.min(parseInt(savedCurrentLevel), gameState.maxUnlockedLevel);
                }
            } catch (e) {
                console.log('æ— æ³•åŠ è½½è¿›åº¦:', e);
            }
        }

        function resetProgress() {
            try {
                localStorage.removeItem('wizardGame_maxLevel');
                localStorage.removeItem('wizardGame_currentLevel');
                gameState.maxUnlockedLevel = 1;
                gameState.currentLevel = 1;
            } catch (e) {
                console.log('æ— æ³•é‡ç½®è¿›åº¦:', e);
            }
        }

        // DOMå…ƒç´ 
        const levelDisplay = document.getElementById('level');
        const maxLevelDisplay = document.getElementById('max-level');
        const unlockedLevelsDisplay = document.getElementById('unlocked-levels');
        const messageDisplay = document.getElementById('message');
        const gameContainer = document.getElementById('game-container');
        const player = document.getElementById('player');
        const door = document.getElementById('door');
        const nextBtn = document.getElementById('next-btn');
        const restartBtn = document.getElementById('restart-btn');
        const levelSelectBtn = document.getElementById('level-select-btn');
        const soundToggleBtn = document.getElementById('sound-toggle-btn');
        const musicToggleBtn = document.getElementById('music-toggle-btn');
        const resetProgressBtn = document.getElementById('reset-progress-btn');
        const levelSelectModal = document.getElementById('level-select');
        const levelButtonsContainer = document.getElementById('level-buttons');
        const closeSelectBtn = document.getElementById('close-select-btn');
        const helpBtn = document.getElementById('help-btn');
        const helpModal = document.getElementById('help-modal');
        const closeHelpBtn = document.getElementById('close-help-btn');

        // æ¸¸æˆå˜é‡
        let gameWidth = 800;
        let gameHeight = 500;
        let doorRect = door.getBoundingClientRect();
        let basePlayerSpeed = 8;
        let playerSpeed = 8;
        let animationFrame;
        let trapInterval;
        
        // éŸ³æ•ˆç³»ç»Ÿ
        let audioContext;
        let soundEnabled = true;
        
        // èƒŒæ™¯éŸ³ä¹ç³»ç»Ÿ
        let backgroundMusic;
        let musicEnabled = true;
        let musicVolume = 0.1; // èƒŒæ™¯éŸ³ä¹éŸ³é‡ï¼ˆ10%ï¼‰

        // åˆå§‹åŒ–éŸ³é¢‘ä¸Šä¸‹æ–‡
        function initAudio() {
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                // ä»æœ¬åœ°å­˜å‚¨åŠ è½½éŸ³æ•ˆè®¾ç½®
                const savedSoundSetting = localStorage.getItem('wizardGame_soundEnabled');
                if (savedSoundSetting !== null) {
                    soundEnabled = savedSoundSetting === 'true';
                }
                updateSoundButton();
                
                // åˆå§‹åŒ–èƒŒæ™¯éŸ³ä¹
                initBackgroundMusic();
            } catch (e) {
                console.log('éŸ³é¢‘ä¸æ”¯æŒ:', e);
                soundEnabled = false;
                updateSoundButton();
            }
        }

        // åˆå§‹åŒ–èƒŒæ™¯éŸ³ä¹
        function initBackgroundMusic() {
            try {
                // å°è¯•å¤šç§å¯èƒ½çš„æ–‡ä»¶å
                const possiblePaths = [
                    'background_music.wav',
                    'backgroud_music.wav', // ç”¨æˆ·æåˆ°çš„åŸå§‹åç§°ï¼ˆå¯èƒ½æœ‰æ‹¼å†™é”™è¯¯ï¼‰
                    './background_music.wav',
                    './backgroud_music.wav'
                ];
                
                backgroundMusic = new Audio();
                backgroundMusic.loop = true; // å¾ªç¯æ’­æ”¾
                backgroundMusic.volume = musicVolume;
                
                // ä»æœ¬åœ°å­˜å‚¨åŠ è½½éŸ³ä¹è®¾ç½®
                const savedMusicSetting = localStorage.getItem('wizardGame_musicEnabled');
                const savedMusicVolume = localStorage.getItem('wizardGame_musicVolume');
                
                if (savedMusicSetting !== null) {
                    musicEnabled = savedMusicSetting === 'true';
                }
                // å›ºå®šéŸ³é‡ä¸º10%ï¼Œä¸ä»æœ¬åœ°å­˜å‚¨è¯»å–
                musicVolume = 0.1;
                backgroundMusic.volume = musicVolume;
                
                // æ·»åŠ éŸ³é¢‘äº‹ä»¶ç›‘å¬å™¨
                backgroundMusic.addEventListener('loadstart', () => {
                    console.log('å¼€å§‹åŠ è½½èƒŒæ™¯éŸ³ä¹...');
                });
                
                backgroundMusic.addEventListener('canplaythrough', () => {
                    console.log('èƒŒæ™¯éŸ³ä¹åŠ è½½å®Œæˆï¼Œå¯ä»¥æ’­æ”¾');
                    updateMusicButton();
                    if (musicEnabled && !firstInteraction) {
                        playBackgroundMusic();
                    }
                });
                
                backgroundMusic.addEventListener('error', (e) => {
                    console.log('èƒŒæ™¯éŸ³ä¹åŠ è½½å¤±è´¥:', e);
                    console.log('å½“å‰å°è¯•çš„æ–‡ä»¶è·¯å¾„:', backgroundMusic.src);
                    // å°è¯•ä¸‹ä¸€ä¸ªæ–‡ä»¶è·¯å¾„
                    tryNextMusicPath();
                });
                
                backgroundMusic.addEventListener('play', () => {
                    console.log('èƒŒæ™¯éŸ³ä¹å¼€å§‹æ’­æ”¾');
                });
                
                backgroundMusic.addEventListener('pause', () => {
                    console.log('èƒŒæ™¯éŸ³ä¹æš‚åœ');
                });
                
                // å¼€å§‹å°è¯•åŠ è½½ç¬¬ä¸€ä¸ªè·¯å¾„
                let currentPathIndex = 0;
                
                function tryNextMusicPath() {
                    if (currentPathIndex < possiblePaths.length) {
                        const path = possiblePaths[currentPathIndex];
                        console.log('å°è¯•åŠ è½½éŸ³ä¹æ–‡ä»¶:', path);
                        backgroundMusic.src = path;
                        backgroundMusic.load();
                        currentPathIndex++;
                    } else {
                        console.log('æ‰€æœ‰éŸ³ä¹æ–‡ä»¶è·¯å¾„éƒ½å°è¯•å¤±è´¥');
                        musicEnabled = false;
                        updateMusicButton();

                    }
                }
                
                // å¼€å§‹å°è¯•ç¬¬ä¸€ä¸ªè·¯å¾„
                tryNextMusicPath();
                
                updateMusicButton();
                
            } catch (e) {
                console.log('èƒŒæ™¯éŸ³ä¹åˆå§‹åŒ–å¤±è´¥:', e);
                musicEnabled = false;
                updateMusicButton();
            }
        }

        // æ’­æ”¾èƒŒæ™¯éŸ³ä¹
        function playBackgroundMusic() {
            if (backgroundMusic && musicEnabled) {
                console.log('å°è¯•æ’­æ”¾èƒŒæ™¯éŸ³ä¹, éŸ³é‡:', backgroundMusic.volume);
                console.log('éŸ³ä¹æ–‡ä»¶çŠ¶æ€:', {
                    src: backgroundMusic.src,
                    readyState: backgroundMusic.readyState,
                    paused: backgroundMusic.paused,
                    currentTime: backgroundMusic.currentTime,
                    duration: backgroundMusic.duration
                });
                
                backgroundMusic.play().then(() => {
                    console.log('èƒŒæ™¯éŸ³ä¹æ’­æ”¾æˆåŠŸ');
                }).catch(e => {
                    console.log('èƒŒæ™¯éŸ³ä¹æ’­æ”¾å¤±è´¥:', e);
                    if (e.name === 'NotAllowedError') {
                        console.log('æµè§ˆå™¨é˜»æ­¢äº†è‡ªåŠ¨æ’­æ”¾ï¼Œéœ€è¦ç”¨æˆ·äº¤äº’');

                    }
                });
            } else {
                console.log('æ’­æ”¾æ¡ä»¶ä¸æ»¡è¶³:', {
                    hasBackgroundMusic: !!backgroundMusic,
                    musicEnabled: musicEnabled
                });
            }
        }

        // æš‚åœèƒŒæ™¯éŸ³ä¹
        function pauseBackgroundMusic() {
            if (backgroundMusic) {
                backgroundMusic.pause();
            }
        }

        // åˆ‡æ¢èƒŒæ™¯éŸ³ä¹å¼€å…³
        function toggleMusic() {
            musicEnabled = !musicEnabled;
            localStorage.setItem('wizardGame_musicEnabled', musicEnabled);
            
            if (musicEnabled) {
                console.log('ç”¨æˆ·æ‰‹åŠ¨å¯ç”¨èƒŒæ™¯éŸ³ä¹');
                playBackgroundMusic();
            } else {
                console.log('ç”¨æˆ·æ‰‹åŠ¨ç¦ç”¨èƒŒæ™¯éŸ³ä¹');
                pauseBackgroundMusic();
            }
            
            updateMusicButton();
        }



        // åˆ‡æ¢éŸ³æ•ˆå¼€å…³
        function toggleSound() {
            soundEnabled = !soundEnabled;
            localStorage.setItem('wizardGame_soundEnabled', soundEnabled);
            updateSoundButton();
            
            // æ’­æ”¾æµ‹è¯•éŸ³æ•ˆ
            if (soundEnabled) {
                playClickSound();
            }
        }

        // æ›´æ–°éŸ³æ•ˆæŒ‰é’®æ˜¾ç¤º
        function updateSoundButton() {
            if (soundToggleBtn) {
                soundToggleBtn.textContent = soundEnabled ? 'ğŸ”Š éŸ³æ•ˆ' : 'ğŸ”‡ éŸ³æ•ˆ';
                soundToggleBtn.style.opacity = soundEnabled ? '1' : '0.6';
            }
        }

        // æ›´æ–°èƒŒæ™¯éŸ³ä¹æŒ‰é’®æ˜¾ç¤º
        function updateMusicButton() {
            if (musicToggleBtn) {
                musicToggleBtn.textContent = musicEnabled ? 'ğŸµ éŸ³ä¹' : 'ğŸ”‡ éŸ³ä¹';
                musicToggleBtn.style.opacity = musicEnabled ? '1' : '0.6';
            }
        }



        // ç”Ÿæˆçˆ†ç‚¸éŸ³æ•ˆ
        function playExplosionSound() {
            if (!soundEnabled || !audioContext) return;
            
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            // çˆ†ç‚¸éŸ³æ•ˆï¼šä½é¢‘å™ªéŸ³
            oscillator.type = 'sawtooth';
            oscillator.frequency.setValueAtTime(150, audioContext.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(50, audioContext.currentTime + 0.5);
            
            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
            
            oscillator.start();
            oscillator.stop(audioContext.currentTime + 0.5);
        }

        // ç”Ÿæˆè¿‡å…³éŸ³æ•ˆ
        function playSuccessSound() {
            if (!soundEnabled || !audioContext) return;
            
            // æ’­æ”¾ä¸€ç³»åˆ—ä¸Šå‡çš„éŸ³ç¬¦
            const notes = [523.25, 659.25, 783.99, 1046.50]; // C5, E5, G5, C6
            
            notes.forEach((frequency, index) => {
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime + index * 0.15);
                
                gainNode.gain.setValueAtTime(0, audioContext.currentTime + index * 0.15);
                gainNode.gain.linearRampToValueAtTime(0.2, audioContext.currentTime + index * 0.15 + 0.05);
                gainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + index * 0.15 + 0.3);
                
                oscillator.start(audioContext.currentTime + index * 0.15);
                oscillator.stop(audioContext.currentTime + index * 0.15 + 0.3);
            });
        }

        // ç”ŸæˆæŒ‰é”®éŸ³æ•ˆ
        function playClickSound() {
            if (!soundEnabled || !audioContext) return;
            
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.type = 'square';
            oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(600, audioContext.currentTime + 0.1);
            
            gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
            
            oscillator.start();
            oscillator.stop(audioContext.currentTime + 0.1);
        }
        
        // é”®ç›˜çŠ¶æ€è¿½è¸ª
        const keys = {
            ArrowUp: false,
            ArrowDown: false,
            ArrowLeft: false,
            ArrowRight: false
        };

        // æ›´æ–°è¿›åº¦æ˜¾ç¤º
        function updateProgressDisplay() {
            maxLevelDisplay.textContent = gameState.maxUnlockedLevel;
            unlockedLevelsDisplay.textContent = gameState.maxUnlockedLevel;
        }

        // åˆ›å»ºå…³å¡é€‰æ‹©æŒ‰é’®
        function createLevelButtons() {
            levelButtonsContainer.innerHTML = '';
            
            for (let i = 1; i <= gameState.maxLevel; i++) {
                const btn = document.createElement('button');
                btn.textContent = i;
                btn.className = 'level-btn';
                
                if (i <= gameState.maxUnlockedLevel) {
                    if (i === gameState.currentLevel) {
                        btn.className += ' current';
                    } else {
                        btn.className += ' unlocked';
                    }
                    btn.onclick = () => selectLevel(i);
                } else {
                    btn.className += ' locked';
                    btn.disabled = true;
                }
                
                levelButtonsContainer.appendChild(btn);
            }
        }

        // é€‰æ‹©å…³å¡
        function selectLevel(level) {
            if (level <= gameState.maxUnlockedLevel) {
                playClickSound();
                gameState.currentLevel = level;
                saveProgress();
                levelSelectModal.classList.add('hidden');
                startLevel();
            }
        }

        // å¼€å§‹å…³å¡
        function startLevel() {
            gameState.gameOver = false;
            gameState.player = { x: 50, y: 250 };
            gameState.traps = [];
            gameState.movingTraps = [];
            
            messageDisplay.textContent = '';
            nextBtn.classList.add('hidden');
            
            // æ¸…é™¤ä¹‹å‰çš„é™·é˜±
            document.querySelectorAll('.trap, .spike, .moving-trap').forEach(el => el.remove());
            
            updatePlayerPosition();
            setupLevel();
            updateProgressDisplay();
        }

        // åˆå§‹åŒ–æ¸¸æˆ
        function initGame() {
            // åˆå§‹åŒ–éŸ³é¢‘ç³»ç»Ÿ
            initAudio();
            
            // åŠ è½½ä¿å­˜çš„è¿›åº¦
            loadProgress();
            
            gameState.gameOver = false;
            gameState.player = { x: 50, y: 250 };
            gameState.traps = [];
            gameState.movingTraps = [];
            
            messageDisplay.textContent = '';
            nextBtn.classList.add('hidden');
            
            // ç¡®ä¿å…³å¡é€‰æ‹©å™¨æ˜¯éšè—çš„
            levelSelectModal.classList.add('hidden');
            
            updatePlayerPosition();
            setupLevel();
            updateProgressDisplay();
            
            // æ¸…é™¤ä¹‹å‰çš„é™·é˜±
            document.querySelectorAll('.trap, .spike, .moving-trap').forEach(el => el.remove());
        }

        // è®¾ç½®å½“å‰å…³å¡
        function setupLevel() {
            levelDisplay.textContent = gameState.currentLevel;
            
            // æ ¹æ®å…³å¡è°ƒæ•´ç©å®¶ç§»åŠ¨é€Ÿåº¦ï¼ˆé«˜å…³å¡ç¨å¾®å¿«ä¸€ç‚¹ä»¥åº”å¯¹æ›´å¤šé™·é˜±ï¼‰
            playerSpeed = basePlayerSpeed + Math.floor(gameState.currentLevel / 20);
            
            // é‡ç½®ç‰¹æ®Šæœºåˆ¶
            resetSpecialMechanics();
            
            // è®¾ç½®ç‰¹æ®Šå…³å¡æœºåˆ¶
            setupSpecialMechanics();
            
            // æ˜¾ç¤ºå…³å¡ä¸»é¢˜æç¤º
            showLevelTheme();
            
            // æ ¹æ®å…³å¡è®¾ç½®é™·é˜±ï¼ˆç”Ÿæˆæ–°å¸ƒå±€ï¼‰
            createTraps(false);
            
            // è®¾ç½®ç§»åŠ¨é™·é˜±ï¼ˆç”Ÿæˆæ–°å¸ƒå±€ï¼‰
            setupMovingTraps(false);
        }

        // é‡ç½®ç‰¹æ®Šæœºåˆ¶
        function resetSpecialMechanics() {
            const sm = gameState.specialMechanics;
            sm.isInvisible = false;
            sm.isReversed = false;
            sm.isGravityFlipped = false;
            sm.collectibles = [];
            sm.keys = 0;
            sm.requiredKeys = 0;
            sm.timeLimit = 0;
            sm.startTime = 0;
            sm.isDarkMode = false;
            sm.lightRadius = 100;
            sm.isSlippery = false;
            sm.momentum = { x: 0, y: 0 };
            sm.teleporters = [];
            sm.switches = [];
            sm.movingPlatforms = [];
            sm.windForce = { x: 0, y: 0 };
            
            // æ¸…é™¤UIå…ƒç´ 
            document.querySelectorAll('.collectible, .key-item, .teleporter, .switch, .moving-platform, .timer-display').forEach(el => el.remove());
            
            // é‡ç½®ç©å®¶æ ·å¼
            player.classList.remove('player-invisible', 'gravity-flipped');
            gameContainer.classList.remove('dark-mode', 'slippery-mode');
        }
        
        // è®¾ç½®ç‰¹æ®Šå…³å¡æœºåˆ¶
        function setupSpecialMechanics() {
            const level = gameState.currentLevel;
            const sm = gameState.specialMechanics;
            
            // ç¬¬5å…³ï¼šæ”¶é›†é’»çŸ³å…³å¡
            if (level === 5) {
                createCollectibles(3);
            }
            // ç¬¬8å…³ï¼šé’¥åŒ™é—¨å…³å¡
            else if (level === 8) {
                sm.requiredKeys = 2;
                createKeys(2);
            }
            // ç¬¬12å…³ï¼šæ—¶é—´é™åˆ¶å…³å¡
            else if (level === 12) {
                sm.timeLimit = 15; // 15ç§’é™åˆ¶
                sm.startTime = Date.now();
                createTimerDisplay();
            }
            // ç¬¬15å…³ï¼šé»‘æš—å…³å¡
            else if (level === 15) {
                sm.isDarkMode = true;
                sm.lightRadius = 80;
                gameContainer.classList.add('dark-mode');
            }
            // ç¬¬18å…³ï¼šåå‘æ§åˆ¶å…³å¡
            else if (level === 18) {
                sm.isReversed = true;
            }
            // ç¬¬22å…³ï¼šæ»‘å†°å…³å¡
            else if (level === 22) {
                sm.isSlippery = true;
                gameContainer.classList.add('slippery-mode');
            }
            // ç¬¬25å…³ï¼šä¼ é€é—¨å…³å¡
            else if (level === 25) {
                createTeleporters(2);
            }
            // ç¬¬28å…³ï¼šå¼€å…³é—¨å…³å¡
            else if (level === 28) {
                createSwitches(3);
            }
            // ç¬¬32å…³ï¼šé‡åŠ›ç¿»è½¬å…³å¡
            else if (level === 32) {
                sm.isGravityFlipped = true;
                player.classList.add('gravity-flipped');
            }
            // ç¬¬35å…³ï¼šç©å®¶éšå½¢å…³å¡
            else if (level === 35) {
                sm.isInvisible = true;
                player.classList.add('player-invisible');
            }
            // ç¬¬40å…³ï¼šé£åŠ›å…³å¡
            else if (level === 40) {
                sm.windForce = { x: 2, y: 0 }; // å‘å³çš„é£
            }
            // ç¬¬45å…³ï¼šç§»åŠ¨å¹³å°å…³å¡
            else if (level === 45) {
                createMovingPlatforms(2);
            }
            // ç¬¬50å…³ï¼šç»¼åˆæŒ‘æˆ˜
            else if (level === 50) {
                sm.timeLimit = 20;
                sm.startTime = Date.now();
                sm.requiredKeys = 1;
                createTimerDisplay();
                createKeys(1);
                createCollectibles(2);
            }
            // ç¬¬55å…³ï¼šå¤šé‡ä¼ é€è¿·å®«
            else if (level === 55) {
                createTeleporters(4);
                sm.isDarkMode = true;
                gameContainer.classList.add('dark-mode');
            }
            // ç¬¬60å…³ï¼šæé€ŸæŒ‘æˆ˜
            else if (level === 60) {
                sm.timeLimit = 10;
                sm.startTime = Date.now();
                sm.isSlippery = true;
                createTimerDisplay();
                gameContainer.classList.add('slippery-mode');
            }
            // ç¬¬65å…³ï¼šéšå½¢æ³•å¸ˆ
            else if (level === 65) {
                sm.isInvisible = true;
                sm.isReversed = true;
                player.classList.add('player-invisible');
            }
            // ç¬¬70å…³ï¼šé£æš´ä¸­å¿ƒ
            else if (level === 70) {
                sm.windForce = { x: 3, y: 2 };
                sm.timeLimit = 25;
                sm.startTime = Date.now();
                createTimerDisplay();
            }
            // ç¬¬75å…³ï¼šé‡åŠ›æ··ä¹±
            else if (level === 75) {
                sm.isGravityFlipped = true;
                sm.isSlippery = true;
                player.classList.add('gravity-flipped');
                gameContainer.classList.add('slippery-mode');
            }
            // ç¬¬80å…³ï¼šç»ˆææœºå…³
            else if (level === 80) {
                createSwitches(5);
                sm.timeLimit = 30;
                sm.startTime = Date.now();
                createTimerDisplay();
                sm.isDarkMode = true;
                gameContainer.classList.add('dark-mode');
            }
            // ç¬¬85å…³ï¼šè®°å¿†è¯•ç‚¼
            else if (level === 85) {
                createCollectibles(5);
                createKeys(3);
                sm.requiredKeys = 3;
                sm.isReversed = true;
            }
            // ç¬¬90å…³ï¼šæ—¶ç©ºæ‰­æ›²
            else if (level === 90) {
                sm.timeLimit = 15;
                sm.startTime = Date.now();
                createTimerDisplay();
                createTeleporters(3);
                sm.windForce = { x: -2, y: 1 };
                sm.isSlippery = true;
                gameContainer.classList.add('slippery-mode');
            }
            // ç¬¬95å…³ï¼šæœ€ç»ˆè€ƒéªŒå‰å¥
            else if (level === 95) {
                createCollectibles(3);
                createKeys(2);
                sm.requiredKeys = 2;
                createSwitches(3);
                sm.timeLimit = 35;
                sm.startTime = Date.now();
                createTimerDisplay();
                sm.isDarkMode = true;
                gameContainer.classList.add('dark-mode');
            }
            // ç¬¬99å…³ï¼šç»ˆæå‰å¤œ
            else if (level === 99) {
                sm.isInvisible = true;
                sm.isReversed = true;
                sm.isGravityFlipped = true;
                sm.isSlippery = true;
                sm.timeLimit = 20;
                sm.startTime = Date.now();
                createTimerDisplay();
                createTeleporters(2);
                sm.windForce = { x: 2, y: -1 };
                player.classList.add('player-invisible', 'gravity-flipped');
                gameContainer.classList.add('dark-mode', 'slippery-mode');
            }
            // ç¬¬100å…³ï¼šé‡ç”Ÿä¹‹é—¨
            else if (level === 100) {
                // æœ€ç»ˆå…³å¡ï¼šæ‰€æœ‰æœºåˆ¶çš„ç»ˆæç»„åˆ
                createCollectibles(1); // åªéœ€è¦1ä¸ªç‰¹æ®Šæ°´æ™¶
                createKeys(1);
                sm.requiredKeys = 1;
                createSwitches(1);
                createTeleporters(1);
                sm.timeLimit = 60; // ç»™è¶³å¤Ÿæ—¶é—´
                sm.startTime = Date.now();
                createTimerDisplay();
                // ä¸æ·»åŠ å¤ªå¤šå¹²æ‰°ï¼Œè®©ç©å®¶ä¸“æ³¨äºæœ€åçš„æŒ‘æˆ˜
            }
            
            // é«˜çº§å…³å¡çš„éšæœºç‰¹æ®Šæœºåˆ¶ (æ¯10å…³ä¸€æ¬¡ç‰¹æ®Šæœºåˆ¶)
            if (level > 60 && level % 10 === 0 && ![70, 80, 90, 100].includes(level)) {
                const randomMechanics = [
                    () => { sm.isDarkMode = true; gameContainer.classList.add('dark-mode'); },
                    () => { sm.isReversed = true; },
                    () => { sm.isSlippery = true; gameContainer.classList.add('slippery-mode'); },
                    () => { sm.windForce = { x: Math.random() * 4 - 2, y: Math.random() * 4 - 2 }; },
                    () => { createTeleporters(Math.floor(Math.random() * 3) + 1); },
                    () => { 
                        sm.timeLimit = 20 + Math.random() * 10; 
                        sm.startTime = Date.now(); 
                        createTimerDisplay(); 
                    }
                ];
                
                const randomMechanic = randomMechanics[Math.floor(Math.random() * randomMechanics.length)];
                randomMechanic();
            }
        }
        
        // æ˜¾ç¤ºå…³å¡ä¸»é¢˜
        function showLevelTheme() {
            let themeMessage = '';
            
            if (gameState.currentLevel === 1) {
                themeMessage = 'ğŸŒ… åˆæ¬¡è§‰é†’ï¼šæ³•å¸ˆä»æ²‰ç¡ä¸­è‹é†’ï¼Œè¸ä¸Šé‡ç”Ÿä¹‹è·¯';
            } else if (gameState.currentLevel === 2) {
                themeMessage = 'âš”ï¸ è®°å¿†ç¢ç‰‡ï¼šå¾€æ˜”çš„æˆ˜æ–—è®°å¿†å¼€å§‹å¤è‹';
            } else if (gameState.currentLevel >= 3 && gameState.currentLevel <= 10) {
                themeMessage = 'ğŸ‘» å¹»è±¡è¿·å®«ï¼šè™šå®éš¾è¾¨çš„å¹»å¢ƒè€ƒéªŒç€ä½ çš„æ„ŸçŸ¥';
            } else if (gameState.currentLevel >= 11 && gameState.currentLevel <= 20) {
                themeMessage = 'ğŸ§Š å†°å°çŒåœºï¼šå¯’å†°ä¸è¿½çŒè€…çš„è‡´å‘½èˆè¹ˆ';
            } else if (gameState.currentLevel >= 21 && gameState.currentLevel <= 30) {
                themeMessage = 'ğŸ’¥ å´©åç©ºé—´ï¼šç°å®å¼€å§‹åˆ†è£‚ï¼Œé‡åŠ›å¤±å»æ§åˆ¶';
            } else if (gameState.currentLevel >= 31 && gameState.currentLevel <= 40) {
                themeMessage = 'ğŸª é•œåƒä¸–ç•Œï¼šåœ¨åè½¬çš„ç°å®ä¸­å¯»æ‰¾çœŸç›¸';
            } else if (gameState.currentLevel >= 41 && gameState.currentLevel <= 60) {
                themeMessage = 'âš¡ æ—¶ç©ºä¹±æµï¼šæ—¶é—´ä¸ç©ºé—´çš„æ‰­æ›²æ”¹å˜ç€ä¸€åˆ‡';
            } else if (gameState.currentLevel >= 61 && gameState.currentLevel <= 80) {
                themeMessage = 'ğŸŒ€ å¾ªç¯æ·±æ¸Šï¼šå¤šé‡å¾ªç¯äº¤ç»‡ï¼Œè€ƒéªŒç€ä½ çš„æ„å¿—';
            } else if (gameState.currentLevel >= 81) {
                themeMessage = 'ğŸ”¥ ç»ˆæè¯•ç‚¼ï¼šæ‰“ç ´å¾ªç¯çš„æœ€åè€ƒéªŒï¼Œé‡ç”Ÿåœ¨å³';
            }
            
            // ç‰¹æ®Šå…³å¡çš„ç‰¹æ®Šæç¤º
            const sm = gameState.specialMechanics;
            if (gameState.currentLevel === 5) {
                themeMessage = 'ğŸ’ è®°å¿†æ°´æ™¶ï¼šæ”¶é›†æ‰€æœ‰æ°´æ™¶æ¢å¤è®°å¿†';
            } else if (gameState.currentLevel === 8) {
                themeMessage = 'ğŸ—ï¸ å°å°ä¹‹é—¨ï¼šå¯»æ‰¾é’¥åŒ™è§£å¼€å°å°';
            } else if (gameState.currentLevel === 12) {
                themeMessage = 'â° æ—¶é—´è£‚ç¼ï¼šåœ¨æ—¶é—´å´©å¡Œå‰é€ƒè„±';
            } else if (gameState.currentLevel === 15) {
                themeMessage = 'ğŸŒ‘ é»‘æš—æ·±æ¸Šï¼šåœ¨æ— å°½é»‘æš—ä¸­å¯»æ‰¾å…‰æ˜';
            } else if (gameState.currentLevel === 18) {
                themeMessage = 'ğŸ”„ æ··ä¹±æ„è¯†ï¼šæ€ç»´è¢«æ‰­æ›²äº†';
            } else if (gameState.currentLevel === 22) {
                themeMessage = 'ğŸ§Š å†°éœœä¸–ç•Œï¼šåœ°é¢ç»“å†°ï¼Œå°å¿ƒæ»‘å€’';
            } else if (gameState.currentLevel === 25) {
                themeMessage = 'ğŸŒ€ ç©ºé—´é—¨ï¼šåˆ©ç”¨ä¼ é€é—¨ç©¿è¶Šç©ºé—´';
            } else if (gameState.currentLevel === 28) {
                themeMessage = 'ğŸ”˜ æœºå…³è¿·å®«ï¼šæ¿€æ´»æ‰€æœ‰æœºå…³å¼€å¯å‡ºè·¯';
            } else if (gameState.currentLevel === 32) {
                themeMessage = 'ğŸ”„ é‡åŠ›å¼‚å¸¸ï¼šä¸Šä¸‹é¢ å€’çš„ä¸–ç•Œ';
            } else if (gameState.currentLevel === 35) {
                themeMessage = 'ğŸ‘» çµä½“çŠ¶æ€ï¼šä½ å˜å¾—åŠé€æ˜äº†';
            } else if (gameState.currentLevel === 40) {
                themeMessage = 'ğŸ’¨ é£æš´ä¹‹çœ¼ï¼šå¼ºé£åœ¨æ¨åŠ¨ç€ä½ ';
            } else if (gameState.currentLevel === 45) {
                themeMessage = 'ğŸš€ æµ®ç©ºå¹³å°ï¼šè·³ä¸Šç§»åŠ¨çš„å¹³å°';
            } else if (gameState.currentLevel === 50) {
                themeMessage = 'ğŸ”¥ ç»ˆæè€ƒéªŒï¼šæ—¶é—´ã€é’¥åŒ™ã€æ°´æ™¶çš„ä¸‰é‡è¯•ç‚¼';
            } else if (gameState.currentLevel === 55) {
                themeMessage = 'ğŸŒ€ ä¼ é€è¿·å®«ï¼šåœ¨é»‘æš—ä¸­å¯»æ‰¾æ­£ç¡®çš„ä¼ é€é—¨';
            } else if (gameState.currentLevel === 60) {
                themeMessage = 'âš¡ æé€Ÿé€ƒè„±ï¼šæ»‘å†°åœºä¸Šçš„ç”Ÿæ­»æ—¶é€Ÿ';
            } else if (gameState.currentLevel === 65) {
                themeMessage = 'ğŸ‘» éšå½¢æ³•å¸ˆï¼šåœ¨æ··ä¹±ä¸­ä¿æŒéšå½¢';
            } else if (gameState.currentLevel === 70) {
                themeMessage = 'ğŸŒªï¸ é£æš´ä¸­å¿ƒï¼šåœ¨ç‹‚é£ä¸­å¯»æ‰¾å‡ºè·¯';
            } else if (gameState.currentLevel === 75) {
                themeMessage = 'ğŸ”„ é‡åŠ›æ··ä¹±ï¼šé¢ å€’ä¸–ç•Œçš„æ»‘å†°æŒ‘æˆ˜';
            } else if (gameState.currentLevel === 80) {
                themeMessage = 'ğŸ”˜ ç»ˆææœºå…³ï¼šé»‘æš—ä¸­çš„äº”é‡æœºå…³';
            } else if (gameState.currentLevel === 85) {
                themeMessage = 'ğŸ§  è®°å¿†è¯•ç‚¼ï¼šåœ¨æ··ä¹±ä¸­æ”¶é›†å¤±è½çš„è®°å¿†';
            } else if (gameState.currentLevel === 90) {
                themeMessage = 'âš¡ æ—¶ç©ºæ‰­æ›²ï¼šä¼ é€é—¨ä¸­çš„æ»‘å†°é£æš´';
            } else if (gameState.currentLevel === 95) {
                themeMessage = 'ğŸŒŸ æœ€ç»ˆè€ƒéªŒï¼šé»‘æš—ä¸­çš„ç»¼åˆè¯•ç‚¼';
            } else if (gameState.currentLevel === 99) {
                themeMessage = 'ğŸ’€ ç»ˆæå‰å¤œï¼šæ‰€æœ‰è¯…å’’çš„é›†åˆä½“';
            } else if (gameState.currentLevel === 100) {
                themeMessage = 'ğŸŒ… é‡ç”Ÿä¹‹é—¨ï¼šæ‰“ç ´å¾ªç¯ï¼Œè·å¾—çœŸæ­£çš„è‡ªç”±';
            }
            
            if (themeMessage) {
                messageDisplay.textContent = themeMessage;
                setTimeout(() => {
                    if (messageDisplay.textContent === themeMessage) {
                        messageDisplay.textContent = '';
                    }
                }, 3000);
            }
        }

        // åˆ›å»ºæ”¶é›†å“
        function createCollectibles(count) {
            const sm = gameState.specialMechanics;
            for (let i = 0; i < count; i++) {
                const collectible = document.createElement('div');
                collectible.className = 'collectible';
                collectible.style.left = (150 + Math.random() * (gameWidth - 300)) + 'px';
                collectible.style.top = (50 + Math.random() * (gameHeight - 150)) + 'px';
                gameContainer.appendChild(collectible);
                sm.collectibles.push(collectible);
            }
        }
        
        // åˆ›å»ºé’¥åŒ™
        function createKeys(count) {
            const sm = gameState.specialMechanics;
            for (let i = 0; i < count; i++) {
                const key = document.createElement('div');
                key.className = 'key-item';
                key.style.left = (150 + Math.random() * (gameWidth - 300)) + 'px';
                key.style.top = (50 + Math.random() * (gameHeight - 150)) + 'px';
                gameContainer.appendChild(key);
            }
        }
        
        // åˆ›å»ºä¼ é€é—¨
        function createTeleporters(count) {
            const sm = gameState.specialMechanics;
            for (let i = 0; i < count; i++) {
                const teleporter = document.createElement('div');
                teleporter.className = 'teleporter';
                teleporter.style.left = (100 + Math.random() * (gameWidth - 260)) + 'px';
                teleporter.style.top = (50 + Math.random() * (gameHeight - 150)) + 'px';
                teleporter.dataset.teleporterId = i;
                gameContainer.appendChild(teleporter);
                sm.teleporters.push(teleporter);
            }
        }
        
        // åˆ›å»ºå¼€å…³
        function createSwitches(count) {
            const sm = gameState.specialMechanics;
            for (let i = 0; i < count; i++) {
                const switchEl = document.createElement('div');
                switchEl.className = 'switch';
                switchEl.style.left = (150 + Math.random() * (gameWidth - 300)) + 'px';
                switchEl.style.top = (50 + Math.random() * (gameHeight - 150)) + 'px';
                switchEl.dataset.activated = 'false';
                gameContainer.appendChild(switchEl);
                sm.switches.push(switchEl);
            }
        }
        
        // åˆ›å»ºç§»åŠ¨å¹³å°
        function createMovingPlatforms(count) {
            const sm = gameState.specialMechanics;
            for (let i = 0; i < count; i++) {
                const platform = document.createElement('div');
                platform.className = 'moving-platform';
                platform.style.left = (100 + Math.random() * (gameWidth - 280)) + 'px';
                platform.style.top = (100 + Math.random() * (gameHeight - 200)) + 'px';
                
                const platformData = {
                    element: platform,
                    x: parseFloat(platform.style.left),
                    y: parseFloat(platform.style.top),
                    speedX: (Math.random() - 0.5) * 4,
                    speedY: (Math.random() - 0.5) * 4,
                    width: 80,
                    height: 20
                };
                
                gameContainer.appendChild(platform);
                sm.movingPlatforms.push(platformData);
            }
        }
        
        // åˆ›å»ºè®¡æ—¶å™¨æ˜¾ç¤º
        function createTimerDisplay() {
            const timer = document.createElement('div');
            timer.className = 'timer-display';
            timer.id = 'timer-display';
            gameContainer.appendChild(timer);
        }
        
        // ç”Ÿæˆå…³å¡å¸ƒå±€ç§å­
        function generateLevelSeed(level) {
            return level * 12345; // ä½¿ç”¨å…³å¡æ•°ç”Ÿæˆå›ºå®šç§å­
        }
        
        // åŸºäºç§å­çš„éšæœºæ•°ç”Ÿæˆå™¨
        function seededRandom(seed) {
            const x = Math.sin(seed) * 10000;
            return x - Math.floor(x);
        }

        // åˆ›å»ºç‰¹æ®Šé™·é˜± - æ ¹æ®å…³å¡ä¸»é¢˜é€‰æ‹©é™·é˜±ç±»å‹
        function createSpecialTrap(trap, seed, seedCounter, sizeMultiplier) {
            // æ ¹æ®å…³å¡èŒƒå›´ç¡®å®šå¯ç”¨çš„é™·é˜±ç±»å‹
            let availableTypes = [];
            
            if (gameState.currentLevel >= 3 && gameState.currentLevel <= 10) {
                // ç¬¬3-10å…³ï¼šåŸºç¡€ç‰¹æ®Šé™·é˜±
                availableTypes = ['invisible', 'teleport', 'bounce'];
            } else if (gameState.currentLevel >= 11 && gameState.currentLevel <= 20) {
                // ç¬¬11-20å…³ï¼šè¿½è¸ªå’Œå†°å†»ä¸»é¢˜
                availableTypes = ['hunter', 'freeze', 'invisible'];
            } else if (gameState.currentLevel >= 21 && gameState.currentLevel <= 30) {
                // ç¬¬21-30å…³ï¼šåˆ†è£‚å’Œé‡åŠ›ä¸»é¢˜
                availableTypes = ['split', 'gravity', 'teleport'];
            } else if (gameState.currentLevel >= 31 && gameState.currentLevel <= 40) {
                // ç¬¬31-40å…³ï¼šé•œåƒå’Œé—ªçƒä¸»é¢˜
                availableTypes = ['mirror', 'blink', 'hunter'];
            } else if (gameState.currentLevel >= 41 && gameState.currentLevel <= 60) {
                // ç¬¬41-60å…³ï¼šå˜åŒ–æ•ˆæœä¸»é¢˜
                availableTypes = ['shrink', 'speed', 'clone', 'bounce'];
            } else if (gameState.currentLevel >= 61 && gameState.currentLevel <= 80) {
                // ç¬¬61-80å…³ï¼šæ··åˆè¿›é˜¶
                availableTypes = ['gravity', 'split', 'mirror', 'freeze', 'hunter'];
            } else if (gameState.currentLevel >= 81) {
                // ç¬¬81-100å…³ï¼šç»ˆææŒ‘æˆ˜ï¼Œæ‰€æœ‰ç±»å‹
                availableTypes = ['invisible', 'teleport', 'hunter', 'blink', 'gravity', 'split', 'mirror', 'freeze', 'bounce', 'shrink', 'speed', 'clone'];
            }
            
            const typeIndex = Math.floor(seededRandom(seed + seedCounter++) * availableTypes.length);
            const trapType = availableTypes[typeIndex];
            
            const baseSize = 40;
            const width = baseSize * sizeMultiplier;
            const height = baseSize * sizeMultiplier;
            const left = 100 + seededRandom(seed + seedCounter++) * (gameWidth - 200 - width);
            const bottom = seededRandom(seed + seedCounter++) * (gameHeight - height - 50);
            
            switch(trapType) {
                case 'invisible':
                    trap.className = 'invisible-trap';
                    trap.dataset.trapType = 'invisible';
                    trap.dataset.revealed = 'false';
                    break;
                case 'teleport':
                    trap.className = 'teleport-trap';
                    trap.dataset.trapType = 'teleport';
                    break;
                case 'hunter':
                    trap.className = 'hunter-trap';
                    trap.dataset.trapType = 'hunter';
                    trap.dataset.huntSpeed = '2';
                    break;
                case 'blink':
                    trap.className = 'blink-trap';
                    trap.dataset.trapType = 'blink';
                    trap.dataset.visible = 'true';
                    break;
                case 'gravity':
                    trap.className = 'gravity-trap';
                    trap.dataset.trapType = 'gravity';
                    trap.dataset.pullForce = '3';
                    break;
                case 'split':
                    trap.className = 'split-trap';
                    trap.dataset.trapType = 'split';
                    trap.dataset.hasTriggered = 'false';
                    break;
                case 'mirror':
                    trap.className = 'mirror-trap';
                    trap.dataset.trapType = 'mirror';
                    break;
                case 'freeze':
                    trap.className = 'freeze-trap';
                    trap.dataset.trapType = 'freeze';
                    break;
                case 'bounce':
                    trap.className = 'bounce-trap';
                    trap.dataset.trapType = 'bounce';
                    break;
                case 'shrink':
                    trap.className = 'shrink-trap';
                    trap.dataset.trapType = 'shrink';
                    break;
                case 'speed':
                    trap.className = 'speed-trap';
                    trap.dataset.trapType = 'speed';
                    break;
                case 'clone':
                    trap.className = 'clone-trap';
                    trap.dataset.trapType = 'clone';
                    trap.dataset.hasTriggered = 'false';
                    break;
            }
            
            trap.style.width = width + 'px';
            trap.style.height = height + 'px';
            trap.style.left = left + 'px';
            trap.style.bottom = bottom + 'px';
            
            // ä¿å­˜ç‰¹æ®Šé™·é˜±ä¿¡æ¯
            gameState.levelLayouts[gameState.currentLevel].staticTraps.push({
                className: trap.className,
                trapType: trapType,
                width: width,
                height: height,
                left: left,
                bottom: bottom,
                data: {...trap.dataset}
            });
            
            return seedCounter;
        }
        
        // è·¯å¾„æŸ¥æ‰¾ç®—æ³• - ç¡®ä¿ç©å®¶å¯ä»¥åˆ°è¾¾é—¨å£
        function hasValidPath(traps, startX, startY, endX, endY) {
            const gridSize = 15; // å‡å°ç½‘æ ¼å¤§å°ä»¥æé«˜ç²¾åº¦
            const cols = Math.ceil(gameWidth / gridSize);
            const rows = Math.ceil(gameHeight / gridSize);
            
            // åˆ›å»ºç½‘æ ¼åœ°å›¾ (false = å¯é€šè¡Œ, true = éšœç¢)
            const grid = Array(rows).fill().map(() => Array(cols).fill(false));
            
            // æ ‡è®°é™·é˜±ä½ç½®ï¼Œå¢åŠ ä¸€äº›ç¼“å†²åŒº
            traps.forEach(trap => {
                const buffer = 1; // å¢åŠ 1æ ¼ç¼“å†²åŒº
                const left = Math.max(0, Math.floor(trap.left / gridSize) - buffer);
                const right = Math.min(cols, Math.ceil((trap.left + trap.width) / gridSize) + buffer);
                
                // å¤„ç†ä¸åŒç±»å‹çš„é™·é˜±åæ ‡ç³»ç»Ÿ
                let top, bottom;
                if (trap.className === 'spike') {
                    // å°–åˆºé™·é˜±åœ¨åº•éƒ¨ï¼Œå æ®åº•éƒ¨å‡ è¡Œ
                    top = Math.max(0, Math.floor((gameHeight - 30) / gridSize) - buffer);
                    bottom = rows;
                } else {
                    // å…¶ä»–é™·é˜±ä½¿ç”¨topåæ ‡
                    top = Math.max(0, Math.floor(trap.top / gridSize) - buffer);
                    bottom = Math.min(rows, Math.ceil((trap.top + trap.height) / gridSize) + buffer);
                }
                
                // æ ‡è®°ç½‘æ ¼ä¸ºéšœç¢
                for (let y = top; y < bottom; y++) {
                    for (let x = left; x < right; x++) {
                        if (y >= 0 && y < rows && x >= 0 && x < cols) {
                            grid[y][x] = true; // æ ‡è®°ä¸ºéšœç¢
                        }
                    }
                }
            });
            
            // è½¬æ¢åæ ‡åˆ°ç½‘æ ¼ç³»ç»Ÿ
            const startGridX = Math.floor(startX / gridSize);
            const startGridY = Math.floor((gameHeight - startY) / gridSize);
            const endGridX = Math.floor(endX / gridSize);
            const endGridY = Math.floor((gameHeight - endY) / gridSize);
            
            // ç¡®ä¿èµ·å§‹ç‚¹å’Œç»ˆç‚¹åœ¨æœ‰æ•ˆèŒƒå›´å†…
            if (startGridX < 0 || startGridX >= cols || startGridY < 0 || startGridY >= rows ||
                endGridX < 0 || endGridX >= cols || endGridY < 0 || endGridY >= rows) {
                console.log('èµ·å§‹ç‚¹æˆ–ç»ˆç‚¹è¶…å‡ºè¾¹ç•Œ');
                return false;
            }
            
            // æ¸…ç†èµ·å§‹ç‚¹å’Œç»ˆç‚¹å‘¨å›´çš„éšœç¢ç‰©ï¼Œç¡®ä¿å®ƒä»¬å¯é€šè¡Œ
            const clearRadius = 2;
            for (let dy = -clearRadius; dy <= clearRadius; dy++) {
                for (let dx = -clearRadius; dx <= clearRadius; dx++) {
                    const clearX = startGridX + dx;
                    const clearY = startGridY + dy;
                    if (clearX >= 0 && clearX < cols && clearY >= 0 && clearY < rows) {
                        grid[clearY][clearX] = false;
                    }
                    
                    const clearEndX = endGridX + dx;
                    const clearEndY = endGridY + dy;
                    if (clearEndX >= 0 && clearEndX < cols && clearEndY >= 0 && clearEndY < rows) {
                        grid[clearEndY][clearEndX] = false;
                    }
                }
            }
            
            // BFSè·¯å¾„æŸ¥æ‰¾
            const queue = [[startGridX, startGridY, 0]]; // æ·»åŠ è·ç¦»ä¿¡æ¯
            const visited = Array(rows).fill().map(() => Array(cols).fill(false));
            visited[startGridY][startGridX] = true;
            
            // 4æ–¹å‘ç§»åŠ¨ (ä¸åŒ…æ‹¬å¯¹è§’çº¿ï¼Œæ›´ä¸¥æ ¼)
            const directions = [[0, 1], [1, 0], [0, -1], [-1, 0]];
            
            let maxDistance = 0;
            const maxSearchDistance = cols + rows; // é™åˆ¶æœç´¢è·ç¦»
            
            while (queue.length > 0) {
                const [x, y, distance] = queue.shift();
                maxDistance = Math.max(maxDistance, distance);
                
                // å¦‚æœæœç´¢è·ç¦»è¿‡é•¿ï¼Œå¯èƒ½é™·å…¥æ­»å¾ªç¯
                if (distance > maxSearchDistance) {
                    break;
                }
                
                // æ£€æŸ¥æ˜¯å¦åˆ°è¾¾ç›®æ ‡åŒºåŸŸï¼ˆå…è®¸ä¸€å®šèŒƒå›´ï¼‰
                if (Math.abs(x - endGridX) <= 2 && Math.abs(y - endGridY) <= 2) {
                    console.log(`æ‰¾åˆ°è·¯å¾„ï¼Œæœç´¢è·ç¦»: ${distance}`);
                    return true;
                }
                
                // æ¢ç´¢ç›¸é‚»æ ¼å­
                for (const [dx, dy] of directions) {
                    const nx = x + dx;
                    const ny = y + dy;
                    
                    if (nx >= 0 && nx < cols && ny >= 0 && ny < rows && 
                        !visited[ny][nx] && !grid[ny][nx]) {
                        visited[ny][nx] = true;
                        queue.push([nx, ny, distance + 1]);
                    }
                }
            }
            
            console.log(`æœªæ‰¾åˆ°è·¯å¾„ï¼Œæœ€å¤§æœç´¢è·ç¦»: ${maxDistance}`);
            return false; // æ²¡æœ‰æ‰¾åˆ°è·¯å¾„
        }
        
        // åˆ›å»ºé™æ€é™·é˜±
        function createTraps(useExistingLayout = false) {
            // ç¬¬ä¸€å…³æ²¡æœ‰ä»»ä½•é™·é˜±
            if (gameState.currentLevel === 1) {
                return;
            }
            
            // å¦‚æœè¦é‡ç”¨ç°æœ‰å¸ƒå±€
            if (useExistingLayout && gameState.levelLayouts[gameState.currentLevel]) {
                const layout = gameState.levelLayouts[gameState.currentLevel];
                
                // é‡å»ºé™æ€é™·é˜±
                for (const trapData of layout.staticTraps) {
                    const trap = document.createElement('div');
                    trap.className = trapData.className;
                    
                    if (trapData.trapType) {
                        // é‡å»ºç‰¹æ®Šé™·é˜±
                        trap.dataset.trapType = trapData.trapType;
                        if (trapData.data) {
                            Object.assign(trap.dataset, trapData.data);
                        }
                        trap.style.width = trapData.width + 'px';
                        trap.style.height = trapData.height + 'px';
                        trap.style.left = trapData.left + 'px';
                        trap.style.bottom = trapData.bottom + 'px';
                    } else if (trapData.className === 'trap') {
                        trap.style.width = trapData.width + 'px';
                        trap.style.height = trapData.height + 'px';
                        trap.style.left = trapData.left + 'px';
                        trap.style.bottom = trapData.bottom + 'px';
                    } else {
                        trap.style.left = trapData.left + 'px';
                    }
                    
                    gameContainer.appendChild(trap);
                    gameState.traps.push(trap);
                }
                return;
            }
            
            // ç”Ÿæˆæ–°çš„å¸ƒå±€ - ç¡®ä¿æœ‰å¯é€šè¡Œè·¯å¾„
            const seed = generateLevelSeed(gameState.currentLevel);
            let seedCounter = 0;
            let attempts = 0;
            const maxAttempts = 10;
            
            // æ ¹æ®å…³å¡æ•°é‡é€’å¢éš¾åº¦
            let trapCount;
            if (gameState.currentLevel <= 10) {
                trapCount = gameState.currentLevel * 2; // ç¬¬2å…³å¼€å§‹ï¼Œ2,4,6,8...ä¸ªé™·é˜±
            } else if (gameState.currentLevel <= 30) {
                trapCount = 20 + (gameState.currentLevel - 10) * 3; // ç¬¬11å…³èµ·ï¼Œæ¯å…³å¢åŠ 3ä¸ª
            } else if (gameState.currentLevel <= 60) {
                trapCount = 80 + (gameState.currentLevel - 30) * 2; // ç¬¬31å…³èµ·ï¼Œæ¯å…³å¢åŠ 2ä¸ª
            } else {
                trapCount = 140 + (gameState.currentLevel - 60); // ç¬¬61å…³èµ·ï¼Œæ¯å…³å¢åŠ 1ä¸ª
            }
            
            // åˆå§‹åŒ–å…³å¡å¸ƒå±€å­˜å‚¨
            if (!gameState.levelLayouts[gameState.currentLevel]) {
                gameState.levelLayouts[gameState.currentLevel] = {
                    staticTraps: [],
                    movingTraps: []
                };
            }
            
            // ç©å®¶èµ·å§‹ä½ç½®å’Œé—¨çš„ä½ç½®
            const playerStartX = 50;
            const playerStartY = gameHeight - 100;
            const doorX = gameWidth - 80;
            const doorY = gameHeight - 100;
            
            let validLayout = false;
            
            while (!validLayout && attempts < maxAttempts) {
                attempts++;
                seedCounter = attempts * 1000; // æ¯æ¬¡å°è¯•ä½¿ç”¨ä¸åŒçš„ç§å­åç§»
                
                // ä¸´æ—¶é™·é˜±æ•°ç»„ç”¨äºè·¯å¾„éªŒè¯
                const tempTraps = [];
                
                // æ ¹æ®å°è¯•æ¬¡æ•°åŠ¨æ€è°ƒæ•´é™·é˜±æ•°é‡
                const adjustedTrapCount = Math.max(1, trapCount - Math.floor(attempts * trapCount / maxAttempts));
                
                // ç”Ÿæˆé™·é˜±
                for (let i = 0; i < adjustedTrapCount; i++) {
                    // æ ¹æ®å…³å¡é˜¶æ®µè°ƒæ•´é™·é˜±æ¯”ä¾‹
                    let specialChance, spikeChance, trapChance;
                    
                    if (gameState.currentLevel <= 10) {
                        specialChance = Math.min(0.1 + gameState.currentLevel * 0.02, 0.3);
                        spikeChance = 0.5;
                        trapChance = 0.3;
                    } else if (gameState.currentLevel <= 30) {
                        specialChance = 0.4;
                        spikeChance = 0.4;
                        trapChance = 0.2;
                    } else if (gameState.currentLevel <= 60) {
                        specialChance = 0.6;
                        spikeChance = 0.3;
                        trapChance = 0.1;
                    } else {
                        specialChance = 0.7;
                        spikeChance = 0.25;
                        trapChance = 0.05;
                    }
                    
                    const randomValue = seededRandom(seed + seedCounter++);
                    const sizeMultiplier = 1 + gameState.currentLevel * 0.005;
                    
                    let trapData = {};
                    let trapPlaced = false;
                    let placementAttempts = 0;
                    
                    while (!trapPlaced && placementAttempts < 50) {
                        placementAttempts++;
                        
                        if (randomValue < specialChance && gameState.currentLevel >= 3) {
                            // ç‰¹æ®Šé™·é˜±
                            const width = 40 * sizeMultiplier;
                            const height = 40 * sizeMultiplier;
                            const left = 120 + seededRandom(seed + seedCounter++) * (gameWidth - 240 - width);
                            const top = 60 + seededRandom(seed + seedCounter++) * (gameHeight - height - 120);
                            
                            // æ›´ä¸¥æ ¼çš„å®‰å…¨åŒºåŸŸæ£€æŸ¥
                            const safeRadius = 120; // å¢å¤§å®‰å…¨åŠå¾„
                            const distToStart = Math.sqrt(Math.pow(left + width/2 - playerStartX, 2) + Math.pow(top + height/2 - playerStartY, 2));
                            const distToEnd = Math.sqrt(Math.pow(left + width/2 - doorX, 2) + Math.pow(top + height/2 - doorY, 2));
                            
                            // æ£€æŸ¥ä¸­é—´é€šé“åŒºåŸŸ
                            const midChannelY = gameHeight - 150;
                            const inMidChannel = (top < midChannelY + 50 && top + height > midChannelY - 50);
                            
                            if (distToStart > safeRadius && distToEnd > safeRadius && !inMidChannel) {
                                trapData = {
                                    left: left,
                                    top: top,
                                    width: width,
                                    height: height,
                                    className: 'special-trap'
                                };
                                trapPlaced = true;
                            }
                        } else if (randomValue < specialChance + spikeChance) {
                            // å°–åˆºé™·é˜±
                            const left = 120 + seededRandom(seed + seedCounter++) * (gameWidth - 240 - 30);
                            
                            // æ›´ä¸¥æ ¼çš„æ°´å¹³å®‰å…¨è·ç¦»
                            const safeDistance = 100;
                            if (Math.abs(left + 15 - playerStartX) > safeDistance && 
                                Math.abs(left + 15 - doorX) > safeDistance) {
                                trapData = {
                                    left: left,
                                    top: 0,
                                    width: 30,
                                    height: 20,
                                    className: 'spike'
                                };
                                trapPlaced = true;
                            }
                        } else if (randomValue < specialChance + spikeChance + trapChance) {
                            // çŸ©å½¢é™·é˜±
                            const width = Math.min((30 + seededRandom(seed + seedCounter++) * 70) * sizeMultiplier, 120);
                            const height = Math.min((20 + seededRandom(seed + seedCounter++) * 50) * sizeMultiplier, 80);
                            const left = 120 + seededRandom(seed + seedCounter++) * (gameWidth - 240 - width);
                            const top = 60 + seededRandom(seed + seedCounter++) * (gameHeight - height - 120);
                            
                            // æ›´ä¸¥æ ¼çš„å®‰å…¨åŒºåŸŸæ£€æŸ¥
                            const safeRadius = 120;
                            const distToStart = Math.sqrt(Math.pow(left + width/2 - playerStartX, 2) + Math.pow(top + height/2 - playerStartY, 2));
                            const distToEnd = Math.sqrt(Math.pow(left + width/2 - doorX, 2) + Math.pow(top + height/2 - doorY, 2));
                            
                            // æ£€æŸ¥ä¸­é—´é€šé“åŒºåŸŸ
                            const midChannelY = gameHeight - 150;
                            const inMidChannel = (top < midChannelY + 50 && top + height > midChannelY - 50);
                            
                            if (distToStart > safeRadius && distToEnd > safeRadius && !inMidChannel) {
                                trapData = {
                                    left: left,
                                    top: top,
                                    width: width,
                                    height: height,
                                    className: 'trap'
                                };
                                trapPlaced = true;
                            }
                        } else {
                            // é»˜è®¤å°–åˆºé™·é˜±
                            const left = 120 + seededRandom(seed + seedCounter++) * (gameWidth - 240 - 30);
                            
                            // æ›´ä¸¥æ ¼çš„æ°´å¹³å®‰å…¨è·ç¦»
                            const safeDistance = 100;
                            if (Math.abs(left + 15 - playerStartX) > safeDistance && 
                                Math.abs(left + 15 - doorX) > safeDistance) {
                                trapData = {
                                    left: left,
                                    top: 0,
                                    width: 30,
                                    height: 20,
                                    className: 'spike'
                                };
                                trapPlaced = true;
                            }
                        }
                    }
                    
                    if (trapPlaced) {
                        tempTraps.push(trapData);
                    }
                }
                
                // æ£€æŸ¥æ˜¯å¦æœ‰æœ‰æ•ˆè·¯å¾„
                if (hasValidPath(tempTraps, playerStartX, playerStartY, doorX, doorY)) {
                    validLayout = true;
                    
                    // åˆ›å»ºå®é™…çš„é™·é˜±å…ƒç´ 
                    tempTraps.forEach((trapData, index) => {
                        const trap = document.createElement('div');
                        
                        if (trapData.className === 'special-trap' && gameState.currentLevel >= 3) {
                            seedCounter = createSpecialTrap(trap, seed, seedCounter + index * 10, 1 + gameState.currentLevel * 0.005);
                        } else {
                            trap.className = trapData.className;
                            trap.style.width = trapData.width + 'px';
                            trap.style.height = trapData.height + 'px';
                            trap.style.left = trapData.left + 'px';
                            
                            if (trapData.className === 'spike') {
                                // å°–åˆºé™·é˜±å›ºå®šåœ¨åº•éƒ¨
                                trap.style.bottom = '0px';
                            } else {
                                // è½¬æ¢ä¸ºbottomåæ ‡ç³»ç»Ÿ
                                trap.style.bottom = (gameHeight - trapData.top - trapData.height) + 'px';
                            }
                            
                            // ä¿å­˜å¸ƒå±€ä¿¡æ¯
                            gameState.levelLayouts[gameState.currentLevel].staticTraps.push({
                                className: trapData.className,
                                width: trapData.width,
                                height: trapData.height,
                                left: trapData.left,
                                bottom: trapData.className === 'spike' ? 0 : (gameHeight - trapData.top - trapData.height)
                            });
                        }
                        
                        gameContainer.appendChild(trap);
                        gameState.traps.push(trap);
                    });
                }
            }
            
            // å¦‚æœå¤šæ¬¡å°è¯•åä»æ— æ³•ç”Ÿæˆæœ‰æ•ˆå¸ƒå±€ï¼Œåˆ™ç”Ÿæˆä¸€ä¸ªç®€åŒ–çš„å¸ƒå±€
            if (!validLayout) {
                console.log(`å…³å¡ ${gameState.currentLevel}: æ— æ³•ç”Ÿæˆæœ‰æ•ˆè·¯å¾„ï¼Œä½¿ç”¨ç®€åŒ–å¸ƒå±€`);
                
                // ç”Ÿæˆä¿è¯å¯é€šè¡Œçš„ç®€åŒ–å¸ƒå±€
                const simpleTrapCount = Math.min(3, Math.max(1, Math.floor(gameState.currentLevel / 10)));
                const safePositions = [];
                
                // è®¡ç®—å®‰å…¨ä½ç½®ï¼Œç¡®ä¿ç•™å‡ºé€šé“
                const channelWidth = 150; // é€šé“å®½åº¦
                const channelCenterX = gameWidth / 2;
                
                for (let i = 0; i < simpleTrapCount; i++) {
                    let trapX;
                    if (i % 2 === 0) {
                        // å·¦ä¾§é™·é˜±
                        trapX = 150 + (i / 2) * 100;
                        if (trapX > channelCenterX - channelWidth / 2 - 50) {
                            trapX = channelCenterX - channelWidth / 2 - 50;
                        }
                    } else {
                        // å³ä¾§é™·é˜±
                        trapX = channelCenterX + channelWidth / 2 + 50 + Math.floor(i / 2) * 100;
                        if (trapX > gameWidth - 200) {
                            trapX = gameWidth - 200;
                        }
                    }
                    
                    // ç¡®ä¿ä¸ä¸èµ·å§‹ç‚¹å’Œç»ˆç‚¹å†²çª
                    if (Math.abs(trapX - playerStartX) > 80 && Math.abs(trapX - doorX) > 80) {
                        safePositions.push(trapX);
                    }
                }
                
                // åˆ›å»ºç®€åŒ–é™·é˜±
                for (let i = 0; i < Math.min(safePositions.length, simpleTrapCount); i++) {
                    const trap = document.createElement('div');
                    trap.className = 'spike';
                    trap.style.left = safePositions[i] + 'px';
                    trap.style.bottom = '0px';
                    trap.style.width = '30px';
                    trap.style.height = '20px';
                    
                    gameState.levelLayouts[gameState.currentLevel].staticTraps.push({
                        className: 'spike',
                        left: safePositions[i],
                        width: 30,
                        height: 20
                    });
                    
                    gameContainer.appendChild(trap);
                    gameState.traps.push(trap);
                }
                
                // éªŒè¯ç®€åŒ–å¸ƒå±€æ˜¯å¦å¯é€šè¡Œ
                const simplifiedTraps = safePositions.map(x => ({
                    left: x,
                    top: 0,
                    width: 30,
                    height: 20,
                    className: 'spike'
                }));
                
                if (hasValidPath(simplifiedTraps, playerStartX, playerStartY, doorX, doorY)) {
                    console.log(`å…³å¡ ${gameState.currentLevel}: ç®€åŒ–å¸ƒå±€éªŒè¯é€šè¿‡`);
                } else {
                    console.log(`å…³å¡ ${gameState.currentLevel}: ç®€åŒ–å¸ƒå±€éªŒè¯å¤±è´¥ï¼Œä½¿ç”¨æœ€å°å¸ƒå±€`);
                    // æ¸…é™¤æ‰€æœ‰é™·é˜±ï¼Œåªä¿ç•™ä¸€ä¸ªè¿œç¦»é€šé“çš„é™·é˜±
                    gameState.traps.forEach(trap => trap.remove());
                    gameState.traps = [];
                    gameState.levelLayouts[gameState.currentLevel].staticTraps = [];
                    
                    if (gameState.currentLevel > 1) {
                        const trap = document.createElement('div');
                        trap.className = 'spike';
                        trap.style.left = (gameWidth * 0.3) + 'px';
                        trap.style.bottom = '0px';
                        trap.style.width = '30px';
                        trap.style.height = '20px';
                        
                        gameState.levelLayouts[gameState.currentLevel].staticTraps.push({
                            className: 'spike',
                            left: gameWidth * 0.3,
                            width: 30,
                            height: 20
                        });
                        
                        gameContainer.appendChild(trap);
                        gameState.traps.push(trap);
                    }
                }
            } else {
                console.log(`å…³å¡ ${gameState.currentLevel}: æˆåŠŸç”Ÿæˆæœ‰æ•ˆè·¯å¾„å¸ƒå±€ (å°è¯•æ¬¡æ•°: ${attempts})`);
            }
        }

        // è®¾ç½®ç§»åŠ¨é™·é˜±
        function setupMovingTraps(useExistingLayout = false) {
            // ç¬¬1-3å…³æ²¡æœ‰ç§»åŠ¨é™·é˜±
            if (gameState.currentLevel <= 3) {
                return;
            }
            
            // å¦‚æœè¦é‡ç”¨ç°æœ‰å¸ƒå±€
            if (useExistingLayout && gameState.levelLayouts[gameState.currentLevel]) {
                const layout = gameState.levelLayouts[gameState.currentLevel];
                
                // é‡å»ºç§»åŠ¨é™·é˜±
                for (const trapData of layout.movingTraps) {
                    const movingTrap = document.createElement('div');
                    movingTrap.className = 'moving-trap';
                    
                    movingTrap.style.left = trapData.startX + 'px';
                    movingTrap.style.top = trapData.startY + 'px';
                    
                    gameContainer.appendChild(movingTrap);
                    gameState.movingTraps.push({
                        element: movingTrap,
                        x: trapData.startX,
                        y: trapData.startY,
                        speedX: trapData.speedX,
                        speedY: trapData.speedY
                    });
                }
                
                // å¼€å§‹ç§»åŠ¨é™·é˜±
                if (trapInterval) clearInterval(trapInterval);
                const updateInterval = Math.max(15, 35 - gameState.currentLevel * 0.2);
                trapInterval = setInterval(moveTraps, updateInterval);
                return;
            }
            
            // ç”Ÿæˆæ–°çš„ç§»åŠ¨é™·é˜±å¸ƒå±€
            const seed = generateLevelSeed(gameState.currentLevel);
            let seedCounter = 1000; // ä½¿ç”¨ä¸åŒçš„èµ·å§‹å€¼é¿å…ä¸é™æ€é™·é˜±å†²çª
            
            // æ ¹æ®å…³å¡é€’å¢ç§»åŠ¨é™·é˜±æ•°é‡
            let movingTrapCount;
            if (gameState.currentLevel <= 15) {
                movingTrapCount = Math.floor((gameState.currentLevel - 3) / 3); // ç¬¬4å…³å¼€å§‹ï¼Œæ¯3å…³å¢åŠ 1ä¸ª
            } else if (gameState.currentLevel <= 50) {
                movingTrapCount = 4 + Math.floor((gameState.currentLevel - 15) / 5); // ç¬¬16å…³èµ·ï¼Œæ¯5å…³å¢åŠ 1ä¸ª
            } else {
                movingTrapCount = Math.min(11 + Math.floor((gameState.currentLevel - 50) / 10), 20); // ç¬¬51å…³èµ·ï¼Œæ¯10å…³å¢åŠ 1ä¸ªï¼Œæœ€å¤š20ä¸ª
            }
            
            for (let i = 0; i < movingTrapCount; i++) {
                const movingTrap = document.createElement('div');
                movingTrap.className = 'moving-trap';
                
                // ä½¿ç”¨ç§å­ç”Ÿæˆå›ºå®šçš„åˆå§‹ä½ç½®å’Œç§»åŠ¨æ–¹å‘ï¼Œé¿å¼€èµ·å§‹ç‚¹å’Œé—¨å£
                let startX, startY;
                let attempts = 0;
                do {
                    startX = 100 + seededRandom(seed + seedCounter++) * (gameWidth - 200);
                    startY = 50 + seededRandom(seed + seedCounter++) * (gameHeight - 100);
                    attempts++;
                } while (attempts < 20 && (
                    (startX < 150 && startY > gameHeight - 150) || // é¿å¼€èµ·å§‹åŒºåŸŸ
                    (startX > gameWidth - 150 && startY > gameHeight - 150) // é¿å¼€é—¨å£åŒºåŸŸ
                ));
                
                // æ ¹æ®å…³å¡è°ƒæ•´ç§»åŠ¨é€Ÿåº¦
                const baseSpeed = 2 + gameState.currentLevel * 0.05; // é€Ÿåº¦éšå…³å¡å¢åŠ 
                const maxSpeed = Math.min(baseSpeed, 8); // é™åˆ¶æœ€å¤§é€Ÿåº¦
                const speedX = (seededRandom(seed + seedCounter++) - 0.5) * maxSpeed;
                const speedY = (seededRandom(seed + seedCounter++) - 0.5) * maxSpeed;
                
                movingTrap.style.left = startX + 'px';
                movingTrap.style.top = startY + 'px';
                
                gameContainer.appendChild(movingTrap);
                gameState.movingTraps.push({
                    element: movingTrap,
                    x: startX,
                    y: startY,
                    speedX: speedX,
                    speedY: speedY
                });
                
                // ä¿å­˜ç§»åŠ¨é™·é˜±å¸ƒå±€ä¿¡æ¯
                gameState.levelLayouts[gameState.currentLevel].movingTraps.push({
                    startX: startX,
                    startY: startY,
                    speedX: speedX,
                    speedY: speedY
                });
            }
            
            // å¼€å§‹ç§»åŠ¨é™·é˜±ï¼Œé«˜å…³å¡æ›´æ–°é¢‘ç‡æ›´é«˜
            if (trapInterval) clearInterval(trapInterval);
            const updateInterval = Math.max(15, 35 - gameState.currentLevel * 0.2); // æ›´æ–°é—´éš”éšå…³å¡å‡å°‘
            trapInterval = setInterval(moveTraps, updateInterval);
        }

        // ç§»åŠ¨é™·é˜±
        function moveTraps() {
            gameState.movingTraps.forEach(trap => {
                trap.x += trap.speedX;
                trap.y += trap.speedY;
                
                // è¾¹ç•Œæ£€æµ‹
                if (trap.x <= 0 || trap.x >= gameWidth - 40) {
                    trap.speedX *= -1;
                }
                if (trap.y <= 0 || trap.y >= gameHeight - 40) {
                    trap.speedY *= -1;
                }
                
                trap.element.style.left = trap.x + 'px';
                trap.element.style.top = trap.y + 'px';
            });
        }

        // æ›´æ–°ç©å®¶ä½ç½®
        function updatePlayerPosition() {
            player.style.left = gameState.player.x + 'px';
            player.style.top = gameState.player.y + 'px';
        }

        // å¤„ç†ç‰¹æ®Šé™·é˜±
        function handleSpecialTrap(trap) {
            const trapType = trap.dataset.trapType;
            
            switch(trapType) {
                case 'teleport':
                    // ä¼ é€é™·é˜±ï¼šéšæœºä¼ é€ç©å®¶
                    playClickSound(); // ä¼ é€éŸ³æ•ˆ
                    gameState.player.x = 50 + Math.random() * (gameWidth - 150);
                    gameState.player.y = 50 + Math.random() * (gameHeight - 100);
                    updatePlayerPosition();
                    messageDisplay.textContent = 'ğŸ’« ä¼ é€äº†ï¼';
                    setTimeout(() => {
                        if (messageDisplay.textContent.includes('ä¼ é€äº†')) {
                            messageDisplay.textContent = '';
                        }
                    }, 1500);
                    break;
                    
                case 'freeze':
                    // å†°å†»é™·é˜±ï¼šå†»ç»“ç©å®¶3ç§’
                    gameState.playerFrozen = true;
                    gameState.freezeEndTime = Date.now() + 3000;
                    player.style.filter = 'hue-rotate(240deg) brightness(0.7)';
                    messageDisplay.textContent = 'ğŸ§Š è¢«å†°å†»äº†ï¼';
                    setTimeout(() => {
                        gameState.playerFrozen = false;
                        player.style.filter = '';
                        if (messageDisplay.textContent.includes('è¢«å†°å†»äº†')) {
                            messageDisplay.textContent = '';
                        }
                    }, 3000);
                    break;
                    
                case 'split':
                    // åˆ†è£‚é™·é˜±ï¼šåˆ†è£‚æˆ4ä¸ªå°é™·é˜±
                    if (trap.dataset.hasTriggered === 'false') {
                        trap.dataset.hasTriggered = 'true';
                        createSplitTraps(trap);
                        trap.remove();
                        gameState.traps = gameState.traps.filter(t => t !== trap);
                    }
                    break;
                    
                case 'gravity':
                    // é‡åŠ›é™·é˜±ï¼šæŠŠç©å®¶æ‹‰å‘ä¸­å¿ƒç„¶åçˆ†ç‚¸
                    const trapRect = trap.getBoundingClientRect();
                    const centerX = trapRect.left + trapRect.width / 2 - gameContainer.getBoundingClientRect().left;
                    const centerY = trapRect.top + trapRect.height / 2 - gameContainer.getBoundingClientRect().top;
                    gameState.player.x = centerX - 20;
                    gameState.player.y = centerY - 25;
                    updatePlayerPosition();
                    setTimeout(() => gameOver(), 500);
                    break;
                    
                case 'bounce':
                    // å¼¹è·³é™·é˜±ï¼šæŠŠç©å®¶å¼¹åˆ°éšæœºæ–¹å‘
                    playClickSound();
                    const bounceForce = 100;
                    const angle = Math.random() * 2 * Math.PI;
                    gameState.player.x += Math.cos(angle) * bounceForce;
                    gameState.player.y += Math.sin(angle) * bounceForce;
                    
                    // ç¡®ä¿ç©å®¶ä¸ä¼šè¢«å¼¹å‡ºè¾¹ç•Œ
                    gameState.player.x = Math.max(0, Math.min(gameWidth - 40, gameState.player.x));
                    gameState.player.y = Math.max(0, Math.min(gameHeight - 50, gameState.player.y));
                    updatePlayerPosition();
                    
                    messageDisplay.textContent = 'ğŸ€ è¢«å¼¹é£äº†ï¼';
                    setTimeout(() => {
                        if (messageDisplay.textContent.includes('è¢«å¼¹é£äº†')) {
                            messageDisplay.textContent = '';
                        }
                    }, 1500);
                    break;
                    
                case 'shrink':
                    // ç¼©å°é™·é˜±ï¼šè®©ç©å®¶å˜å°5ç§’
                    player.style.transform = 'scale(0.5)';
                    messageDisplay.textContent = 'ğŸ” å˜å°äº†ï¼';
                    setTimeout(() => {
                        player.style.transform = '';
                        if (messageDisplay.textContent.includes('å˜å°äº†')) {
                            messageDisplay.textContent = '';
                        }
                    }, 5000);
                    break;
                    
                case 'speed':
                    // åŠ é€Ÿé™·é˜±ï¼šè®©ç©å®¶ç§»åŠ¨é€Ÿåº¦ç¿»å€5ç§’
                    const originalSpeed = playerSpeed;
                    playerSpeed *= 2;
                    player.style.filter = 'hue-rotate(120deg) brightness(1.2)';
                    messageDisplay.textContent = 'âš¡ åŠ é€Ÿäº†ï¼';
                    setTimeout(() => {
                        playerSpeed = originalSpeed;
                        player.style.filter = '';
                        if (messageDisplay.textContent.includes('åŠ é€Ÿäº†')) {
                            messageDisplay.textContent = '';
                        }
                    }, 5000);
                    break;
                    
                case 'clone':
                    // å…‹éš†é™·é˜±ï¼šåˆ›å»ºç©å®¶çš„é•œåƒ
                    if (trap.dataset.hasTriggered === 'false') {
                        trap.dataset.hasTriggered = 'true';
                        createPlayerClone();
                        messageDisplay.textContent = 'ğŸ‘¥ å‡ºç°äº†åˆ†èº«ï¼';
                        setTimeout(() => {
                            if (messageDisplay.textContent.includes('å‡ºç°äº†åˆ†èº«')) {
                                messageDisplay.textContent = '';
                            }
                        }, 2000);
                    }
                    break;
                    
                default:
                    // å…¶ä»–ç‰¹æ®Šé™·é˜±ä¹Ÿä¼šå¯¼è‡´æ¸¸æˆç»“æŸ
                    gameOver();
                    break;
            }
        }

        // åˆ›å»ºåˆ†è£‚çš„å°é™·é˜±
        function createSplitTraps(originalTrap) {
            const rect = originalTrap.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2 - gameContainer.getBoundingClientRect().left;
            const centerY = rect.top + rect.height / 2 - gameContainer.getBoundingClientRect().top;
            
            const directions = [
                {x: -1, y: -1}, {x: 1, y: -1}, 
                {x: -1, y: 1}, {x: 1, y: 1}
            ];
            
            directions.forEach((dir, index) => {
                setTimeout(() => {
                    const smallTrap = document.createElement('div');
                    smallTrap.className = 'trap';
                    smallTrap.style.width = '20px';
                    smallTrap.style.height = '20px';
                    smallTrap.style.left = (centerX + dir.x * 30) + 'px';
                    smallTrap.style.top = (centerY + dir.y * 30) + 'px';
                    smallTrap.style.position = 'absolute';
                    
                    gameContainer.appendChild(smallTrap);
                    gameState.traps.push(smallTrap);
                }, index * 100);
            });
        }

        // åˆ›å»ºç©å®¶å…‹éš†
        function createPlayerClone() {
            const clone = document.createElement('div');
            clone.className = 'player-clone';
            clone.innerHTML = 'ğŸ§™â€â™‚ï¸';
            clone.style.position = 'absolute';
            clone.style.width = '40px';
            clone.style.height = '50px';
            clone.style.fontSize = '40px';
            clone.style.display = 'flex';
            clone.style.alignItems = 'center';
            clone.style.justifyContent = 'center';
            clone.style.zIndex = '3';
            clone.style.opacity = '0.7';
            clone.style.filter = 'hue-rotate(180deg)';
            
            // å…‹éš†å‡ºç°åœ¨ç©å®¶é™„è¿‘çš„éšæœºä½ç½®
            const offsetX = (Math.random() - 0.5) * 200;
            const offsetY = (Math.random() - 0.5) * 200;
            clone.style.left = Math.max(0, Math.min(gameWidth - 40, gameState.player.x + offsetX)) + 'px';
            clone.style.top = Math.max(0, Math.min(gameHeight - 50, gameState.player.y + offsetY)) + 'px';
            
            gameContainer.appendChild(clone);
            
            // å…‹éš†ä¼šè·Ÿéšç©å®¶ç§»åŠ¨ï¼Œä½†æœ‰å»¶è¿Ÿ
            let cloneX = parseFloat(clone.style.left);
            let cloneY = parseFloat(clone.style.top);
            
            const cloneInterval = setInterval(() => {
                if (gameState.gameOver) {
                    clearInterval(cloneInterval);
                    clone.remove();
                    return;
                }
                
                // å…‹éš†ç¼“æ…¢è·Ÿéšç©å®¶
                const dx = gameState.player.x - cloneX;
                const dy = gameState.player.y - cloneY;
                cloneX += dx * 0.1;
                cloneY += dy * 0.1;
                
                clone.style.left = cloneX + 'px';
                clone.style.top = cloneY + 'px';
            }, 50);
            
            // 10ç§’åç§»é™¤å…‹éš†
            setTimeout(() => {
                clearInterval(cloneInterval);
                if (clone.parentNode) {
                    clone.remove();
                }
            }, 10000);
        }

        // æ£€æµ‹ç¢°æ’
        function checkCollisions() {
            const playerRect = player.getBoundingClientRect();
            const doorRect = door.getBoundingClientRect();
            const sm = gameState.specialMechanics;
            
            // æ£€æŸ¥ç‰¹æ®Šå…ƒç´ äº¤äº’
            checkSpecialElementInteractions(playerRect);
            
            // æ›´æ–°è®¡æ—¶å™¨
            updateTimer();
            
            // æ£€æŸ¥æ˜¯å¦æ»¡è¶³é€šå…³æ¡ä»¶
            if (!canPassLevel()) {
                return;
            }
            
            // æ£€æŸ¥æ˜¯å¦å®Œå…¨è¿›å…¥é—¨å†…ï¼ˆç©å®¶éœ€è¦å®Œå…¨åœ¨é—¨çš„èŒƒå›´å†…ï¼‰
            if (playerRect.left >= doorRect.left + 5 && 
                playerRect.right <= doorRect.right - 5 && 
                playerRect.bottom >= doorRect.top + 5 && 
                playerRect.top <= doorRect.bottom - 5) {
                levelComplete();
                return;
            }
            
            // æ£€æŸ¥ä¸é™æ€é™·é˜±çš„ç¢°æ’
            for (const trap of gameState.traps) {
                const trapRect = trap.getBoundingClientRect();
                if (playerRect.right > trapRect.left && 
                    playerRect.left < trapRect.right && 
                    playerRect.bottom > trapRect.top && 
                    playerRect.top < trapRect.bottom) {
                    
                    // å¤„ç†ç‰¹æ®Šé™·é˜±
                    if (trap.dataset.trapType) {
                        // é—ªçƒé™·é˜±åœ¨ä¸å¯è§æ—¶ä¸ä¼šé€ æˆä¼¤å®³
                        if (trap.dataset.trapType === 'blink' && trap.dataset.visible === 'false') {
                            continue;
                        }
                        handleSpecialTrap(trap);
                    } else {
                        gameOver();
                    }
                    return;
                }
            }
            
            // æ£€æŸ¥ä¸ç§»åŠ¨é™·é˜±çš„ç¢°æ’
            for (const trap of gameState.movingTraps) {
                const trapRect = trap.element.getBoundingClientRect();
                if (playerRect.right > trapRect.left && 
                    playerRect.left < trapRect.right && 
                    playerRect.bottom > trapRect.top && 
                    playerRect.top < trapRect.bottom) {
                    gameOver();
                    return;
                }
            }
            
            // æ£€æŸ¥è¾¹ç•Œ
            if (gameState.player.x < 0 || gameState.player.x > gameWidth - 40 ||
                gameState.player.y < 0 || gameState.player.y > gameHeight - 50) {
                gameOver();
                return;
            }
        }

        // å…³å¡å®Œæˆ
        function levelComplete() {
            // é˜²æ­¢é‡å¤è°ƒç”¨
            if (gameState.gameOver) return;
            gameState.gameOver = true;
            
            // æ’­æ”¾è¿‡å…³éŸ³æ•ˆ
            playSuccessSound();
            
            // æ·»åŠ è¿‡å…³ç‰¹æ•ˆ
            const sparkle = document.createElement('div');
            sparkle.className = 'level-complete';
            sparkle.style.left = (gameState.player.x - 30) + 'px';
            sparkle.style.top = (gameState.player.y - 25) + 'px';
            gameContainer.appendChild(sparkle);
            
            // ç§»é™¤ç‰¹æ•ˆ
            setTimeout(() => {
                sparkle.remove();
            }, 1000);
            
            // è§£é”ä¸‹ä¸€å…³
            if (gameState.currentLevel === gameState.maxUnlockedLevel && gameState.currentLevel < gameState.maxLevel) {
                gameState.maxUnlockedLevel = gameState.currentLevel + 1;
                saveProgress();
            }
            
            if (gameState.currentLevel === gameState.maxLevel) {
                messageDisplay.textContent = 'ğŸŒŸ é‡ç”Ÿå®Œæˆï¼ä½ å·²æ‰“ç ´å¾ªç¯ï¼Œè·å¾—äº†çœŸæ­£çš„è‡ªç”±ï¼æ³•å¸ˆé‡è·æ–°ç”Ÿï¼';
                setTimeout(() => {
                    messageDisplay.textContent = 'å¾ªç¯å·²ç ´ï¼Œä½†å†’é™©æ°¸ä¸æ­¢æ­¥...é€‰æ‹©ä»»æ„å…³å¡é‡æ¸©é‡ç”Ÿä¹‹è·¯';
                    updateProgressDisplay();
                }, 3000);
            } else {
                const stageMessages = [
                    'âœ¨ è§‰é†’ä¹‹å…‰æ›´åŠ æ˜äº®...',
                    'ğŸ”® è®°å¿†ç¢ç‰‡é€æ¸æ‹¼åˆ...',
                    'ğŸ‘» å¹»è±¡å¼€å§‹æ¶ˆæ•£...',
                    'ğŸ§Š å¯’å†°æ— æ³•é˜»æŒ¡å‰è¿›...',
                    'ğŸ’¥ åœ¨å´©åä¸­å¯»æ‰¾ç§©åº...',
                    'ğŸª çœŸç›¸åœ¨é•œåƒä¸­æ˜¾ç°...',
                    'âš¡ æ—¶ç©ºä¹±æµè¢«ä½ å¾æœ...',
                    'ğŸŒ€ å¾ªç¯çš„æ·é”æ­£åœ¨æ¾åŠ¨...',
                    'ğŸ”¥ é‡ç”Ÿçš„ç«ç„°æ„ˆå‘ç‚½çƒ­...'
                ];
                
                let stageIndex = Math.floor((gameState.currentLevel - 1) / 10);
                if (stageIndex >= stageMessages.length) stageIndex = stageMessages.length - 1;
                
                messageDisplay.textContent = stageMessages[stageIndex];
                // 2ç§’åè‡ªåŠ¨è¿›å…¥ä¸‹ä¸€å…³
                setTimeout(() => {
                    nextLevel();
                }, 2000);
            }
        }

        // æ¸¸æˆç»“æŸ
        function gameOver() {
            // é˜²æ­¢é‡å¤è°ƒç”¨
            if (gameState.gameOver) return;
            gameState.gameOver = true;
            
            // æ’­æ”¾çˆ†ç‚¸éŸ³æ•ˆ
            playExplosionSound();
            
            // æ·»åŠ çˆ†ç‚¸ç‰¹æ•ˆ
            const explosion = document.createElement('div');
            explosion.className = 'explosion';
            explosion.style.left = (gameState.player.x - 30) + 'px';
            explosion.style.top = (gameState.player.y - 25) + 'px';
            gameContainer.appendChild(explosion);
            
            // éšè—ç©å®¶
            player.style.display = 'none';
            
            const deathMessages = [
                'ğŸ’« å¾ªç¯é‡å¯...æ³•å¸ˆå†æ¬¡è§‰é†’',
                'ğŸ”„ æ—¶é—´å€’æµ...é‡æ–°æ¥è¿‡',
                'âš¡ é‡ç”Ÿä¹‹åŠ›æ¿€æ´»...å†æ¬¡æŒ‘æˆ˜',
                'ğŸŒ€ å¾ªç¯ç»§ç»­...æ°¸ä¸æ”¾å¼ƒ',
                'ğŸ”¥ ä»ç°çƒ¬ä¸­é‡ç”Ÿ...å†æ¥ä¸€æ¬¡'
            ];
            const randomMessage = deathMessages[Math.floor(Math.random() * deathMessages.length)];
            messageDisplay.textContent = randomMessage;
            
            // ç§»é™¤çˆ†ç‚¸ç‰¹æ•ˆå¹¶é‡æ–°å¼€å§‹å½“å‰å…³å¡
            setTimeout(() => {
                explosion.remove();
                player.style.display = 'flex';
                restartCurrentLevel();
            }, 1500);
        }
        
        // é‡æ–°å¼€å§‹å½“å‰å…³å¡
        function restartCurrentLevel() {
            gameState.player = { x: 50, y: 250 };
            gameState.traps = [];
            gameState.movingTraps = [];
            gameState.specialTraps = [];
            gameState.gameOver = false;
            gameState.playerFrozen = false;
            gameState.freezeEndTime = 0;
            
            messageDisplay.textContent = '';
            
            // æ¸…é™¤ç©å®¶çš„ç‰¹æ®ŠçŠ¶æ€
            player.style.filter = '';
            player.style.transform = '';
            
            // æ¸…é™¤ä¹‹å‰çš„é™·é˜±ï¼ˆåŒ…æ‹¬ç‰¹æ®Šé™·é˜±å’Œç‰¹æ®Šå…ƒç´ ï¼‰
            document.querySelectorAll('.trap, .spike, .moving-trap, .invisible-trap, .teleport-trap, .hunter-trap, .blink-trap, .gravity-trap, .split-trap, .mirror-trap, .freeze-trap, .bounce-trap, .shrink-trap, .speed-trap, .clone-trap, .player-clone, .collectible, .key-item, .teleporter, .switch, .moving-platform, .timer-display').forEach(el => el.remove());
            
            updatePlayerPosition();
            
            // é‡ç”¨ç°æœ‰çš„å…³å¡å¸ƒå±€
            levelDisplay.textContent = gameState.currentLevel;
            playerSpeed = basePlayerSpeed + Math.floor(gameState.currentLevel / 20);
            
            // é‡æ–°è®¾ç½®ç‰¹æ®Šæœºåˆ¶
            resetSpecialMechanics();
            setupSpecialMechanics();
            
            createTraps(true); // ä½¿ç”¨ç°æœ‰å¸ƒå±€
            setupMovingTraps(true); // ä½¿ç”¨ç°æœ‰å¸ƒå±€
        }

        // ä¸‹ä¸€å…³
        function nextLevel() {
            gameState.currentLevel++;
            saveProgress(); // ä¿å­˜å½“å‰å…³å¡è¿›åº¦
            gameState.player = { x: 50, y: 250 };
            gameState.traps = [];
            gameState.movingTraps = [];
            gameState.specialTraps = [];
            gameState.gameOver = false;  // é‡ç½®æ¸¸æˆçŠ¶æ€
            gameState.playerFrozen = false;
            gameState.freezeEndTime = 0;
            
            messageDisplay.textContent = '';
            nextBtn.classList.add('hidden');
            
            // æ¸…é™¤ç©å®¶çš„ç‰¹æ®ŠçŠ¶æ€
            player.style.filter = '';
            player.style.transform = '';
            
            // æ¸…é™¤ä¹‹å‰çš„é™·é˜±ï¼ˆåŒ…æ‹¬ç‰¹æ®Šé™·é˜±å’Œç‰¹æ®Šå…ƒç´ ï¼‰
            document.querySelectorAll('.trap, .spike, .moving-trap, .invisible-trap, .teleport-trap, .hunter-trap, .blink-trap, .gravity-trap, .split-trap, .mirror-trap, .freeze-trap, .bounce-trap, .shrink-trap, .speed-trap, .clone-trap, .player-clone, .collectible, .key-item, .teleporter, .switch, .moving-platform, .timer-display').forEach(el => el.remove());
            
            updatePlayerPosition();
            setupLevel();
            updateProgressDisplay(); // æ›´æ–°è¿›åº¦æ˜¾ç¤º
            
            // ä¸éœ€è¦å†æ¬¡è°ƒç”¨gameLoop()ï¼Œå› ä¸ºå®ƒå·²ç»åœ¨è¿è¡Œ
        }

        // æ›´æ–°ç©å®¶ç§»åŠ¨
        function updatePlayerMovement() {
            if (gameState.gameOver || gameState.playerFrozen) return;
            
            const sm = gameState.specialMechanics;
            let moveX = 0, moveY = 0;
            
            // åŸºç¡€ç§»åŠ¨è¾“å…¥
            if (keys.ArrowUp) moveY -= playerSpeed;
            if (keys.ArrowDown) moveY += playerSpeed;
            if (keys.ArrowLeft) moveX -= playerSpeed;
            if (keys.ArrowRight) moveX += playerSpeed;
            
            // åå‘æ§åˆ¶
            if (sm.isReversed) {
                moveX = -moveX;
                moveY = -moveY;
            }
            
            // é‡åŠ›ç¿»è½¬
            if (sm.isGravityFlipped) {
                moveY = -moveY;
            }
            
            // æ»‘å†°æ¨¡å¼
            if (sm.isSlippery) {
                sm.momentum.x += moveX * 0.3;
                sm.momentum.y += moveY * 0.3;
                sm.momentum.x *= 0.95; // æ‘©æ“¦åŠ›
                sm.momentum.y *= 0.95;
                moveX = sm.momentum.x;
                moveY = sm.momentum.y;
            }
            
            // é£åŠ›å½±å“
            moveX += sm.windForce.x;
            moveY += sm.windForce.y;
            
            // åº”ç”¨ç§»åŠ¨
            gameState.player.x += moveX;
            gameState.player.y += moveY;
            
            updatePlayerPosition();
        }

        // æ¸¸æˆä¸»å¾ªç¯
        function gameLoop() {
            updatePlayerMovement();
            updateSpecialTraps();
            updateSpecialMechanics();
            checkCollisions();
            animationFrame = requestAnimationFrame(gameLoop);
        }
        
        // æ›´æ–°ç‰¹æ®Šæœºåˆ¶æ•ˆæœ
        function updateSpecialMechanics() {
            const sm = gameState.specialMechanics;
            
            // æ›´æ–°é»‘æš—æ¨¡å¼çš„å…‰ç…§
            if (sm.isDarkMode) {
                const playerX = gameState.player.x + 20; // ç©å®¶ä¸­å¿ƒ
                const playerY = gameState.player.y + 25;
                gameContainer.style.setProperty('--light-x', (playerX / gameWidth * 100) + '%');
                gameContainer.style.setProperty('--light-y', (playerY / gameHeight * 100) + '%');
                gameContainer.style.setProperty('--light-radius', sm.lightRadius + 'px');
            }
            
            // æ›´æ–°ç§»åŠ¨å¹³å°
            sm.movingPlatforms.forEach(platform => {
                platform.x += platform.speedX;
                platform.y += platform.speedY;
                
                // è¾¹ç•Œåå¼¹
                if (platform.x <= 0 || platform.x >= gameWidth - platform.width) {
                    platform.speedX = -platform.speedX;
                    platform.x = Math.max(0, Math.min(gameWidth - platform.width, platform.x));
                }
                if (platform.y <= 0 || platform.y >= gameHeight - platform.height) {
                    platform.speedY = -platform.speedY;
                    platform.y = Math.max(0, Math.min(gameHeight - platform.height, platform.y));
                }
                
                platform.element.style.left = platform.x + 'px';
                platform.element.style.top = platform.y + 'px';
                
                // æ£€æŸ¥ç©å®¶æ˜¯å¦åœ¨å¹³å°ä¸Š
                const playerRect = player.getBoundingClientRect();
                const platformRect = platform.element.getBoundingClientRect();
                
                if (playerRect.right > platformRect.left && 
                    playerRect.left < platformRect.right && 
                    playerRect.bottom > platformRect.top && 
                    playerRect.top < platformRect.bottom) {
                    // ç©å®¶è·Ÿéšå¹³å°ç§»åŠ¨
                    gameState.player.x += platform.speedX;
                    gameState.player.y += platform.speedY;
                    updatePlayerPosition();
                }
            });
        }

        // æ£€æŸ¥ç‰¹æ®Šå…ƒç´ äº¤äº’
        function checkSpecialElementInteractions(playerRect) {
            const sm = gameState.specialMechanics;
            
            // æ£€æŸ¥æ”¶é›†å“
            sm.collectibles.forEach((collectible, index) => {
                const collectibleRect = collectible.getBoundingClientRect();
                if (playerRect.right > collectibleRect.left && 
                    playerRect.left < collectibleRect.right && 
                    playerRect.bottom > collectibleRect.top && 
                    playerRect.top < collectibleRect.bottom) {
                    collectible.remove();
                    sm.collectibles.splice(index, 1);
                    playSuccessSound();
                    messageDisplay.textContent = `ğŸ’ æ”¶é›†åˆ°æ°´æ™¶ï¼è¿˜éœ€ ${sm.collectibles.length} ä¸ª`;
                }
            });
            
            // æ£€æŸ¥é’¥åŒ™
            document.querySelectorAll('.key-item').forEach(key => {
                const keyRect = key.getBoundingClientRect();
                if (playerRect.right > keyRect.left && 
                    playerRect.left < keyRect.right && 
                    playerRect.bottom > keyRect.top && 
                    playerRect.top < keyRect.bottom) {
                    key.remove();
                    sm.keys++;
                    playSuccessSound();
                    messageDisplay.textContent = `ğŸ—ï¸ è·å¾—é’¥åŒ™ï¼(${sm.keys}/${sm.requiredKeys})`;
                }
            });
            
            // æ£€æŸ¥ä¼ é€é—¨
            sm.teleporters.forEach(teleporter => {
                const teleporterRect = teleporter.getBoundingClientRect();
                if (playerRect.right > teleporterRect.left && 
                    playerRect.left < teleporterRect.right && 
                    playerRect.bottom > teleporterRect.top && 
                    playerRect.top < teleporterRect.bottom) {
                    // ä¼ é€åˆ°éšæœºä½ç½®
                    gameState.player.x = 100 + Math.random() * (gameWidth - 200);
                    gameState.player.y = 50 + Math.random() * (gameHeight - 150);
                    updatePlayerPosition();
                    playSuccessSound();
                    messageDisplay.textContent = 'ğŸŒ€ ä¼ é€æˆåŠŸï¼';
                }
            });
            
            // æ£€æŸ¥å¼€å…³
            sm.switches.forEach(switchEl => {
                const switchRect = switchEl.getBoundingClientRect();
                if (playerRect.right > switchRect.left && 
                    playerRect.left < switchRect.right && 
                    playerRect.bottom > switchRect.top && 
                    playerRect.top < switchRect.bottom) {
                    if (switchEl.dataset.activated === 'false') {
                        switchEl.dataset.activated = 'true';
                        switchEl.classList.add('activated');
                        playSuccessSound();
                        const activatedCount = sm.switches.filter(s => s.dataset.activated === 'true').length;
                        messageDisplay.textContent = `ğŸ”˜ å¼€å…³æ¿€æ´»ï¼(${activatedCount}/${sm.switches.length})`;
                    }
                }
            });
        }
        
        // æ›´æ–°è®¡æ—¶å™¨
        function updateTimer() {
            const sm = gameState.specialMechanics;
            if (sm.timeLimit > 0) {
                const elapsed = (Date.now() - sm.startTime) / 1000;
                const remaining = Math.max(0, sm.timeLimit - elapsed);
                
                const timerDisplay = document.getElementById('timer-display');
                if (timerDisplay) {
                    timerDisplay.textContent = `â° ${Math.ceil(remaining)}s`;
                    if (remaining <= 5) {
                        timerDisplay.classList.add('timer-warning');
                    }
                    
                    if (remaining <= 0) {
                        gameOver();
                        return;
                    }
                }
            }
        }
        
        // æ£€æŸ¥æ˜¯å¦å¯ä»¥é€šå…³
        function canPassLevel() {
            const sm = gameState.specialMechanics;
            
            // æ£€æŸ¥æ”¶é›†å“
            if (sm.collectibles.length > 0) {
                return false;
            }
            
            // æ£€æŸ¥é’¥åŒ™
            if (sm.requiredKeys > 0 && sm.keys < sm.requiredKeys) {
                return false;
            }
            
            // æ£€æŸ¥å¼€å…³
            if (sm.switches.length > 0) {
                const activatedCount = sm.switches.filter(s => s.dataset.activated === 'true').length;
                if (activatedCount < sm.switches.length) {
                    return false;
                }
            }
            
            return true;
        }
        
        // æ›´æ–°ç‰¹æ®Šé™·é˜±çš„è¡Œä¸º
        function updateSpecialTraps() {
            if (gameState.gameOver) return;
            
            gameState.traps.forEach(trap => {
                const trapType = trap.dataset.trapType;
                if (!trapType) return;
                
                const playerRect = player.getBoundingClientRect();
                const trapRect = trap.getBoundingClientRect();
                
                switch(trapType) {
                    case 'invisible':
                        // éšå½¢é™·é˜±ï¼šç©å®¶é è¿‘æ—¶æ˜¾ç°
                        const distance = Math.sqrt(
                            Math.pow(playerRect.left - trapRect.left, 2) + 
                            Math.pow(playerRect.top - trapRect.top, 2)
                        );
                        if (distance < 80 && trap.dataset.revealed === 'false') {
                            trap.dataset.revealed = 'true';
                            trap.classList.add('revealed');
                        }
                        break;
                        
                    case 'hunter':
                        // è¿½è¸ªé™·é˜±ï¼šè·Ÿç€ç©å®¶ç§»åŠ¨
                        const speed = parseFloat(trap.dataset.huntSpeed) || 2;
                        const currentLeft = parseFloat(trap.style.left);
                        const currentTop = parseFloat(trap.style.top);
                        
                        const playerX = gameState.player.x + 20; // ç©å®¶ä¸­å¿ƒç‚¹
                        const playerY = gameState.player.y + 25;
                        const trapX = currentLeft + 20; // é™·é˜±ä¸­å¿ƒç‚¹
                        const trapY = currentTop + 20;
                        
                        const dx = playerX - trapX;
                        const dy = playerY - trapY;
                        const magnitude = Math.sqrt(dx * dx + dy * dy);
                        
                        if (magnitude > 5) { // é¿å…æŠ–åŠ¨
                            const moveX = (dx / magnitude) * speed;
                            const moveY = (dy / magnitude) * speed;
                            
                            trap.style.left = Math.max(0, Math.min(gameWidth - 40, currentLeft + moveX)) + 'px';
                            trap.style.top = Math.max(0, Math.min(gameHeight - 40, currentTop + moveY)) + 'px';
                        }
                        break;
                        
                    case 'mirror':
                        // é•œåƒé™·é˜±ï¼šä¸ç©å®¶åšç›¸åç§»åŠ¨
                        const centerX = gameWidth / 2;
                        const centerY = gameHeight / 2;
                        const mirrorX = centerX - (gameState.player.x - centerX);
                        const mirrorY = centerY - (gameState.player.y - centerY);
                        
                        trap.style.left = Math.max(0, Math.min(gameWidth - 40, mirrorX - 20)) + 'px';
                        trap.style.top = Math.max(0, Math.min(gameHeight - 40, mirrorY - 25)) + 'px';
                        break;
                        
                    case 'gravity':
                        // é‡åŠ›é™·é˜±ï¼šå¸å¼•ç©å®¶
                        const gravityDistance = Math.sqrt(
                            Math.pow(playerRect.left - trapRect.left, 2) + 
                            Math.pow(playerRect.top - trapRect.top, 2)
                        );
                        
                        if (gravityDistance < 120) { // é‡åŠ›èŒƒå›´
                            const pullForce = parseFloat(trap.dataset.pullForce) || 3;
                            const trapCenterX = trapRect.left + trapRect.width / 2 - gameContainer.getBoundingClientRect().left;
                            const trapCenterY = trapRect.top + trapRect.height / 2 - gameContainer.getBoundingClientRect().top;
                            
                            const pullX = trapCenterX - (gameState.player.x + 20);
                            const pullY = trapCenterY - (gameState.player.y + 25);
                            const pullMagnitude = Math.sqrt(pullX * pullX + pullY * pullY);
                            
                            if (pullMagnitude > 0) {
                                gameState.player.x += (pullX / pullMagnitude) * pullForce * 0.3;
                                gameState.player.y += (pullY / pullMagnitude) * pullForce * 0.3;
                                updatePlayerPosition();
                            }
                        }
                        break;
                        
                    case 'blink':
                        // é—ªçƒé™·é˜±é€»è¾‘å·²é€šè¿‡CSSåŠ¨ç”»å¤„ç†
                        const computedStyle = window.getComputedStyle(trap);
                        trap.dataset.visible = computedStyle.opacity > 0.5 ? 'true' : 'false';
                        break;
                }
            });
        }

        // é”®ç›˜æ§åˆ¶
        document.addEventListener('keydown', (e) => {
            if (gameState.gameOver) return;
            
            if (e.key in keys) {
                keys[e.key] = true;
            }
        });

        document.addEventListener('keyup', (e) => {
            if (e.key in keys) {
                keys[e.key] = false;
            }
        });

        // äº‹ä»¶ç›‘å¬
        nextBtn.addEventListener('click', () => {
            playClickSound();
            nextLevel();
        });
        
        restartBtn.addEventListener('click', () => {
            playClickSound();
            startLevel();
        });
        
        levelSelectBtn.addEventListener('click', () => {
            playClickSound();
            createLevelButtons();
            levelSelectModal.classList.remove('hidden');
        });
        
        soundToggleBtn.addEventListener('click', toggleSound);
        
        musicToggleBtn.addEventListener('click', () => {
            playClickSound();
            toggleMusic();
        });
        
        helpBtn.addEventListener('click', () => {
            playClickSound();
            helpModal.classList.remove('hidden');
        });
        
        closeSelectBtn.addEventListener('click', () => {
            playClickSound();
            levelSelectModal.classList.add('hidden');
        });
        
        closeHelpBtn.addEventListener('click', () => {
            playClickSound();
            helpModal.classList.add('hidden');
        });
        
        resetProgressBtn.addEventListener('click', () => {
            playClickSound();
            if (confirm('ç¡®å®šè¦é‡ç½®æ‰€æœ‰è¿›åº¦å—ï¼Ÿè¿™å°†åˆ é™¤æ‚¨çš„æ‰€æœ‰æ¸¸æˆè®°å½•ï¼')) {
                resetProgress();
                initGame();
                messageDisplay.textContent = 'è¿›åº¦å·²é‡ç½®ï¼';
                setTimeout(() => {
                    messageDisplay.textContent = '';
                }, 2000);
            }
        });

        // é¡µé¢åŠ è½½æ—¶ç«‹å³éšè—å…³å¡é€‰æ‹©å™¨å’Œå¸®åŠ©é¢æ¿
        levelSelectModal.classList.add('hidden');
        helpModal.classList.add('hidden');
        
        // å¤„ç†é¦–æ¬¡ç”¨æˆ·äº¤äº’ï¼ˆç”¨äºå¯åŠ¨èƒŒæ™¯éŸ³ä¹ï¼‰
        let firstInteraction = true;
        function handleFirstInteraction() {
            if (firstInteraction && musicEnabled && backgroundMusic) {
                playBackgroundMusic();
                firstInteraction = false;
            }
        }

        // ç›‘å¬å„ç§ç”¨æˆ·äº¤äº’äº‹ä»¶
        document.addEventListener('click', handleFirstInteraction);
        document.addEventListener('keydown', handleFirstInteraction);
        document.addEventListener('touchstart', handleFirstInteraction);
        
        // å¼€å§‹æ¸¸æˆ
        initGame();
        gameLoop();
    </script>
</body>
</html>