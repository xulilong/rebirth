<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ‹¯æ•‘Zack - MTå†’é™©</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            text-align: center;
            background-color: #222;
            color: white;
            margin: 0;
            padding: 20px;
            overflow: hidden;
        }
        #game-container {
            position: relative;
            width: 800px;
            height: 500px;
            margin: 0 auto;
            background-color: #333;
            border: 3px solid #555;
            overflow: hidden;
        }
        #player {
            position: absolute;
            width: 40px;
            height: 50px;
            z-index: 10;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        #player::before {
            content: 'ğŸ§™â€â™‚ï¸';
            font-size: 35px;
            animation: fly 1s ease-in-out infinite alternate;
        }
        
        @keyframes fly {
            0% { transform: translateY(0px) rotate(-2deg); }
            100% { transform: translateY(-8px) rotate(2deg); }
        }
        #door {
            position: absolute;
            width: 60px;
            height: 100px;
            background: linear-gradient(135deg, #2c2c2c 0%, #1a1a1a 50%, #000 100%);
            border: 5px solid #8B4513;
            border-radius: 10px 10px 0 0;
            right: 20px;
            bottom: 0;
            z-index: 5;
            box-shadow: inset 0 0 20px rgba(0,0,0,0.8);
        }
        
        #door::before {
            content: 'ğŸšª';
            position: absolute;
            font-size: 40px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            opacity: 0.8;
        }
        
        #door::after {
            content: '';
            position: absolute;
            width: 8px;
            height: 8px;
            background: #FFD700;
            border-radius: 50%;
            right: 8px;
            top: 45%;
            box-shadow: 0 0 5px rgba(255, 215, 0, 0.5);
        }
        .trap {
            position: absolute;
            background-color: #8B4513;
            border: 2px solid #654321;
            z-index: 2;
        }
        .level-info {
            font-size: 24px;
            margin: 10px 0;
        }
        #progress-info {
            font-size: 18px;
            color: #FFD700;
            font-weight: normal;
        }

        #loop-info {
            color: #e74c3c;
            font-size: 18px;
            margin-left: 15px;
            font-weight: bold;
        }
        
        .location-info {
            text-align: center;
            margin-bottom: 15px;
            font-size: 18px;
            font-weight: bold;
            color: #e74c3c;
            background: rgba(255,255,255,0.1);
            padding: 8px 15px;
            border-radius: 20px;
            display: inline-block;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            border: 2px solid #e74c3c;
        }
        .controls {
            margin: 20px 0;
        }
        button {
            padding: 10px 20px;
            font-size: 16px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin: 0 10px;
        }
        button:hover {
            background-color: #45a049;
        }
        
        /* å…³å¡é€‰æ‹©å™¨æ ·å¼ */
        #level-select {
            background-color: rgba(0,0,0,0.9);
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 100;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
        }
        
        #level-select.hidden {
            display: none !important;
        }
        
        #level-buttons {
            display: grid;
            grid-template-columns: repeat(10, 60px);
            gap: 10px;
            margin: 20px;
            max-height: 300px;
            overflow-y: auto;
        }
        
        .level-btn {
            width: 60px;
            height: 60px;
            border-radius: 10px;
            font-size: 16px;
            font-weight: bold;
        }
        
        .level-btn.unlocked {
            background-color: #4CAF50;
            border: 2px solid #45a049;
        }
        
        .level-btn.current {
            background-color: #FFD700;
            color: #333;
            border: 2px solid #FFA500;
        }
        
        .level-btn.locked {
            background-color: #666;
            color: #999;
            cursor: not-allowed;
            border: 2px solid #555;
        }
        
        #close-select-btn {
            background-color: #f44336;
            margin-top: 20px;
        }
        
        #close-select-btn:hover {
            background-color: #da190b;
        }
        
        #reset-progress-btn {
            background-color: #ff9800;
        }
        
        #reset-progress-btn:hover {
            background-color: #e68900;
        }
        
        /* éŸ³ä¹æ§åˆ¶æŒ‰é’®æ ·å¼ */
        #music-toggle-btn {
            background-color: #9C27B0;
        }
        
        #music-toggle-btn:hover {
            background-color: #7B1FA2;
        }
        

        

        #message {
            font-size: 24px;
            height: 30px;
            margin: 10px 0;
            color: #FFD700;
        }
        .hidden {
            display: none;
        }

        /* å¯¹è¯æ¡†æ ·å¼ */
        .dialog-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .dialog-box {
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            border-radius: 15px;
            padding: 30px;
            max-width: 500px;
            width: 90%;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            text-align: center;
            position: relative;
            border: 3px solid #e74c3c;
        }

        .dialog-title {
            font-size: 1.5em;
            font-weight: bold;
            color: #e74c3c;
            margin-bottom: 20px;
        }

        .dialog-content {
            font-size: 1.1em;
            line-height: 1.6;
            color: #ecf0f1;
            margin-bottom: 25px;
            text-align: left;
            white-space: pre-line;
        }

        .dialog-btn {
            background: linear-gradient(45deg, #e74c3c, #c0392b);
            color: white;
            padding: 12px 30px;
            border: none;
            border-radius: 8px;
            font-size: 1.1em;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
        }

        .dialog-btn:hover {
            background: linear-gradient(45deg, #c0392b, #e74c3c);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(231, 76, 60, 0.4);
        }

        /* Zackæ‹¯æ•‘æˆåŠŸå¯¹è¯æ¡†æ ·å¼ */
        .zack-success-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, rgba(26, 26, 46, 0.95) 0%, rgba(44, 62, 80, 0.95) 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            animation: successFade 0.8s ease-in;
        }

        @keyframes successFade {
            from { opacity: 0; transform: scale(0.8); }
            to { opacity: 1; transform: scale(1); }
        }

        .zack-success-box {
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            border-radius: 20px;
            padding: 40px;
            max-width: 600px;
            width: 90%;
            box-shadow: 0 15px 40px rgba(0,0,0,0.6);
            text-align: center;
            position: relative;
            border: 4px solid #FFD700;
            animation: boxBounce 0.6s ease-out 0.2s both;
        }

        @keyframes boxBounce {
            0% { transform: translateY(-50px); opacity: 0; }
            60% { transform: translateY(10px); opacity: 1; }
            100% { transform: translateY(0); opacity: 1; }
        }

        .zack-avatar {
            width: 120px;
            height: 120px;
            border-radius: 50%;
            margin: 0 auto 20px;
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 60px;
            border: 4px solid #FFD700;
            box-shadow: 0 8px 20px rgba(0,0,0,0.3);
            animation: avatarGlow 2s ease-in-out infinite alternate;
            background-image: url('images/zack.jpeg');
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
        }

        .zack-avatar.fallback {
            background-image: none;
        }

        @keyframes avatarGlow {
            0% { box-shadow: 0 8px 20px rgba(0,0,0,0.3), 0 0 0 0 rgba(255, 215, 0, 0.7); }
            100% { box-shadow: 0 8px 20px rgba(0,0,0,0.3), 0 0 0 20px rgba(255, 215, 0, 0); }
        }

        .zack-success-title {
            font-size: 2.2em;
            font-weight: bold;
            color: #FFD700;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .zack-success-content {
            font-size: 1.2em;
            line-height: 1.6;
            color: #ecf0f1;
            margin-bottom: 30px;
            text-align: left;
        }

        .zack-success-btn {
            background: linear-gradient(45deg, #FFD700, #FFA500);
            color: #1a1a2e;
            padding: 15px 40px;
            border: none;
            border-radius: 10px;
            font-size: 1.2em;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
            box-shadow: 0 4px 15px rgba(255, 215, 0, 0.4);
        }

        .zack-success-btn:hover {
            background: linear-gradient(45deg, #FFA500, #FFD700);
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(255, 215, 0, 0.6);
        }

        /* CEOå°±èŒä»ªå¼åŠ¨ç”» */
        .ceo-ceremony-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1001;
            animation: ceremonyFadeIn 1s ease-in;
        }

        @keyframes ceremonyFadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .mt-logo {
            font-size: 8em;
            font-weight: bold;
            background: linear-gradient(45deg, #FFD700, #FFA500, #FF6B35);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 30px;
            animation: logoGlow 2s ease-in-out infinite alternate;
            text-shadow: 0 0 30px rgba(255, 215, 0, 0.5);
        }

        @keyframes logoGlow {
            0% { 
                transform: scale(1);
                filter: brightness(1);
            }
            100% { 
                transform: scale(1.05);
                filter: brightness(1.2);
            }
        }

        .ceo-title {
            font-size: 3em;
            color: #FFD700;
            margin-bottom: 20px;
            animation: titleSlideIn 1.5s ease-out 0.5s both;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }

        @keyframes titleSlideIn {
            from { 
                opacity: 0;
                transform: translateY(50px);
            }
            to { 
                opacity: 1;
                transform: translateY(0);
            }
        }

        .ceo-subtitle {
            font-size: 1.5em;
            color: #ecf0f1;
            margin-bottom: 40px;
            animation: subtitleFadeIn 1.5s ease-out 1s both;
            text-align: center;
            max-width: 600px;
        }

        @keyframes subtitleFadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .fireworks {
            position: absolute;
            width: 100%;
            height: 100%;
            pointer-events: none;
            overflow: hidden;
        }

        .firework {
            position: absolute;
            width: 4px;
            height: 4px;
            border-radius: 50%;
            animation: fireworkExplode 2s ease-out infinite;
        }

        @keyframes fireworkExplode {
            0% {
                transform: scale(0);
                opacity: 1;
            }
            50% {
                transform: scale(1);
                opacity: 1;
            }
            100% {
                transform: scale(2);
                opacity: 0;
            }
        }

        .confetti {
            position: absolute;
            width: 10px;
            height: 10px;
            animation: confettiFall 3s linear infinite;
        }

        @keyframes confettiFall {
            0% {
                transform: translateY(-100vh) rotate(0deg);
                opacity: 1;
            }
            100% {
                transform: translateY(100vh) rotate(360deg);
                opacity: 0;
            }
        }

        .mt-values {
            display: flex;
            gap: 40px;
            margin-top: 30px;
            animation: valuesSlideUp 2s ease-out 1.5s both;
        }

        @keyframes valuesSlideUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .value-item {
            text-align: center;
            color: #bdc3c7;
            font-size: 1.1em;
            max-width: 200px;
        }

        .value-icon {
            font-size: 2em;
            margin-bottom: 10px;
            display: block;
        }

        .value-desc {
            font-size: 0.9em;
            color: #95a5a6;
            margin-top: 5px;
            line-height: 1.3;
        }

        .continue-btn {
            background: linear-gradient(45deg, #FFD700, #FFA500);
            color: #1a1a2e;
            padding: 15px 40px;
            border: none;
            border-radius: 10px;
            font-size: 1.2em;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
            margin-top: 40px;
            animation: btnAppear 2s ease-out 2s both;
            box-shadow: 0 4px 15px rgba(255, 215, 0, 0.4);
        }

        @keyframes btnAppear {
            from {
                opacity: 0;
                transform: scale(0.8);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        .continue-btn:hover {
            background: linear-gradient(45deg, #FFA500, #FFD700);
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(255, 215, 0, 0.6);
        }
        .spike {
            position: absolute;
            width: 0;
            height: 0;
            border-left: 15px solid transparent;
            border-right: 15px solid transparent;
            border-bottom: 30px solid #696969;
            bottom: 0;
        }
        .moving-trap {
            position: absolute;
            width: 40px;
            height: 40px;
            background-color: #FF6347;
            border: 2px solid #DC143C;
            border-radius: 50%;
            z-index: 2;
        }
        
        /* æ–°çš„é™·é˜±ç±»å‹æ ·å¼ */
        .invisible-trap {
            position: absolute;
            background-color: rgba(128, 128, 128, 0.1);
            border: 2px dashed rgba(128, 128, 128, 0.3);
            z-index: 2;
            transition: opacity 0.3s ease;
        }
        
        .invisible-trap.revealed {
            background-color: rgba(105, 105, 105, 0.8);
            border: 2px solid #696969;
        }
        
        .teleport-trap {
            position: absolute;
            width: 50px;
            height: 50px;
            background: radial-gradient(circle, #9C27B0, #673AB7);
            border-radius: 50%;
            z-index: 2;
            animation: teleportPulse 2s ease-in-out infinite;
        }
        
        @keyframes teleportPulse {
            0%, 100% { transform: scale(1); opacity: 0.7; }
            50% { transform: scale(1.2); opacity: 1; }
        }
        
        .hunter-trap {
            position: absolute;
            width: 35px;
            height: 35px;
            background-color: #FF4500;
            border-radius: 50%;
            z-index: 2;
            border: 3px solid #FF6347;
            animation: hunterGlow 1s ease-in-out infinite alternate;
        }
        
        @keyframes hunterGlow {
            0% { box-shadow: 0 0 5px #FF4500; }
            100% { box-shadow: 0 0 15px #FF4500, 0 0 25px #FF4500; }
        }
        
        .blink-trap {
            position: absolute;
            background-color: #00BCD4;
            z-index: 2;
            animation: blinkTrap 3s ease-in-out infinite;
        }
        
        @keyframes blinkTrap {
            0%, 40% { opacity: 1; }
            50%, 90% { opacity: 0; }
            100% { opacity: 1; }
        }
        
        .gravity-trap {
            position: absolute;
            width: 60px;
            height: 60px;
            background: radial-gradient(circle, rgba(0,0,0,0.8), rgba(0,0,0,0.3));
            border: 3px solid #333;
            border-radius: 50%;
            z-index: 2;
            animation: gravityPull 2s ease-in-out infinite;
        }
        
        @keyframes gravityPull {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
        
        .split-trap {
            position: absolute;
            width: 45px;
            height: 45px;
            background-color: #32CD32;
            border: 2px solid #228B22;
            z-index: 2;
            border-radius: 10px;
            transform: rotate(45deg);
        }
        
        .mirror-trap {
            position: absolute;
            width: 40px;
            height: 40px;
            background: linear-gradient(45deg, #C0C0C0, #808080);
            border-radius: 50%;
            z-index: 2;
            border: 2px solid #999;
            animation: mirrorShine 2s linear infinite;
        }
        
        @keyframes mirrorShine {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .freeze-trap {
            position: absolute;
            width: 40px;
            height: 40px;
            background: linear-gradient(45deg, #00E5FF, #0277BD);
            border-radius: 50%;
            z-index: 2;
            animation: freezeEffect 1.5s ease-in-out infinite;
        }
        
        @keyframes freezeEffect {
            0%, 100% { transform: scale(1); filter: hue-rotate(0deg); }
            50% { transform: scale(0.9); filter: hue-rotate(90deg); }
        }
        
        .bounce-trap {
            position: absolute;
            width: 40px;
            height: 40px;
            background: linear-gradient(45deg, #FF1493, #FF69B4);
            border-radius: 50%;
            z-index: 2;
            animation: bounceEffect 1s ease-in-out infinite;
        }
        
        @keyframes bounceEffect {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
        }
        
        .shrink-trap {
            position: absolute;
            width: 40px;
            height: 40px;
            background: linear-gradient(45deg, #FFD700, #FFA500);
            border-radius: 50%;
            z-index: 2;
            animation: shrinkEffect 2s ease-in-out infinite;
        }
        
        @keyframes shrinkEffect {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(0.5); }
        }
        
        .speed-trap {
            position: absolute;
            width: 40px;
            height: 40px;
            background: linear-gradient(45deg, #00FF00, #32CD32);
            border-radius: 50%;
            z-index: 2;
            animation: speedEffect 0.5s linear infinite;
        }
        
        @keyframes speedEffect {
            0% { transform: rotate(0deg) scale(1); }
            100% { transform: rotate(360deg) scale(1.1); }
        }
        
        .clone-trap {
            position: absolute;
            width: 40px;
            height: 40px;
            background: linear-gradient(45deg, #8A2BE2, #9370DB);
            border-radius: 50%;
            z-index: 2;
            animation: cloneEffect 1.5s ease-in-out infinite;
        }
        
        @keyframes cloneEffect {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.5; transform: scale(1.2); }
        }
        
        /* çˆ†ç‚¸ç‰¹æ•ˆ */
        .explosion {
            position: absolute;
            width: 100px;
            height: 100px;
            z-index: 15;
            pointer-events: none;
        }
        
        .explosion::before {
            content: 'ğŸ’¥';
            font-size: 80px;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            animation: explode 0.8s ease-out;
        }
        
        @keyframes explode {
            0% {
                transform: translate(-50%, -50%) scale(0.1);
                opacity: 1;
            }
            50% {
                transform: translate(-50%, -50%) scale(1.2);
                opacity: 1;
            }
            100% {
                transform: translate(-50%, -50%) scale(1.5);
                opacity: 0;
            }
        }
        
        /* è¿‡å…³ç‰¹æ•ˆ */
        .level-complete {
            position: absolute;
            width: 100px;
            height: 100px;
            z-index: 15;
            pointer-events: none;
        }
        
        .level-complete::before {
            content: 'âœ¨';
            font-size: 60px;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            animation: sparkle 1s ease-out;
        }
        
        @keyframes sparkle {
            0% {
                transform: translate(-50%, -50%) scale(0.5) rotate(0deg);
                opacity: 1;
            }
            50% {
                transform: translate(-50%, -50%) scale(1.2) rotate(180deg);
                opacity: 1;
            }
            100% {
                transform: translate(-50%, -50%) scale(1.5) rotate(360deg);
                opacity: 0;
            }
        }
    </style>
</head>
<body>
    <h1>æ‹¯æ•‘Zack - MTå†’é™©</h1>
    <div class="level-info">
        ç¬¬ <span id="level">1</span> å…³ 
        <span id="progress-info">(æœ€é«˜è®°å½•: ç¬¬ <span id="max-level">1</span> å…³)</span>
        <span id="loop-info">ğŸ”„ ç¬¬ <span id="loop-count">3</span> æ¬¡å¾ªç¯</span>
    </div>
    <div class="location-info">
        ğŸ“ å½“å‰ä½ç½®: <span id="location">å…¬å¸å‰å°</span>
    </div>
    <div id="message"></div>
    <div id="game-container">
        <div id="player"></div>
        <div id="door"></div>
        <!-- é™·é˜±å°†ç”±JSåŠ¨æ€ç”Ÿæˆ -->
    </div>
    <div class="controls">
        <button id="restart-btn">é‡æ–°å¼€å§‹å½“å‰å…³</button>
        <button id="next-btn" class="hidden">ä¸‹ä¸€å…³</button>
        <button id="level-select-btn">é€‰æ‹©å…³å¡</button>
        <button id="sound-toggle-btn">ğŸ”Š éŸ³æ•ˆ</button>
        <button id="music-toggle-btn">ğŸµ éŸ³ä¹</button>
        <button id="reset-progress-btn">é‡ç½®è¿›åº¦</button>
    </div>
    <div id="level-select" class="hidden">
        <h3>é€‰æ‹©å…³å¡ (å·²è§£é”: ç¬¬1-<span id="unlocked-levels">1</span>å…³)</h3>
        <div id="level-buttons"></div>
        <button id="close-select-btn">å…³é—­</button>
    </div>

    <script>
        // æ¸¸æˆçŠ¶æ€
        const gameState = {
            currentLevel: 1,
            maxLevel: 10,
            maxUnlockedLevel: 1, // æœ€é«˜è§£é”å…³å¡
            player: { x: 50, y: 250 },
            isMoving: false,
            gameOver: false,
            traps: [],
            movingTraps: [],
            specialTraps: [], // ç‰¹æ®Šé™·é˜±æ•°ç»„
            playerFrozen: false, // ç©å®¶æ˜¯å¦è¢«å†°å†»
            freezeEndTime: 0, // å†°å†»ç»“æŸæ—¶é—´
            levelLayouts: {} // å­˜å‚¨æ¯å…³çš„é™·é˜±å¸ƒå±€
        };

        // æœ¬åœ°å­˜å‚¨ç›¸å…³å‡½æ•°
        function saveProgress() {
            try {
                localStorage.setItem('wizardGame_maxLevel', gameState.maxUnlockedLevel);
                localStorage.setItem('wizardGame_currentLevel', gameState.currentLevel);
                localStorage.setItem('wizardGame_loopCount', loopCount);
            } catch (e) {
                console.log('æ— æ³•ä¿å­˜è¿›åº¦:', e);
            }
        }

        function loadProgress() {
            try {
                const savedMaxLevel = localStorage.getItem('wizardGame_maxLevel');
                const savedCurrentLevel = localStorage.getItem('wizardGame_currentLevel');
                const savedLoopCount = localStorage.getItem('wizardGame_loopCount');
                
                if (savedMaxLevel) {
                    gameState.maxUnlockedLevel = parseInt(savedMaxLevel);
                }
                if (savedCurrentLevel) {
                    gameState.currentLevel = Math.min(parseInt(savedCurrentLevel), gameState.maxUnlockedLevel);
                }
                if (savedLoopCount) {
                    loopCount = parseInt(savedLoopCount);
                } else {
                    loopCount = 3; // é»˜è®¤å€¼
                }
            } catch (e) {
                console.log('æ— æ³•åŠ è½½è¿›åº¦:', e);
            }
        }

        function resetProgress() {
            try {
                localStorage.removeItem('wizardGame_maxLevel');
                localStorage.removeItem('wizardGame_currentLevel');
                localStorage.removeItem('wizardGame_loopCount');
                gameState.maxUnlockedLevel = 1;
                gameState.currentLevel = 1;
                loopCount = 3; // é‡ç½®å¾ªç¯æ¬¡æ•°
                updateProgressDisplay(); // æ›´æ–°æ˜¾ç¤º
            } catch (e) {
                console.log('æ— æ³•é‡ç½®è¿›åº¦:', e);
            }
        }

        // å…³å¡ä½ç½®ä¿¡æ¯ - MTå…¬å¸æ¢ç´¢ä¹‹æ—…
        const levelLocations = {
            1: "ğŸ¢ å…¬å¸å‰å° - åˆæ¥ä¹åˆ°",
            2: "ğŸ½ï¸ ç¬¬ä¸€é£Ÿå ‚ - è§…é£Ÿæ—¶å…‰", 
            3: "ğŸ“‹ ä¼šè®®å®¤-æ–‡æ˜ - æ–‡åŒ–æ´—ç¤¼",
            4: "ğŸ§© ä¼šè®®å®¤-ä¹é«˜ - åˆ›æ„ç©ºé—´",
            5: "ğŸï¸ ä¼šè®®å®¤-å›éŸ³ç¾¤å²› - æ€ç»´ç¢°æ’",
            6: "ğŸœ ç¬¬äºŒé£Ÿå ‚ - èƒ½é‡è¡¥ç»™",
            7: "ğŸ’» HOPé¡¹ç›®ç»„ - æŠ€æœ¯å‰æ²¿",
            8: "ğŸš€ JUMPé¡¹ç›®ç»„ - æ•æ·å¼€å‘",
            9: "âš™ï¸ æŠ€æœ¯éƒ¨æ ¸å¿ƒ - ç³»ç»Ÿä¸­æ¢",
            10: "ğŸ‘‘ CEOåŠå…¬å®¤ - æœ€ç»ˆå†³æˆ˜"
        };

        // å…³å¡å¯¹è¯ä¿¡æ¯ - æ·±åº¦å‰§æƒ…ä½“éªŒ
        const levelDialogs = {
            1: {
                title: "ğŸ”„ æ—¶ç©ºå¾ªç¯çš„å¼€å§‹",
                content: () => `æ¬¢è¿æ¥åˆ°Magic Tavernï¼å’¦ï¼Ÿè¿™ç§ä¼¼æ›¾ç›¸è¯†çš„æ„Ÿè§‰...ç­‰ç­‰ï¼Œè¿™å·²ç»æ˜¯ç¬¬${loopCount}æ¬¡å¾ªç¯äº†ï¼Ÿï¼æˆ‘æ˜¯ä¸æ˜¯åœ¨åšæ¢¦ï¼Ÿè¿˜æ˜¯æ˜¨æ™šåŠ ç­å¤ªæ™šäº§ç”Ÿå¹»è§‰äº†ï¼Ÿï¼

ğŸ® ä»»åŠ¡æç¤ºï¼šCEO Zackå¯èƒ½é‡åˆ°äº†éº»çƒ¦ï¼Œéœ€è¦ä½ çš„å¸®åŠ©ï¼
ğŸ’¡ æ“ä½œæŒ‡å—ï¼šç”¨æ–¹å‘é”®æ§åˆ¶è§’è‰²ç§»åŠ¨ï¼Œé¿å¼€çº¢è‰²éšœç¢ç‰©ï¼Œåˆ°è¾¾ç»¿è‰²å‡ºå£å°±èƒ½è¿›å…¥ä¸‹ä¸€å…³ï¼`
            },
            2: {
                title: "ğŸ½ï¸ MTäººçš„æ—¥å¸¸ - å¹²é¥­ç¬¬ä¸€",
                content: `å¾ªç¯ï¼Ÿå¼€ä»€ä¹ˆç©ç¬‘ï¼Ÿä½œä¸ºä¸€ä¸ªæ‰“å·¥äººï¼Œè¿˜æ˜¯å¹²é¥­é‡è¦ï¼12ç‚¹åŠäº†ï¼Œå†²ï¼ï¼ï¼

ğŸœ å…³å¡ç‰¹è‰²ï¼šåœ¨ç¾é£Ÿçš„è¯±æƒ‘ä¸­ä¿æŒä¸“æ³¨ï¼Œä¸è¦è¢«é¦™å‘³åˆ†æ•£æ³¨æ„åŠ›ï¼
âš ï¸ éš¾åº¦æå‡ï¼šå‡ºç°äº†ç§»åŠ¨çš„éšœç¢ç‰©ï¼å®ƒä»¬å°±åƒå¿™ç¢Œçš„æœåŠ¡å‘˜ä¸€æ ·æ¥å›ç©¿æ¢­ï¼Œå°å¿ƒåˆ«æ’ä¸Šï¼`
            },
            3: {
                title: "ğŸ“‹ ä¼ä¸šæ–‡åŒ–çš„åŠ›é‡",
                content: `æ–‡æ˜ä¼šè®®å®¤ï¼Œå¢™ä¸Šè´´ç€ä¼ä¸šæ–‡åŒ–æ ‡è¯­ï¼Œçœ‹èµ·æ¥å¾ˆæœ‰ç²¾ç¥ï¼çœŸè¯šã€è¿›å–ã€è´Ÿè´£ã€é½å¿ƒååŠ›...è¿™äº›è¯æˆ‘éƒ½è®¤è¯†ï¼Œç»„åˆåœ¨ä¸€èµ·å°±å¾ˆæœ‰åŠ›é‡çš„æ„Ÿè§‰ã€‚

âš¡ å°å°æŒ‘æˆ˜ï¼šä¼šè®®å®¤é‡Œçš„éšœç¢ç‰©å˜å¤šäº†ï¼Œå°±åƒå¼€ä¼šæ—¶çªç„¶å†’å‡ºçš„æ–°æƒ³æ³•ä¸€æ ·ï¼Œéœ€è¦çµæ´»åº”å¯¹ï¼`
            },
            4: {
                title: "ğŸ§© åˆ›æ„æ— é™çš„ä¹é«˜ç©ºé—´",
                content: `ä¹é«˜ä¼šè®®å®¤ï¼å“‡ï¼Œè¿™é‡Œçš„ä¹é«˜æ¨¡å‹å¥½ç²¾è‡´ï¼Œä¸€å®šèŠ±äº†ä¸å°‘å¿ƒæ€ï¼é‚£ä¸ªåŸå ¡æ¨¡å‹...å’¦ï¼Œè¿™ä¸ªç»“æ„æ€ä¹ˆè¿™ä¹ˆçœ¼ç†Ÿï¼Ÿè¯¥ä¸ä¼šæ˜¯æŒ‰æˆ‘ä»¬çš„ç³»ç»Ÿæ¶æ„æ­çš„å§ï¼Ÿ

ğŸ¨ æ¸¸æˆå¿ƒå¾—ï¼šå°±åƒæ­ä¹é«˜éœ€è¦è€å¿ƒä¸€æ ·ï¼Œé€šè¿‡è¿™äº›éšœç¢ä¹Ÿéœ€è¦ç»†å¿ƒè§„åˆ’è·¯çº¿ï¼`
            },
            5: {
                title: "ğŸï¸ å›éŸ³ç¾¤å²›çš„æ™ºæ…§ç¢°æ’",
                content: `å›éŸ³ç¾¤å²›ä¼šè®®å®¤ï¼Œè¿™åå­—èµ·å¾—çœŸæœ‰è¯—æ„ï¼ä¸€å¬å°±çŸ¥é“æ˜¯ä¸ªæœ‰æ–‡åŒ–çš„äººæƒ³å‡ºæ¥çš„ã€‚å¢™ä¸Šçš„æµ·æ´‹ä¸»é¢˜è£…é¥°ç”»å¾ˆæ¼‚äº®ï¼Œè“è‰²è°ƒçœ‹ç€å°±è®©äººå¿ƒæƒ…èˆ’ç•…ã€‚"å›éŸ³"è¿™ä¸ªæ¦‚å¿µä¹Ÿå¾ˆæœ‰æ„æ€ï¼

ğŸŒªï¸ ç­–ç•¥å‡çº§ï¼šå°±åƒåœ¨å²›å±¿é—´èˆªè¡Œä¸€æ ·ï¼Œéœ€è¦æ‰¾åˆ°æœ€ä½³è·¯å¾„æ¥åº”å¯¹è¿™äº›è¶Šæ¥è¶Šå¤æ‚çš„éšœç¢ï¼`
            },
            6: {
                title: "ğŸœ èƒ½é‡è¡¥ç»™ç«™ - ç¬¬äºŒé£Ÿå ‚",
                content: `ç¬¬äºŒé£Ÿå ‚ï¼è¿™é‡Œé€‰æ‹©æ›´å¤šï¼Œäººæ°”ä¹Ÿæ›´æ—ºï¼å¹²é¥­å¹²é¥­ï¼ï¼ï¼

âš¡ æ´»åŠ›æ»¡æ»¡ï¼šåƒé¥±äº†æœç„¶ç²¾ç¥ç™¾å€ï¼ä¸è¿‡è¿™äº›éšœç¢ç‰©å¥½åƒä¹Ÿè·Ÿç€"å‡çº§"äº†ï¼ŒæŒ‘æˆ˜æ›´å¤§äº†ï¼`
            },
            7: {
                title: "ğŸ’» HOPé¡¹ç›®ç»„ - æŠ€æœ¯å‰æ²¿",
                content: `HOPé¡¹ç›®ç»„ï¼Œå¤§å±å¹•ä¸Šå„ç§èŠ±é‡Œèƒ¡å“¨çš„å›¾è¡¨ï¼Œçœ‹èµ·æ¥å¾ˆå‰å®³çš„æ ·å­ï¼Œç¨‹åºå‘˜ä»¬åœ¨ç–¯ç‹‚æ•²é”®ç›˜ï¼Œä¸çŸ¥é“æ˜¯åœ¨å†™ä»£ç è¿˜æ˜¯åœ¨èŠå¤©æ‘¸é±¼ã€‚

ğŸš¨ Bugè­¦æŠ¥ï¼šç³»ç»Ÿå¼€å§‹æŠ¥è­¦äº†ï¼è¿™äº›ç§»åŠ¨çš„éšœç¢ç‰©è¯¥ä¸ä¼šå°±æ˜¯ä¼ è¯´ä¸­çš„"çº¿ä¸ŠBug"å§ï¼Ÿ`
            },
            8: {
                title: "ğŸš€ JUMPé¡¹ç›®ç»„ - æ•æ·å¼€å‘",
                content: `JUMPé¡¹ç›®ç»„ï¼è¿™åå­—ä¸€å¬å°±å¾ˆæœ‰æ´»åŠ›ï¼Œå……æ»¡äº†"è·³è·ƒ"çš„æ„Ÿè§‰ï¼

ğŸƒâ€â™‚ï¸ é€Ÿåº¦æŒ‘æˆ˜ï¼šåœ¨è¿™ç§å¿«èŠ‚å¥çš„ç¯å¢ƒä¸‹ï¼Œæˆ‘ä¹Ÿè¦åŠ å¿«é€Ÿåº¦äº†ï¼è¿™äº›éšœç¢ç‰©å˜åŒ–çœŸå¿«ï¼`
            },
            9: {
                title: "âš™ï¸ æŠ€æœ¯éƒ¨æ ¸å¿ƒ - ç³»ç»Ÿä¸­æ¢",
                content: `æŠ€æœ¯éƒ¨æ ¸å¿ƒåŒºåŸŸï¼è¿™é‡Œå°±æ˜¯MTçš„"å¤§è„‘ä¸­æ¢"ï¼å—¡å—¡ä½œå“çš„æœåŠ¡å™¨ä»¬æ­£åœ¨è¾›å‹¤å·¥ä½œï¼Œå°±åƒæ°¸ä¸åœæ­‡çš„å¿ƒè„ï¼

âš ï¸ ç»ˆææŒ‘æˆ˜ï¼šå“‡ï¼Œç³»ç»Ÿè­¦æŠ¥å£°æ­¤èµ·å½¼ä¼ï¼çœ‹æ¥çœŸçš„é‡åˆ°å¤§é—®é¢˜äº†ï¼Œæ˜¯æ—¶å€™å±•ç°çœŸæ­£çš„æŠ€æœ¯äº†ï¼`
            },
            10: {
                title: "ğŸ‘‘ CEOåŠå…¬å®¤ - æ‹¯æ•‘ä½¿å‘½",
                content: `CEOåŠå…¬å®¤ï¼ç»ˆäºåˆ°äº†ï¼è¿™é‡Œå°±æ˜¯ä¼ è¯´ä¸­Zackè¢«å›°çš„åœ°æ–¹ï¼

ğŸ¯ æ‹¯æ•‘è¡ŒåŠ¨ï¼šå¥½äº†ï¼Œä¸èƒ½å†æ„Ÿæ…¨äº†ï¼Zackå°±åœ¨è¿™é‡Œç­‰ç€æˆ‘å»æ•‘ï¼Œå†²é¸­ï¼`
            }
        };

        // DOMå…ƒç´ 
        const levelDisplay = document.getElementById('level');
        const maxLevelDisplay = document.getElementById('max-level');
        const unlockedLevelsDisplay = document.getElementById('unlocked-levels');
        const locationDisplay = document.getElementById('location');
        const messageDisplay = document.getElementById('message');
        const loopCountDisplay = document.getElementById('loop-count');
        const gameContainer = document.getElementById('game-container');
        const player = document.getElementById('player');
        const door = document.getElementById('door');
        const nextBtn = document.getElementById('next-btn');
        const restartBtn = document.getElementById('restart-btn');
        const levelSelectBtn = document.getElementById('level-select-btn');
        const soundToggleBtn = document.getElementById('sound-toggle-btn');
        const musicToggleBtn = document.getElementById('music-toggle-btn');
        const resetProgressBtn = document.getElementById('reset-progress-btn');
        const levelSelectModal = document.getElementById('level-select');
        const levelButtonsContainer = document.getElementById('level-buttons');
        const closeSelectBtn = document.getElementById('close-select-btn');

        // æ¸¸æˆå˜é‡
        let gameWidth = 800;
        let gameHeight = 500;
        let loopCount = 3; // åˆå§‹å¾ªç¯æ¬¡æ•°ä¸º3
        let doorRect = door.getBoundingClientRect();
        let basePlayerSpeed = 8;
        let playerSpeed = 8;
        let animationFrame;
        let trapInterval;
        
        // éŸ³æ•ˆç³»ç»Ÿ
        let audioContext;
        let soundEnabled = true;
        
        // èƒŒæ™¯éŸ³ä¹ç³»ç»Ÿ
        let backgroundMusic;
        let musicEnabled = true;
        let musicVolume = 0.1; // èƒŒæ™¯éŸ³ä¹éŸ³é‡ï¼ˆ10%ï¼‰

        // æ˜¾ç¤ºå¯¹è¯æ¡†
        function showDialog(title, content, callback) {
            const overlay = document.createElement('div');
            overlay.className = 'dialog-overlay';
            
            overlay.innerHTML = `
                <div class="dialog-box">
                    <div class="dialog-title">${title}</div>
                    <div class="dialog-content">${content}</div>
                    <button class="dialog-btn">å¼€å§‹å†’é™©ï¼</button>
                </div>
            `;
            
            document.body.appendChild(overlay);
            
            const btn = overlay.querySelector('.dialog-btn');
            btn.addEventListener('click', () => {
                document.body.removeChild(overlay);
                if (callback) callback();
            });
        }

        // æ˜¾ç¤ºZackæ‹¯æ•‘æˆåŠŸå¯¹è¯æ¡†
        function showZackSuccessDialog() {
            const overlay = document.createElement('div');
            overlay.className = 'zack-success-overlay';
            
            overlay.innerHTML = `
                <div class="zack-success-box">
                    <div class="zack-avatar" id="ceo-avatar"></div>
                    <div class="zack-success-title">ğŸ‰ æ‹¯æ•‘æˆåŠŸï¼</div>
                    <div class="zack-success-content">
                        æ­å–œä½ ï¼ç»è¿‡é‡é‡å›°éš¾ï¼Œä½ ç»ˆäºæˆåŠŸæ‹¯æ•‘äº†Zackï¼
                        <br><br>
                        <strong>Zack:</strong> "å¤ªæ„Ÿè°¢ä½ äº†ï¼æˆ‘è¢«å›°åœ¨è¿™ä¸ªå¾ªç¯ä¸­å¥½ä¹…äº†ï¼ä½ å±•ç°å‡ºäº†MTä»·å€¼è§‚ä¸­çš„'è´Ÿè´£'å’Œ'è¿›å–'ç²¾ç¥ï¼"
                        <br><br>
                        <strong>Zack:</strong> "ä»ä»Šå¤©èµ·ï¼Œä½ å°±æ˜¯Magic Tavernçš„æ–°ä»»CEOï¼è®©æˆ‘ä»¬ä¸€èµ·ç§‰æ‰¿'çœŸè¯šã€è¿›å–ã€è´Ÿè´£ã€é½å¿ƒååŠ›'çš„ç†å¿µï¼Œå¸¦é¢†å…¬å¸èµ°å‘æ›´ç¾å¥½çš„æœªæ¥ï¼"
                        <br><br>
                        ğŸ† <strong>æˆå°±è§£é”ï¼š</strong> å¾ªç¯ç»ˆç»“è€… - æˆåŠŸæ‰“ç ´æ—¶é—´å¾ªç¯ï¼Œæ‹¯æ•‘CEOï¼
                        <br>
                        ğŸ‘‘ <strong>æ–°èº«ä»½ï¼š</strong> MTå…¬å¸CEO
                    </div>
                    <button class="zack-success-btn">æ¥å—CEOèŒä½ï¼</button>
                </div>
            `;
            
            document.body.appendChild(overlay);
            
            // æ£€æµ‹CEOå¤´åƒå›¾ç‰‡æ˜¯å¦å­˜åœ¨ï¼Œå¦‚æœä¸å­˜åœ¨åˆ™ä½¿ç”¨emoji
            const ceoAvatar = overlay.querySelector('#ceo-avatar');
            const testImg = new Image();
            testImg.onload = function() {
                // å›¾ç‰‡åŠ è½½æˆåŠŸï¼Œä½¿ç”¨èƒŒæ™¯å›¾ç‰‡
                console.log('CEOå¤´åƒåŠ è½½æˆåŠŸ');
            };
            testImg.onerror = function() {
                // å›¾ç‰‡åŠ è½½å¤±è´¥ï¼Œä½¿ç”¨emojiä½œä¸ºåå¤‡
                console.log('CEOå¤´åƒåŠ è½½å¤±è´¥ï¼Œä½¿ç”¨emojiåå¤‡');
                ceoAvatar.classList.add('fallback');
                ceoAvatar.textContent = 'ğŸ‘¨â€ğŸ’¼';
            };
            testImg.src = 'images/zack.jpeg';
            
            const btn = overlay.querySelector('.zack-success-btn');
            btn.addEventListener('click', () => {
                document.body.removeChild(overlay);
                // æ˜¾ç¤ºCEOå°±èŒä»ªå¼
                showCEOCeremony();
            });
        }

        // æ˜¾ç¤ºCEOå°±èŒä»ªå¼
        function showCEOCeremony() {
            const overlay = document.createElement('div');
            overlay.className = 'ceo-ceremony-overlay';
            
            overlay.innerHTML = `
                <div class="fireworks"></div>
                <div class="mt-logo">MT</div>
                <div class="ceo-title">ğŸ‘‘ æ–°ä»»CEOå°±èŒå…¸ç¤¼</div>
                <div class="ceo-subtitle">
                    æ¬¢è¿åŠ å…¥Magic Taverné¢†å¯¼å›¢é˜Ÿï¼<br>
                    ç§‰æ‰¿"çœŸè¯šã€è¿›å–ã€è´Ÿè´£ã€é½å¿ƒååŠ›"çš„ä»·å€¼è§‚ï¼Œ<br>
                    è®©æˆ‘ä»¬ä¸€èµ·åˆ›é€ æ›´ç¾å¥½çš„æœªæ¥ï¼
                </div>
                <div class="mt-values">
                    <div class="value-item">
                        <span class="value-icon">ğŸ’</span>
                        <div>çœŸè¯š Sincere</div>
                        <div class="value-desc">å®äº‹æ±‚æ˜¯ï¼Œä¸»åŠ¨æ²Ÿé€š</div>
                    </div>
                    <div class="value-item">
                        <span class="value-icon">ğŸš€</span>
                        <div>è¿›å– Progressive</div>
                        <div class="value-desc">æŒç»­å­¦ä¹ ï¼Œç²¾ç›Šæ±‚ç²¾</div>
                    </div>
                    <div class="value-item">
                        <span class="value-icon">ğŸ›¡ï¸</span>
                        <div>è´Ÿè´£ Reliable</div>
                        <div class="value-desc">å…¢å…¢ä¸šä¸šï¼Œå‹‡äºæ‹…å½“</div>
                    </div>
                    <div class="value-item">
                        <span class="value-icon">ğŸ¤</span>
                        <div>é½å¿ƒååŠ› Team-oriented</div>
                        <div class="value-desc">ç›¸äº’ååŠ©ï¼Œå¤§å±€ä¸ºé‡</div>
                    </div>
                </div>
                <button class="continue-btn">å¼€å§‹CEOä¹‹æ—…ï¼</button>
            `;
            
            document.body.appendChild(overlay);
            
            // åˆ›å»ºçƒŸèŠ±æ•ˆæœ
            createFireworks(overlay.querySelector('.fireworks'));
            
            // åˆ›å»ºå½©å¸¦æ•ˆæœ
            createConfetti(overlay);
            
            const btn = overlay.querySelector('.continue-btn');
            btn.addEventListener('click', () => {
                document.body.removeChild(overlay);
                // é‡ç½®æ‰€æœ‰æ¸¸æˆæ•°æ®å’Œç¼“å­˜
                resetAllGameData();
            });
        }

        // é‡ç½®æ‰€æœ‰æ¸¸æˆæ•°æ®å’Œç¼“å­˜
        function resetAllGameData() {
            // æ¸…é™¤æ‰€æœ‰æœ¬åœ°å­˜å‚¨æ•°æ®
            localStorage.removeItem('wizardGame_currentLevel');
            localStorage.removeItem('wizardGame_maxLevel');
            localStorage.removeItem('wizardGame_loopCount');
            localStorage.removeItem('wizardGame_soundEnabled');
            localStorage.removeItem('wizardGame_musicEnabled');
            localStorage.removeItem('wizardGame_musicVolume');
            localStorage.removeItem('wizardGame_playerSpeed');
            localStorage.removeItem('wizardGame_gameStarted');
            
            // é‡ç½®æ¸¸æˆå˜é‡åˆ°åˆå§‹çŠ¶æ€
            gameState.currentLevel = 1;
            gameState.maxUnlockedLevel = 1;
            loopCount = 3;
            playerSpeed = basePlayerSpeed;
            gameStarted = false;
            
            // é‡ç½®ç©å®¶ä½ç½®
            player.style.left = '50px';
            player.style.top = '50px';
            
            // æ¸…ç©ºæ¸¸æˆåŒºåŸŸ
            gameArea.innerHTML = '';
            gameArea.appendChild(player);
            
            // é‡ç½®æ˜¾ç¤º
            messageDisplay.textContent = 'æ¬¢è¿æ¥åˆ°æ‹¯æ•‘Zack - MTå†’é™©ï¼ç‚¹å‡»å¼€å§‹æ¸¸æˆï¼';
            updateProgressDisplay();
            
            // é‡æ–°æ˜¾ç¤ºå¼€å§‹æŒ‰é’®
            const startBtn = document.getElementById('startBtn');
            if (startBtn) {
                startBtn.style.display = 'block';
                startBtn.textContent = 'å¼€å§‹æ¸¸æˆ';
            }
            
            // åœæ­¢èƒŒæ™¯éŸ³ä¹å¹¶é‡ç½®
            if (backgroundMusic) {
                backgroundMusic.pause();
                backgroundMusic.currentTime = 0;
            }
            
            // é‡ç½®éŸ³é¢‘è®¾ç½®
            soundEnabled = true;
            musicEnabled = true;
            musicVolume = 0.1;
            
            // æ›´æ–°æŒ‰é’®çŠ¶æ€
            updateSoundButton();
            updateMusicButton();
            
            // æ˜¾ç¤ºé‡ç½®å®Œæˆä¿¡æ¯
            setTimeout(() => {
                messageDisplay.textContent = 'ğŸ‰ æ­å–œæˆä¸ºMagic Tavern CEOï¼ç§‰æ‰¿MTä»·å€¼è§‚ï¼Œæ¸¸æˆå·²é‡ç½®ï¼Œå‡†å¤‡å¼€å§‹æ–°çš„å†’é™©ï¼';
                setTimeout(() => {
                    messageDisplay.textContent = 'æ¬¢è¿æ¥åˆ°æ‹¯æ•‘Zack - MTå†’é™©ï¼ç‚¹å‡»å¼€å§‹æ¸¸æˆï¼';
                }, 3000);
            }, 500);
        }

        // åˆ›å»ºçƒŸèŠ±æ•ˆæœ
        function createFireworks(container) {
            const colors = ['#FFD700', '#FF6B35', '#FF1744', '#00E676', '#2196F3', '#9C27B0'];
            
            for (let i = 0; i < 20; i++) {
                setTimeout(() => {
                    const firework = document.createElement('div');
                    firework.className = 'firework';
                    firework.style.left = Math.random() * 100 + '%';
                    firework.style.top = Math.random() * 100 + '%';
                    firework.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                    firework.style.animationDelay = Math.random() * 2 + 's';
                    container.appendChild(firework);
                    
                    // ç§»é™¤çƒŸèŠ±å…ƒç´ 
                    setTimeout(() => {
                        if (firework.parentNode) {
                            firework.parentNode.removeChild(firework);
                        }
                    }, 2000);
                }, i * 200);
            }
        }

        // åˆ›å»ºå½©å¸¦æ•ˆæœ
        function createConfetti(container) {
            const colors = ['#FFD700', '#FF6B35', '#FF1744', '#00E676', '#2196F3', '#9C27B0'];
            
            for (let i = 0; i < 50; i++) {
                setTimeout(() => {
                    const confetti = document.createElement('div');
                    confetti.className = 'confetti';
                    confetti.style.left = Math.random() * 100 + '%';
                    confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                    confetti.style.animationDelay = Math.random() * 3 + 's';
                    confetti.style.animationDuration = (2 + Math.random() * 2) + 's';
                    container.appendChild(confetti);
                    
                    // ç§»é™¤å½©å¸¦å…ƒç´ 
                    setTimeout(() => {
                        if (confetti.parentNode) {
                            confetti.parentNode.removeChild(confetti);
                        }
                    }, 5000);
                }, i * 100);
            }
        }

        // åˆå§‹åŒ–éŸ³é¢‘ä¸Šä¸‹æ–‡
        function initAudio() {
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                // ä»æœ¬åœ°å­˜å‚¨åŠ è½½éŸ³æ•ˆè®¾ç½®
                const savedSoundSetting = localStorage.getItem('wizardGame_soundEnabled');
                if (savedSoundSetting !== null) {
                    soundEnabled = savedSoundSetting === 'true';
                }
                updateSoundButton();
                
                // åˆå§‹åŒ–èƒŒæ™¯éŸ³ä¹
                initBackgroundMusic();
            } catch (e) {
                console.log('éŸ³é¢‘ä¸æ”¯æŒ:', e);
                soundEnabled = false;
                updateSoundButton();
            }
        }

        // åˆå§‹åŒ–èƒŒæ™¯éŸ³ä¹
        function initBackgroundMusic() {
            try {
                // å°è¯•å¤šç§å¯èƒ½çš„æ–‡ä»¶å
                const possiblePaths = [
                    'background_music.wav',
                    'backgroud_music.wav', // ç”¨æˆ·æåˆ°çš„åŸå§‹åç§°ï¼ˆå¯èƒ½æœ‰æ‹¼å†™é”™è¯¯ï¼‰
                    './background_music.wav',
                    './backgroud_music.wav'
                ];
                
                backgroundMusic = new Audio();
                backgroundMusic.loop = true; // å¾ªç¯æ’­æ”¾
                backgroundMusic.volume = musicVolume;
                
                // ä»æœ¬åœ°å­˜å‚¨åŠ è½½éŸ³ä¹è®¾ç½®
                const savedMusicSetting = localStorage.getItem('wizardGame_musicEnabled');
                const savedMusicVolume = localStorage.getItem('wizardGame_musicVolume');
                
                if (savedMusicSetting !== null) {
                    musicEnabled = savedMusicSetting === 'true';
                }
                // å›ºå®šéŸ³é‡ä¸º10%ï¼Œä¸ä»æœ¬åœ°å­˜å‚¨è¯»å–
                musicVolume = 0.1;
                backgroundMusic.volume = musicVolume;
                
                // æ·»åŠ éŸ³é¢‘äº‹ä»¶ç›‘å¬å™¨
                backgroundMusic.addEventListener('loadstart', () => {
                    console.log('å¼€å§‹åŠ è½½èƒŒæ™¯éŸ³ä¹...');
                });
                
                backgroundMusic.addEventListener('canplaythrough', () => {
                    console.log('èƒŒæ™¯éŸ³ä¹åŠ è½½å®Œæˆï¼Œå¯ä»¥æ’­æ”¾');
                    updateMusicButton();
                    if (musicEnabled && !firstInteraction) {
                        playBackgroundMusic();
                    }
                });
                
                backgroundMusic.addEventListener('error', (e) => {
                    console.log('èƒŒæ™¯éŸ³ä¹åŠ è½½å¤±è´¥:', e);
                    console.log('å½“å‰å°è¯•çš„æ–‡ä»¶è·¯å¾„:', backgroundMusic.src);
                    // å°è¯•ä¸‹ä¸€ä¸ªæ–‡ä»¶è·¯å¾„
                    tryNextMusicPath();
                });
                
                backgroundMusic.addEventListener('play', () => {
                    console.log('èƒŒæ™¯éŸ³ä¹å¼€å§‹æ’­æ”¾');
                });
                
                backgroundMusic.addEventListener('pause', () => {
                    console.log('èƒŒæ™¯éŸ³ä¹æš‚åœ');
                });
                
                // å¼€å§‹å°è¯•åŠ è½½ç¬¬ä¸€ä¸ªè·¯å¾„
                let currentPathIndex = 0;
                
                function tryNextMusicPath() {
                    if (currentPathIndex < possiblePaths.length) {
                        const path = possiblePaths[currentPathIndex];
                        console.log('å°è¯•åŠ è½½éŸ³ä¹æ–‡ä»¶:', path);
                        backgroundMusic.src = path;
                        backgroundMusic.load();
                        currentPathIndex++;
                    } else {
                        console.log('æ‰€æœ‰éŸ³ä¹æ–‡ä»¶è·¯å¾„éƒ½å°è¯•å¤±è´¥');
                        musicEnabled = false;
                        updateMusicButton();

                    }
                }
                
                // å¼€å§‹å°è¯•ç¬¬ä¸€ä¸ªè·¯å¾„
                tryNextMusicPath();
                
                updateMusicButton();
                
            } catch (e) {
                console.log('èƒŒæ™¯éŸ³ä¹åˆå§‹åŒ–å¤±è´¥:', e);
                musicEnabled = false;
                updateMusicButton();
            }
        }

        // æ’­æ”¾èƒŒæ™¯éŸ³ä¹
        function playBackgroundMusic() {
            if (backgroundMusic && musicEnabled) {
                console.log('å°è¯•æ’­æ”¾èƒŒæ™¯éŸ³ä¹, éŸ³é‡:', backgroundMusic.volume);
                console.log('éŸ³ä¹æ–‡ä»¶çŠ¶æ€:', {
                    src: backgroundMusic.src,
                    readyState: backgroundMusic.readyState,
                    paused: backgroundMusic.paused,
                    currentTime: backgroundMusic.currentTime,
                    duration: backgroundMusic.duration
                });
                
                backgroundMusic.play().then(() => {
                    console.log('èƒŒæ™¯éŸ³ä¹æ’­æ”¾æˆåŠŸ');
                }).catch(e => {
                    console.log('èƒŒæ™¯éŸ³ä¹æ’­æ”¾å¤±è´¥:', e);
                    if (e.name === 'NotAllowedError') {
                        console.log('æµè§ˆå™¨é˜»æ­¢äº†è‡ªåŠ¨æ’­æ”¾ï¼Œéœ€è¦ç”¨æˆ·äº¤äº’');

                    }
                });
            } else {
                console.log('æ’­æ”¾æ¡ä»¶ä¸æ»¡è¶³:', {
                    hasBackgroundMusic: !!backgroundMusic,
                    musicEnabled: musicEnabled
                });
            }
        }

        // æš‚åœèƒŒæ™¯éŸ³ä¹
        function pauseBackgroundMusic() {
            if (backgroundMusic) {
                backgroundMusic.pause();
            }
        }

        // åˆ‡æ¢èƒŒæ™¯éŸ³ä¹å¼€å…³
        function toggleMusic() {
            musicEnabled = !musicEnabled;
            localStorage.setItem('wizardGame_musicEnabled', musicEnabled);
            
            if (musicEnabled) {
                console.log('ç”¨æˆ·æ‰‹åŠ¨å¯ç”¨èƒŒæ™¯éŸ³ä¹');
                playBackgroundMusic();
            } else {
                console.log('ç”¨æˆ·æ‰‹åŠ¨ç¦ç”¨èƒŒæ™¯éŸ³ä¹');
                pauseBackgroundMusic();
            }
            
            updateMusicButton();
        }



        // åˆ‡æ¢éŸ³æ•ˆå¼€å…³
        function toggleSound() {
            soundEnabled = !soundEnabled;
            localStorage.setItem('wizardGame_soundEnabled', soundEnabled);
            updateSoundButton();
            
            // æ’­æ”¾æµ‹è¯•éŸ³æ•ˆ
            if (soundEnabled) {
                playClickSound();
            }
        }

        // æ›´æ–°éŸ³æ•ˆæŒ‰é’®æ˜¾ç¤º
        function updateSoundButton() {
            if (soundToggleBtn) {
                soundToggleBtn.textContent = soundEnabled ? 'ğŸ”Š éŸ³æ•ˆ' : 'ğŸ”‡ éŸ³æ•ˆ';
                soundToggleBtn.style.opacity = soundEnabled ? '1' : '0.6';
            }
        }

        // æ›´æ–°èƒŒæ™¯éŸ³ä¹æŒ‰é’®æ˜¾ç¤º
        function updateMusicButton() {
            if (musicToggleBtn) {
                musicToggleBtn.textContent = musicEnabled ? 'ğŸµ éŸ³ä¹' : 'ğŸ”‡ éŸ³ä¹';
                musicToggleBtn.style.opacity = musicEnabled ? '1' : '0.6';
            }
        }



        // ç”Ÿæˆçˆ†ç‚¸éŸ³æ•ˆ
        function playExplosionSound() {
            if (!soundEnabled || !audioContext) return;
            
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            // çˆ†ç‚¸éŸ³æ•ˆï¼šä½é¢‘å™ªéŸ³
            oscillator.type = 'sawtooth';
            oscillator.frequency.setValueAtTime(150, audioContext.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(50, audioContext.currentTime + 0.5);
            
            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
            
            oscillator.start();
            oscillator.stop(audioContext.currentTime + 0.5);
        }

        // ç”Ÿæˆè¿‡å…³éŸ³æ•ˆ
        function playSuccessSound() {
            if (!soundEnabled || !audioContext) return;
            
            // æ’­æ”¾ä¸€ç³»åˆ—ä¸Šå‡çš„éŸ³ç¬¦
            const notes = [523.25, 659.25, 783.99, 1046.50]; // C5, E5, G5, C6
            
            notes.forEach((frequency, index) => {
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime + index * 0.15);
                
                gainNode.gain.setValueAtTime(0, audioContext.currentTime + index * 0.15);
                gainNode.gain.linearRampToValueAtTime(0.2, audioContext.currentTime + index * 0.15 + 0.05);
                gainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + index * 0.15 + 0.3);
                
                oscillator.start(audioContext.currentTime + index * 0.15);
                oscillator.stop(audioContext.currentTime + index * 0.15 + 0.3);
            });
        }

        // ç”ŸæˆæŒ‰é”®éŸ³æ•ˆ
        function playClickSound() {
            if (!soundEnabled || !audioContext) return;
            
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.type = 'square';
            oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(600, audioContext.currentTime + 0.1);
            
            gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
            
            oscillator.start();
            oscillator.stop(audioContext.currentTime + 0.1);
        }
        
        // é”®ç›˜çŠ¶æ€è¿½è¸ª
        const keys = {
            ArrowUp: false,
            ArrowDown: false,
            ArrowLeft: false,
            ArrowRight: false
        };

        // æ›´æ–°è¿›åº¦æ˜¾ç¤º
        function updateProgressDisplay() {
            maxLevelDisplay.textContent = gameState.maxUnlockedLevel;
            unlockedLevelsDisplay.textContent = gameState.maxUnlockedLevel;
            loopCountDisplay.textContent = loopCount;
        }

        // åˆ›å»ºå…³å¡é€‰æ‹©æŒ‰é’®
        function createLevelButtons() {
            levelButtonsContainer.innerHTML = '';
            
            for (let i = 1; i <= gameState.maxLevel; i++) {
                const btn = document.createElement('button');
                btn.textContent = i;
                btn.className = 'level-btn';
                
                if (i <= gameState.maxUnlockedLevel) {
                    if (i === gameState.currentLevel) {
                        btn.className += ' current';
                    } else {
                        btn.className += ' unlocked';
                    }
                    btn.onclick = () => selectLevel(i);
                } else {
                    btn.className += ' locked';
                    btn.disabled = true;
                }
                
                levelButtonsContainer.appendChild(btn);
            }
        }

        // é€‰æ‹©å…³å¡
        function selectLevel(level) {
            if (level <= gameState.maxUnlockedLevel) {
                playClickSound();
                gameState.currentLevel = level;
                saveProgress();
                levelSelectModal.classList.add('hidden');
                startLevel();
            }
        }

        // å¼€å§‹å…³å¡
        function startLevel() {
            gameState.gameOver = false;
            gameState.player = { x: 50, y: 250 };
            gameState.traps = [];
            gameState.movingTraps = [];
            
            messageDisplay.textContent = '';
            nextBtn.classList.add('hidden');
            
            // æ¸…é™¤ä¹‹å‰çš„é™·é˜±
            document.querySelectorAll('.trap, .spike, .moving-trap').forEach(el => el.remove());
            
            updatePlayerPosition();
            setupLevel();
            updateProgressDisplay();
        }

        // åˆå§‹åŒ–æ¸¸æˆ
        function initGame() {
            // åˆå§‹åŒ–éŸ³é¢‘ç³»ç»Ÿ
            initAudio();
            
            // åŠ è½½ä¿å­˜çš„è¿›åº¦
            loadProgress();
            
            gameState.gameOver = false;
            gameState.player = { x: 50, y: 250 };
            gameState.traps = [];
            gameState.movingTraps = [];
            
            messageDisplay.textContent = '';
            nextBtn.classList.add('hidden');
            
            // ç¡®ä¿å…³å¡é€‰æ‹©å™¨æ˜¯éšè—çš„
            levelSelectModal.classList.add('hidden');
            
            updatePlayerPosition();
            setupLevel();
            updateProgressDisplay();
            
            // æ¸…é™¤ä¹‹å‰çš„é™·é˜±
            document.querySelectorAll('.trap, .spike, .moving-trap').forEach(el => el.remove());
        }

        // è®¾ç½®å½“å‰å…³å¡
        function setupLevel() {
            levelDisplay.textContent = gameState.currentLevel;
            
            // æ›´æ–°ä½ç½®æ˜¾ç¤º
            locationDisplay.textContent = levelLocations[gameState.currentLevel] || "æœªçŸ¥åŒºåŸŸ";
            
            // æ ¹æ®å…³å¡è°ƒæ•´ç©å®¶ç§»åŠ¨é€Ÿåº¦ï¼ˆé«˜å…³å¡ç¨å¾®å¿«ä¸€ç‚¹ä»¥åº”å¯¹æ›´å¤šé™·é˜±ï¼‰
            playerSpeed = basePlayerSpeed + Math.floor(gameState.currentLevel / 3); // æ¯3å…³å¢åŠ 1ç‚¹é€Ÿåº¦
            
            // æ ¹æ®å…³å¡è®¾ç½®é™·é˜±ï¼ˆç”Ÿæˆæ–°å¸ƒå±€ï¼‰
            createTraps(false);
            
            // è®¾ç½®ç§»åŠ¨é™·é˜±ï¼ˆç”Ÿæˆæ–°å¸ƒå±€ï¼‰
            setupMovingTraps(false);
            
            // æ˜¾ç¤ºå½“å‰å…³å¡çš„å¯¹è¯æ¡†
            const currentDialog = levelDialogs[gameState.currentLevel];
            if (currentDialog) {
                const content = typeof currentDialog.content === 'function' 
                    ? currentDialog.content() 
                    : currentDialog.content;
                showDialog(currentDialog.title, content);
            }
        }

        // ç”Ÿæˆå…³å¡å¸ƒå±€ç§å­
        function generateLevelSeed(level) {
            return level * 12345; // ä½¿ç”¨å…³å¡æ•°ç”Ÿæˆå›ºå®šç§å­
        }
        
        // åŸºäºç§å­çš„éšæœºæ•°ç”Ÿæˆå™¨
        function seededRandom(seed) {
            const x = Math.sin(seed) * 10000;
            return x - Math.floor(x);
        }

        // åˆ›å»ºç‰¹æ®Šé™·é˜±
        function createSpecialTrap(trap, seed, seedCounter, sizeMultiplier) {
            const specialTypes = ['invisible', 'teleport', 'hunter', 'blink', 'gravity', 'split', 'mirror', 'freeze', 'bounce', 'shrink', 'speed', 'clone'];
            const typeIndex = Math.floor(seededRandom(seed + seedCounter++) * specialTypes.length);
            const trapType = specialTypes[typeIndex];
            
            const baseSize = 40;
            const width = baseSize * sizeMultiplier;
            const height = baseSize * sizeMultiplier;
            const left = 100 + seededRandom(seed + seedCounter++) * (gameWidth - 200 - width);
            const bottom = seededRandom(seed + seedCounter++) * (gameHeight - height - 50);
            
            switch(trapType) {
                case 'invisible':
                    trap.className = 'invisible-trap';
                    trap.dataset.trapType = 'invisible';
                    trap.dataset.revealed = 'false';
                    break;
                case 'teleport':
                    trap.className = 'teleport-trap';
                    trap.dataset.trapType = 'teleport';
                    break;
                case 'hunter':
                    trap.className = 'hunter-trap';
                    trap.dataset.trapType = 'hunter';
                    trap.dataset.huntSpeed = '2';
                    break;
                case 'blink':
                    trap.className = 'blink-trap';
                    trap.dataset.trapType = 'blink';
                    trap.dataset.visible = 'true';
                    break;
                case 'gravity':
                    trap.className = 'gravity-trap';
                    trap.dataset.trapType = 'gravity';
                    trap.dataset.pullForce = '3';
                    break;
                case 'split':
                    trap.className = 'split-trap';
                    trap.dataset.trapType = 'split';
                    trap.dataset.hasTriggered = 'false';
                    break;
                case 'mirror':
                    trap.className = 'mirror-trap';
                    trap.dataset.trapType = 'mirror';
                    break;
                case 'freeze':
                    trap.className = 'freeze-trap';
                    trap.dataset.trapType = 'freeze';
                    break;
                case 'bounce':
                    trap.className = 'bounce-trap';
                    trap.dataset.trapType = 'bounce';
                    break;
                case 'shrink':
                    trap.className = 'shrink-trap';
                    trap.dataset.trapType = 'shrink';
                    break;
                case 'speed':
                    trap.className = 'speed-trap';
                    trap.dataset.trapType = 'speed';
                    break;
                case 'clone':
                    trap.className = 'clone-trap';
                    trap.dataset.trapType = 'clone';
                    trap.dataset.hasTriggered = 'false';
                    break;
            }
            
            trap.style.width = width + 'px';
            trap.style.height = height + 'px';
            trap.style.left = left + 'px';
            trap.style.bottom = bottom + 'px';
            
            // ä¿å­˜ç‰¹æ®Šé™·é˜±ä¿¡æ¯
            gameState.levelLayouts[gameState.currentLevel].staticTraps.push({
                className: trap.className,
                trapType: trapType,
                width: width,
                height: height,
                left: left,
                bottom: bottom,
                data: {...trap.dataset}
            });
            
            return seedCounter;
        }
        
        // åˆ›å»ºé™æ€é™·é˜±
        function createTraps(useExistingLayout = false) {
            // ç¬¬ä¸€å…³æ²¡æœ‰ä»»ä½•é™·é˜±
            if (gameState.currentLevel === 1) {
                return;
            }
            
            // å¦‚æœè¦é‡ç”¨ç°æœ‰å¸ƒå±€
            if (useExistingLayout && gameState.levelLayouts[gameState.currentLevel]) {
                const layout = gameState.levelLayouts[gameState.currentLevel];
                
                // é‡å»ºé™æ€é™·é˜±
                for (const trapData of layout.staticTraps) {
                    const trap = document.createElement('div');
                    trap.className = trapData.className;
                    
                    if (trapData.trapType) {
                        // é‡å»ºç‰¹æ®Šé™·é˜±
                        trap.dataset.trapType = trapData.trapType;
                        if (trapData.data) {
                            Object.assign(trap.dataset, trapData.data);
                        }
                        trap.style.width = trapData.width + 'px';
                        trap.style.height = trapData.height + 'px';
                        trap.style.left = trapData.left + 'px';
                        trap.style.bottom = trapData.bottom + 'px';
                    } else if (trapData.className === 'trap') {
                        trap.style.width = trapData.width + 'px';
                        trap.style.height = trapData.height + 'px';
                        trap.style.left = trapData.left + 'px';
                        trap.style.bottom = trapData.bottom + 'px';
                    } else {
                        trap.style.left = trapData.left + 'px';
                    }
                    
                    gameContainer.appendChild(trap);
                    gameState.traps.push(trap);
                }
                return;
            }
            
            // ç”Ÿæˆæ–°çš„å¸ƒå±€
            const seed = generateLevelSeed(gameState.currentLevel);
            let seedCounter = 0;
            
            // ä¼˜åŒ–çš„å…³å¡éš¾åº¦æ›²çº¿ - æ¸è¿›å¼æŒ‘æˆ˜
            let trapCount;
            if (gameState.currentLevel === 1) {
                trapCount = 0; // ç¬¬1å…³ï¼šæ–°æ‰‹å‹å¥½ï¼Œæ— é™·é˜±
            } else if (gameState.currentLevel <= 3) {
                trapCount = (gameState.currentLevel - 1) * 3; // ç¬¬2-3å…³ï¼š3,6ä¸ªé™·é˜±
            } else if (gameState.currentLevel <= 6) {
                trapCount = 6 + (gameState.currentLevel - 3) * 4; // ç¬¬4-6å…³ï¼š10,14,18ä¸ªé™·é˜±
            } else if (gameState.currentLevel <= 8) {
                trapCount = 18 + (gameState.currentLevel - 6) * 5; // ç¬¬7-8å…³ï¼š23,28ä¸ªé™·é˜±
            } else {
                trapCount = 28 + (gameState.currentLevel - 8) * 6; // ç¬¬9-10å…³ï¼š34,40ä¸ªé™·é˜±
            }
            
            // åˆå§‹åŒ–å…³å¡å¸ƒå±€å­˜å‚¨
            if (!gameState.levelLayouts[gameState.currentLevel]) {
                gameState.levelLayouts[gameState.currentLevel] = {
                    staticTraps: [],
                    movingTraps: []
                };
            }
            
            for (let i = 0; i < trapCount; i++) {
                const trap = document.createElement('div');
                
                // é‡æ–°è°ƒæ•´é™·é˜±ç±»å‹æ¯”ä¾‹ï¼Œè®©æ¸¸æˆæ›´æœ‰è¶£ (é€‚é…10å…³)
                const specialChance = Math.min(0.1 + gameState.currentLevel * 0.05, 0.6); // ç‰¹æ®Šé™·é˜±æ¯”ä¾‹å¿«é€Ÿæå‡
                const spikeChance = Math.min(0.2 + gameState.currentLevel * 0.05, 0.6); // å°–åˆºæ¯”ä¾‹
                const trapChance = 0.3; // æ–¹å—é™·é˜±æ¯”ä¾‹
                const randomValue = seededRandom(seed + seedCounter++);
                
                // é«˜å…³å¡çš„é™·é˜±æ›´å¤§
                const sizeMultiplier = 1 + gameState.currentLevel * 0.02; // æ›´å¿«å¢é•¿
                
                if (randomValue < specialChance && gameState.currentLevel >= 2) {
                    // åˆ›å»ºç‰¹æ®Šé™·é˜±ï¼ˆä»ç¬¬2å…³å¼€å§‹ï¼Œæ›´æ—©å‡ºç°ï¼‰
                    seedCounter = createSpecialTrap(trap, seed, seedCounter, sizeMultiplier);
                } else if (randomValue < specialChance + spikeChance) {
                    // å°–åˆºé™·é˜±ï¼ˆä¼˜å…ˆçº§æé«˜ï¼‰
                    trap.className = 'spike';
                    const left = 100 + seededRandom(seed + seedCounter++) * (gameWidth - 200 - 30);
                    trap.style.left = left + 'px';
                    
                    // ä¿å­˜å¸ƒå±€ä¿¡æ¯
                    gameState.levelLayouts[gameState.currentLevel].staticTraps.push({
                        className: 'spike',
                        left: left
                    });
                } else if (randomValue < specialChance + spikeChance + trapChance) {
                    // çŸ©å½¢é™·é˜±
                    trap.className = 'trap';
                    const width = (30 + seededRandom(seed + seedCounter++) * 70) * sizeMultiplier;
                    const height = (20 + seededRandom(seed + seedCounter++) * 50) * sizeMultiplier;
                    const finalWidth = Math.min(width, 120);
                    const finalHeight = Math.min(height, 80);
                    const left = 100 + seededRandom(seed + seedCounter++) * (gameWidth - 200 - finalWidth);
                    const bottom = seededRandom(seed + seedCounter++) * (gameHeight - finalHeight - 50);
                    
                    trap.style.width = finalWidth + 'px';
                    trap.style.height = finalHeight + 'px';
                    trap.style.left = left + 'px';
                    trap.style.bottom = bottom + 'px';
                    
                    // ä¿å­˜å¸ƒå±€ä¿¡æ¯
                    gameState.levelLayouts[gameState.currentLevel].staticTraps.push({
                        className: 'trap',
                        width: finalWidth,
                        height: finalHeight,
                        left: left,
                        bottom: bottom
                    });
                } else {
                    // å¦‚æœéƒ½ä¸æ»¡è¶³ï¼Œåˆ›å»ºä¸€ä¸ªå°–åˆºé™·é˜±ä½œä¸ºé»˜è®¤
                    trap.className = 'spike';
                    const left = 100 + seededRandom(seed + seedCounter++) * (gameWidth - 200 - 30);
                    trap.style.left = left + 'px';
                    
                    // ä¿å­˜å¸ƒå±€ä¿¡æ¯
                    gameState.levelLayouts[gameState.currentLevel].staticTraps.push({
                        className: 'spike',
                        left: left
                    });
                }
                
                gameContainer.appendChild(trap);
                gameState.traps.push(trap);
            }
        }

        // è®¾ç½®ç§»åŠ¨é™·é˜±
        function setupMovingTraps(useExistingLayout = false) {
            // ç¬¬1-3å…³æ²¡æœ‰ç§»åŠ¨é™·é˜±
            if (gameState.currentLevel <= 3) {
                return;
            }
            
            // å¦‚æœè¦é‡ç”¨ç°æœ‰å¸ƒå±€
            if (useExistingLayout && gameState.levelLayouts[gameState.currentLevel]) {
                const layout = gameState.levelLayouts[gameState.currentLevel];
                
                // é‡å»ºç§»åŠ¨é™·é˜±
                for (const trapData of layout.movingTraps) {
                    const movingTrap = document.createElement('div');
                    movingTrap.className = 'moving-trap';
                    
                    movingTrap.style.left = trapData.startX + 'px';
                    movingTrap.style.top = trapData.startY + 'px';
                    
                    gameContainer.appendChild(movingTrap);
                    gameState.movingTraps.push({
                        element: movingTrap,
                        x: trapData.startX,
                        y: trapData.startY,
                        speedX: trapData.speedX,
                        speedY: trapData.speedY
                    });
                }
                
                // å¼€å§‹ç§»åŠ¨é™·é˜±
                if (trapInterval) clearInterval(trapInterval);
                const updateInterval = Math.max(15, 35 - gameState.currentLevel * 0.2);
                trapInterval = setInterval(moveTraps, updateInterval);
                return;
            }
            
            // ç”Ÿæˆæ–°çš„ç§»åŠ¨é™·é˜±å¸ƒå±€
            const seed = generateLevelSeed(gameState.currentLevel);
            let seedCounter = 1000; // ä½¿ç”¨ä¸åŒçš„èµ·å§‹å€¼é¿å…ä¸é™æ€é™·é˜±å†²çª
            
            // ä¼˜åŒ–çš„ç§»åŠ¨é™·é˜±éš¾åº¦æ›²çº¿
            let movingTrapCount;
            if (gameState.currentLevel <= 3) {
                movingTrapCount = 0; // ç¬¬1-3å…³ï¼šæ— ç§»åŠ¨é™·é˜±ï¼Œä¸“æ³¨å­¦ä¹ åŸºç¡€
            } else if (gameState.currentLevel <= 5) {
                movingTrapCount = gameState.currentLevel - 3; // ç¬¬4-5å…³ï¼š1,2ä¸ªç§»åŠ¨é™·é˜±
            } else if (gameState.currentLevel <= 7) {
                movingTrapCount = 2 + (gameState.currentLevel - 5); // ç¬¬6-7å…³ï¼š3,4ä¸ªç§»åŠ¨é™·é˜±
            } else if (gameState.currentLevel <= 9) {
                movingTrapCount = 4 + (gameState.currentLevel - 7) * 2; // ç¬¬8-9å…³ï¼š6,8ä¸ªç§»åŠ¨é™·é˜±
            } else {
                movingTrapCount = 8 + (gameState.currentLevel - 9) * 3; // ç¬¬10å…³ï¼š11ä¸ªç§»åŠ¨é™·é˜±
            }
            
            for (let i = 0; i < movingTrapCount; i++) {
                const movingTrap = document.createElement('div');
                movingTrap.className = 'moving-trap';
                
                // ä½¿ç”¨ç§å­ç”Ÿæˆå›ºå®šçš„åˆå§‹ä½ç½®å’Œç§»åŠ¨æ–¹å‘
                const startX = 100 + seededRandom(seed + seedCounter++) * (gameWidth - 200);
                const startY = 50 + seededRandom(seed + seedCounter++) * (gameHeight - 100);
                
                // æ ¹æ®å…³å¡è°ƒæ•´ç§»åŠ¨é€Ÿåº¦
                const baseSpeed = 2 + gameState.currentLevel * 0.05; // é€Ÿåº¦éšå…³å¡å¢åŠ 
                const maxSpeed = Math.min(baseSpeed, 8); // é™åˆ¶æœ€å¤§é€Ÿåº¦
                const speedX = (seededRandom(seed + seedCounter++) - 0.5) * maxSpeed;
                const speedY = (seededRandom(seed + seedCounter++) - 0.5) * maxSpeed;
                
                movingTrap.style.left = startX + 'px';
                movingTrap.style.top = startY + 'px';
                
                gameContainer.appendChild(movingTrap);
                gameState.movingTraps.push({
                    element: movingTrap,
                    x: startX,
                    y: startY,
                    speedX: speedX,
                    speedY: speedY
                });
                
                // ä¿å­˜ç§»åŠ¨é™·é˜±å¸ƒå±€ä¿¡æ¯
                gameState.levelLayouts[gameState.currentLevel].movingTraps.push({
                    startX: startX,
                    startY: startY,
                    speedX: speedX,
                    speedY: speedY
                });
            }
            
            // å¼€å§‹ç§»åŠ¨é™·é˜±ï¼Œé«˜å…³å¡æ›´æ–°é¢‘ç‡æ›´é«˜
            if (trapInterval) clearInterval(trapInterval);
            const updateInterval = Math.max(15, 35 - gameState.currentLevel * 0.2); // æ›´æ–°é—´éš”éšå…³å¡å‡å°‘
            trapInterval = setInterval(moveTraps, updateInterval);
        }

        // ç§»åŠ¨é™·é˜±
        function moveTraps() {
            gameState.movingTraps.forEach(trap => {
                trap.x += trap.speedX;
                trap.y += trap.speedY;
                
                // è¾¹ç•Œæ£€æµ‹
                if (trap.x <= 0 || trap.x >= gameWidth - 40) {
                    trap.speedX *= -1;
                }
                if (trap.y <= 0 || trap.y >= gameHeight - 40) {
                    trap.speedY *= -1;
                }
                
                trap.element.style.left = trap.x + 'px';
                trap.element.style.top = trap.y + 'px';
            });
        }

        // æ›´æ–°ç©å®¶ä½ç½®
        function updatePlayerPosition() {
            player.style.left = gameState.player.x + 'px';
            player.style.top = gameState.player.y + 'px';
        }

        // å¤„ç†ç‰¹æ®Šé™·é˜±
        function handleSpecialTrap(trap) {
            const trapType = trap.dataset.trapType;
            
            switch(trapType) {
                case 'teleport':
                    // ä¼ é€é™·é˜±ï¼šéšæœºä¼ é€ç©å®¶
                    playClickSound(); // ä¼ é€éŸ³æ•ˆ
                    gameState.player.x = 50 + Math.random() * (gameWidth - 150);
                    gameState.player.y = 50 + Math.random() * (gameHeight - 100);
                    updatePlayerPosition();
                    messageDisplay.textContent = 'ğŸ’« ä¼ é€äº†ï¼';
                    setTimeout(() => {
                        if (messageDisplay.textContent.includes('ä¼ é€äº†')) {
                            messageDisplay.textContent = '';
                        }
                    }, 1500);
                    break;
                    
                case 'freeze':
                    // å†°å†»é™·é˜±ï¼šå†»ç»“ç©å®¶3ç§’
                    gameState.playerFrozen = true;
                    gameState.freezeEndTime = Date.now() + 3000;
                    player.style.filter = 'hue-rotate(240deg) brightness(0.7)';
                    messageDisplay.textContent = 'ğŸ§Š è¢«å†°å†»äº†ï¼';
                    setTimeout(() => {
                        gameState.playerFrozen = false;
                        player.style.filter = '';
                        if (messageDisplay.textContent.includes('è¢«å†°å†»äº†')) {
                            messageDisplay.textContent = '';
                        }
                    }, 3000);
                    break;
                    
                case 'split':
                    // åˆ†è£‚é™·é˜±ï¼šåˆ†è£‚æˆ4ä¸ªå°é™·é˜±
                    if (trap.dataset.hasTriggered === 'false') {
                        trap.dataset.hasTriggered = 'true';
                        createSplitTraps(trap);
                        trap.remove();
                        gameState.traps = gameState.traps.filter(t => t !== trap);
                    }
                    break;
                    
                case 'gravity':
                    // é‡åŠ›é™·é˜±ï¼šæŠŠç©å®¶æ‹‰å‘ä¸­å¿ƒç„¶åçˆ†ç‚¸
                    const trapRect = trap.getBoundingClientRect();
                    const centerX = trapRect.left + trapRect.width / 2 - gameContainer.getBoundingClientRect().left;
                    const centerY = trapRect.top + trapRect.height / 2 - gameContainer.getBoundingClientRect().top;
                    gameState.player.x = centerX - 20;
                    gameState.player.y = centerY - 25;
                    updatePlayerPosition();
                    setTimeout(() => gameOver(), 500);
                    break;
                    
                case 'bounce':
                    // å¼¹è·³é™·é˜±ï¼šæŠŠç©å®¶å¼¹åˆ°éšæœºæ–¹å‘
                    playClickSound();
                    const bounceForce = 100;
                    const angle = Math.random() * 2 * Math.PI;
                    gameState.player.x += Math.cos(angle) * bounceForce;
                    gameState.player.y += Math.sin(angle) * bounceForce;
                    
                    // ç¡®ä¿ç©å®¶ä¸ä¼šè¢«å¼¹å‡ºè¾¹ç•Œ
                    gameState.player.x = Math.max(0, Math.min(gameWidth - 40, gameState.player.x));
                    gameState.player.y = Math.max(0, Math.min(gameHeight - 50, gameState.player.y));
                    updatePlayerPosition();
                    
                    messageDisplay.textContent = 'ğŸ€ è¢«å¼¹é£äº†ï¼';
                    setTimeout(() => {
                        if (messageDisplay.textContent.includes('è¢«å¼¹é£äº†')) {
                            messageDisplay.textContent = '';
                        }
                    }, 1500);
                    break;
                    
                case 'shrink':
                    // ç¼©å°é™·é˜±ï¼šè®©ç©å®¶å˜å°5ç§’
                    player.style.transform = 'scale(0.5)';
                    messageDisplay.textContent = 'ğŸ” å˜å°äº†ï¼';
                    setTimeout(() => {
                        player.style.transform = '';
                        if (messageDisplay.textContent.includes('å˜å°äº†')) {
                            messageDisplay.textContent = '';
                        }
                    }, 5000);
                    break;
                    
                case 'speed':
                    // åŠ é€Ÿé™·é˜±ï¼šè®©ç©å®¶ç§»åŠ¨é€Ÿåº¦ç¿»å€5ç§’
                    const originalSpeed = playerSpeed;
                    playerSpeed *= 2;
                    player.style.filter = 'hue-rotate(120deg) brightness(1.2)';
                    messageDisplay.textContent = 'âš¡ åŠ é€Ÿäº†ï¼';
                    setTimeout(() => {
                        playerSpeed = originalSpeed;
                        player.style.filter = '';
                        if (messageDisplay.textContent.includes('åŠ é€Ÿäº†')) {
                            messageDisplay.textContent = '';
                        }
                    }, 5000);
                    break;
                    
                case 'clone':
                    // å…‹éš†é™·é˜±ï¼šåˆ›å»ºç©å®¶çš„é•œåƒ
                    if (trap.dataset.hasTriggered === 'false') {
                        trap.dataset.hasTriggered = 'true';
                        createPlayerClone();
                        messageDisplay.textContent = 'ğŸ‘¥ å‡ºç°äº†åˆ†èº«ï¼';
                        setTimeout(() => {
                            if (messageDisplay.textContent.includes('å‡ºç°äº†åˆ†èº«')) {
                                messageDisplay.textContent = '';
                            }
                        }, 2000);
                    }
                    break;
                    
                default:
                    // å…¶ä»–ç‰¹æ®Šé™·é˜±ä¹Ÿä¼šå¯¼è‡´æ¸¸æˆç»“æŸ
                    gameOver();
                    break;
            }
        }

        // åˆ›å»ºåˆ†è£‚çš„å°é™·é˜±
        function createSplitTraps(originalTrap) {
            const rect = originalTrap.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2 - gameContainer.getBoundingClientRect().left;
            const centerY = rect.top + rect.height / 2 - gameContainer.getBoundingClientRect().top;
            
            const directions = [
                {x: -1, y: -1}, {x: 1, y: -1}, 
                {x: -1, y: 1}, {x: 1, y: 1}
            ];
            
            directions.forEach((dir, index) => {
                setTimeout(() => {
                    const smallTrap = document.createElement('div');
                    smallTrap.className = 'trap';
                    smallTrap.style.width = '20px';
                    smallTrap.style.height = '20px';
                    smallTrap.style.left = (centerX + dir.x * 30) + 'px';
                    smallTrap.style.top = (centerY + dir.y * 30) + 'px';
                    smallTrap.style.position = 'absolute';
                    
                    gameContainer.appendChild(smallTrap);
                    gameState.traps.push(smallTrap);
                }, index * 100);
            });
        }

        // åˆ›å»ºç©å®¶å…‹éš†
        function createPlayerClone() {
            const clone = document.createElement('div');
            clone.className = 'player-clone';
            clone.innerHTML = 'ğŸ§™â€â™‚ï¸';
            clone.style.position = 'absolute';
            clone.style.width = '40px';
            clone.style.height = '50px';
            clone.style.fontSize = '40px';
            clone.style.display = 'flex';
            clone.style.alignItems = 'center';
            clone.style.justifyContent = 'center';
            clone.style.zIndex = '3';
            clone.style.opacity = '0.7';
            clone.style.filter = 'hue-rotate(180deg)';
            
            // å…‹éš†å‡ºç°åœ¨ç©å®¶é™„è¿‘çš„éšæœºä½ç½®
            const offsetX = (Math.random() - 0.5) * 200;
            const offsetY = (Math.random() - 0.5) * 200;
            clone.style.left = Math.max(0, Math.min(gameWidth - 40, gameState.player.x + offsetX)) + 'px';
            clone.style.top = Math.max(0, Math.min(gameHeight - 50, gameState.player.y + offsetY)) + 'px';
            
            gameContainer.appendChild(clone);
            
            // å…‹éš†ä¼šè·Ÿéšç©å®¶ç§»åŠ¨ï¼Œä½†æœ‰å»¶è¿Ÿ
            let cloneX = parseFloat(clone.style.left);
            let cloneY = parseFloat(clone.style.top);
            
            const cloneInterval = setInterval(() => {
                if (gameState.gameOver) {
                    clearInterval(cloneInterval);
                    clone.remove();
                    return;
                }
                
                // å…‹éš†ç¼“æ…¢è·Ÿéšç©å®¶
                const dx = gameState.player.x - cloneX;
                const dy = gameState.player.y - cloneY;
                cloneX += dx * 0.1;
                cloneY += dy * 0.1;
                
                clone.style.left = cloneX + 'px';
                clone.style.top = cloneY + 'px';
            }, 50);
            
            // 10ç§’åç§»é™¤å…‹éš†
            setTimeout(() => {
                clearInterval(cloneInterval);
                if (clone.parentNode) {
                    clone.remove();
                }
            }, 10000);
        }

        // æ£€æµ‹ç¢°æ’
        function checkCollisions() {
            const playerRect = player.getBoundingClientRect();
            const doorRect = door.getBoundingClientRect();
            
            // æ£€æŸ¥æ˜¯å¦å®Œå…¨è¿›å…¥é—¨å†…ï¼ˆç©å®¶éœ€è¦å®Œå…¨åœ¨é—¨çš„èŒƒå›´å†…ï¼‰
            if (playerRect.left >= doorRect.left + 5 && 
                playerRect.right <= doorRect.right - 5 && 
                playerRect.bottom >= doorRect.top + 5 && 
                playerRect.top <= doorRect.bottom - 5) {
                levelComplete();
                return;
            }
            
            // æ£€æŸ¥ä¸é™æ€é™·é˜±çš„ç¢°æ’
            for (const trap of gameState.traps) {
                const trapRect = trap.getBoundingClientRect();
                if (playerRect.right > trapRect.left && 
                    playerRect.left < trapRect.right && 
                    playerRect.bottom > trapRect.top && 
                    playerRect.top < trapRect.bottom) {
                    
                    // å¤„ç†ç‰¹æ®Šé™·é˜±
                    if (trap.dataset.trapType) {
                        // é—ªçƒé™·é˜±åœ¨ä¸å¯è§æ—¶ä¸ä¼šé€ æˆä¼¤å®³
                        if (trap.dataset.trapType === 'blink' && trap.dataset.visible === 'false') {
                            continue;
                        }
                        handleSpecialTrap(trap);
                    } else {
                        gameOver();
                    }
                    return;
                }
            }
            
            // æ£€æŸ¥ä¸ç§»åŠ¨é™·é˜±çš„ç¢°æ’
            for (const trap of gameState.movingTraps) {
                const trapRect = trap.element.getBoundingClientRect();
                if (playerRect.right > trapRect.left && 
                    playerRect.left < trapRect.right && 
                    playerRect.bottom > trapRect.top && 
                    playerRect.top < trapRect.bottom) {
                    gameOver();
                    return;
                }
            }
            
            // æ£€æŸ¥è¾¹ç•Œ
            if (gameState.player.x < 0 || gameState.player.x > gameWidth - 40 ||
                gameState.player.y < 0 || gameState.player.y > gameHeight - 50) {
                gameOver();
                return;
            }
        }

        // å…³å¡å®Œæˆ
        function levelComplete() {
            // é˜²æ­¢é‡å¤è°ƒç”¨
            if (gameState.gameOver) return;
            gameState.gameOver = true;
            
            // æ’­æ”¾è¿‡å…³éŸ³æ•ˆ
            playSuccessSound();
            
            // æ·»åŠ è¿‡å…³ç‰¹æ•ˆ
            const sparkle = document.createElement('div');
            sparkle.className = 'level-complete';
            sparkle.style.left = (gameState.player.x - 30) + 'px';
            sparkle.style.top = (gameState.player.y - 25) + 'px';
            gameContainer.appendChild(sparkle);
            
            // ç§»é™¤ç‰¹æ•ˆ
            setTimeout(() => {
                sparkle.remove();
            }, 1000);
            
            // è§£é”ä¸‹ä¸€å…³
            if (gameState.currentLevel === gameState.maxUnlockedLevel && gameState.currentLevel < gameState.maxLevel) {
                gameState.maxUnlockedLevel = gameState.currentLevel + 1;
                saveProgress();
            }
            
            if (gameState.currentLevel === gameState.maxLevel) {
                // ç¬¬10å…³é€šå…³ - æ˜¾ç¤ºZackæ‹¯æ•‘æˆåŠŸå¯¹è¯æ¡†
                setTimeout(() => {
                    showZackSuccessDialog();
                }, 1500); // ç­‰å¾…ç‰¹æ•ˆå®Œæˆåæ˜¾ç¤º
            } else {
                messageDisplay.textContent = `âœ¨ æ­å–œé€šè¿‡ç¬¬ ${gameState.currentLevel} å…³ï¼è§£é”ç¬¬ ${gameState.currentLevel + 1} å…³ï¼`;
                // 2ç§’åè‡ªåŠ¨è¿›å…¥ä¸‹ä¸€å…³
                setTimeout(() => {
                    nextLevel();
                }, 2000);
            }
        }

        // æ¸¸æˆç»“æŸ
        function gameOver() {
            // é˜²æ­¢é‡å¤è°ƒç”¨
            if (gameState.gameOver) return;
            gameState.gameOver = true;
            
            // å¢åŠ å¾ªç¯æ¬¡æ•°
            loopCount++;
            updateProgressDisplay(); // æ›´æ–°æ˜¾ç¤º
            
            // æ’­æ”¾çˆ†ç‚¸éŸ³æ•ˆ
            playExplosionSound();
            
            // æ·»åŠ çˆ†ç‚¸ç‰¹æ•ˆ
            const explosion = document.createElement('div');
            explosion.className = 'explosion';
            explosion.style.left = (gameState.player.x - 30) + 'px';
            explosion.style.top = (gameState.player.y - 25) + 'px';
            gameContainer.appendChild(explosion);
            
            // éšè—ç©å®¶
            player.style.display = 'none';
            
            messageDisplay.textContent = `ğŸ’¥ çˆ†ç‚¸äº†ï¼ç¬¬${loopCount}æ¬¡å¾ªç¯å¼€å§‹...`;
            
            // ç§»é™¤çˆ†ç‚¸ç‰¹æ•ˆå¹¶é‡æ–°å¼€å§‹å½“å‰å…³å¡
            setTimeout(() => {
                explosion.remove();
                player.style.display = 'flex';
                restartCurrentLevel();
            }, 1500);
        }
        
        // é‡æ–°å¼€å§‹å½“å‰å…³å¡
        function restartCurrentLevel() {
            gameState.player = { x: 50, y: 250 };
            gameState.traps = [];
            gameState.movingTraps = [];
            gameState.specialTraps = [];
            gameState.gameOver = false;
            gameState.playerFrozen = false;
            gameState.freezeEndTime = 0;
            
            messageDisplay.textContent = '';
            
            // æ¸…é™¤ç©å®¶çš„ç‰¹æ®ŠçŠ¶æ€
            player.style.filter = '';
            player.style.transform = '';
            
            // æ¸…é™¤ä¹‹å‰çš„é™·é˜±ï¼ˆåŒ…æ‹¬ç‰¹æ®Šé™·é˜±ï¼‰
            document.querySelectorAll('.trap, .spike, .moving-trap, .invisible-trap, .teleport-trap, .hunter-trap, .blink-trap, .gravity-trap, .split-trap, .mirror-trap, .freeze-trap, .bounce-trap, .shrink-trap, .speed-trap, .clone-trap, .player-clone').forEach(el => el.remove());
            
            updatePlayerPosition();
            
            // é‡ç”¨ç°æœ‰çš„å…³å¡å¸ƒå±€
            levelDisplay.textContent = gameState.currentLevel;
            playerSpeed = basePlayerSpeed + Math.floor(gameState.currentLevel / 3); // æ¯3å…³å¢åŠ 1ç‚¹é€Ÿåº¦
            createTraps(true); // ä½¿ç”¨ç°æœ‰å¸ƒå±€
            setupMovingTraps(true); // ä½¿ç”¨ç°æœ‰å¸ƒå±€
        }

        // ä¸‹ä¸€å…³
        function nextLevel() {
            gameState.currentLevel++;
            saveProgress(); // ä¿å­˜å½“å‰å…³å¡è¿›åº¦
            gameState.player = { x: 50, y: 250 };
            gameState.traps = [];
            gameState.movingTraps = [];
            gameState.specialTraps = [];
            gameState.gameOver = false;  // é‡ç½®æ¸¸æˆçŠ¶æ€
            gameState.playerFrozen = false;
            gameState.freezeEndTime = 0;
            
            messageDisplay.textContent = '';
            nextBtn.classList.add('hidden');
            
            // æ¸…é™¤ç©å®¶çš„ç‰¹æ®ŠçŠ¶æ€
            player.style.filter = '';
            player.style.transform = '';
            
            // æ¸…é™¤ä¹‹å‰çš„é™·é˜±ï¼ˆåŒ…æ‹¬ç‰¹æ®Šé™·é˜±ï¼‰
            document.querySelectorAll('.trap, .spike, .moving-trap, .invisible-trap, .teleport-trap, .hunter-trap, .blink-trap, .gravity-trap, .split-trap, .mirror-trap, .freeze-trap, .bounce-trap, .shrink-trap, .speed-trap, .clone-trap, .player-clone').forEach(el => el.remove());
            
            updatePlayerPosition();
            setupLevel();
            updateProgressDisplay(); // æ›´æ–°è¿›åº¦æ˜¾ç¤º
            
            // ä¸éœ€è¦å†æ¬¡è°ƒç”¨gameLoop()ï¼Œå› ä¸ºå®ƒå·²ç»åœ¨è¿è¡Œ
        }

        // æ›´æ–°ç©å®¶ç§»åŠ¨
        function updatePlayerMovement() {
            if (gameState.gameOver || gameState.playerFrozen) return;
            
            if (keys.ArrowUp) {
                gameState.player.y -= playerSpeed;
            }
            if (keys.ArrowDown) {
                gameState.player.y += playerSpeed;
            }
            if (keys.ArrowLeft) {
                gameState.player.x -= playerSpeed;
            }
            if (keys.ArrowRight) {
                gameState.player.x += playerSpeed;
            }
            
            updatePlayerPosition();
        }

        // æ¸¸æˆä¸»å¾ªç¯
        function gameLoop() {
            updatePlayerMovement();
            updateSpecialTraps();
            checkCollisions();
            animationFrame = requestAnimationFrame(gameLoop);
        }

        // æ›´æ–°ç‰¹æ®Šé™·é˜±çš„è¡Œä¸º
        function updateSpecialTraps() {
            if (gameState.gameOver) return;
            
            gameState.traps.forEach(trap => {
                const trapType = trap.dataset.trapType;
                if (!trapType) return;
                
                const playerRect = player.getBoundingClientRect();
                const trapRect = trap.getBoundingClientRect();
                
                switch(trapType) {
                    case 'invisible':
                        // éšå½¢é™·é˜±ï¼šç©å®¶é è¿‘æ—¶æ˜¾ç°
                        const distance = Math.sqrt(
                            Math.pow(playerRect.left - trapRect.left, 2) + 
                            Math.pow(playerRect.top - trapRect.top, 2)
                        );
                        if (distance < 80 && trap.dataset.revealed === 'false') {
                            trap.dataset.revealed = 'true';
                            trap.classList.add('revealed');
                        }
                        break;
                        
                    case 'hunter':
                        // è¿½è¸ªé™·é˜±ï¼šè·Ÿç€ç©å®¶ç§»åŠ¨
                        const speed = parseFloat(trap.dataset.huntSpeed) || 2;
                        const currentLeft = parseFloat(trap.style.left);
                        const currentTop = parseFloat(trap.style.top);
                        
                        const playerX = gameState.player.x + 20; // ç©å®¶ä¸­å¿ƒç‚¹
                        const playerY = gameState.player.y + 25;
                        const trapX = currentLeft + 20; // é™·é˜±ä¸­å¿ƒç‚¹
                        const trapY = currentTop + 20;
                        
                        const dx = playerX - trapX;
                        const dy = playerY - trapY;
                        const magnitude = Math.sqrt(dx * dx + dy * dy);
                        
                        if (magnitude > 5) { // é¿å…æŠ–åŠ¨
                            const moveX = (dx / magnitude) * speed;
                            const moveY = (dy / magnitude) * speed;
                            
                            trap.style.left = Math.max(0, Math.min(gameWidth - 40, currentLeft + moveX)) + 'px';
                            trap.style.top = Math.max(0, Math.min(gameHeight - 40, currentTop + moveY)) + 'px';
                        }
                        break;
                        
                    case 'mirror':
                        // é•œåƒé™·é˜±ï¼šä¸ç©å®¶åšç›¸åç§»åŠ¨
                        const centerX = gameWidth / 2;
                        const centerY = gameHeight / 2;
                        const mirrorX = centerX - (gameState.player.x - centerX);
                        const mirrorY = centerY - (gameState.player.y - centerY);
                        
                        trap.style.left = Math.max(0, Math.min(gameWidth - 40, mirrorX - 20)) + 'px';
                        trap.style.top = Math.max(0, Math.min(gameHeight - 40, mirrorY - 25)) + 'px';
                        break;
                        
                    case 'gravity':
                        // é‡åŠ›é™·é˜±ï¼šå¸å¼•ç©å®¶
                        const gravityDistance = Math.sqrt(
                            Math.pow(playerRect.left - trapRect.left, 2) + 
                            Math.pow(playerRect.top - trapRect.top, 2)
                        );
                        
                        if (gravityDistance < 120) { // é‡åŠ›èŒƒå›´
                            const pullForce = parseFloat(trap.dataset.pullForce) || 3;
                            const trapCenterX = trapRect.left + trapRect.width / 2 - gameContainer.getBoundingClientRect().left;
                            const trapCenterY = trapRect.top + trapRect.height / 2 - gameContainer.getBoundingClientRect().top;
                            
                            const pullX = trapCenterX - (gameState.player.x + 20);
                            const pullY = trapCenterY - (gameState.player.y + 25);
                            const pullMagnitude = Math.sqrt(pullX * pullX + pullY * pullY);
                            
                            if (pullMagnitude > 0) {
                                gameState.player.x += (pullX / pullMagnitude) * pullForce * 0.3;
                                gameState.player.y += (pullY / pullMagnitude) * pullForce * 0.3;
                                updatePlayerPosition();
                            }
                        }
                        break;
                        
                    case 'blink':
                        // é—ªçƒé™·é˜±é€»è¾‘å·²é€šè¿‡CSSåŠ¨ç”»å¤„ç†
                        const computedStyle = window.getComputedStyle(trap);
                        trap.dataset.visible = computedStyle.opacity > 0.5 ? 'true' : 'false';
                        break;
                }
            });
        }

        // é”®ç›˜æ§åˆ¶
        document.addEventListener('keydown', (e) => {
            if (gameState.gameOver) return;
            
            if (e.key in keys) {
                keys[e.key] = true;
            }
        });

        document.addEventListener('keyup', (e) => {
            if (e.key in keys) {
                keys[e.key] = false;
            }
        });

        // äº‹ä»¶ç›‘å¬
        nextBtn.addEventListener('click', () => {
            playClickSound();
            nextLevel();
        });
        
        restartBtn.addEventListener('click', () => {
            playClickSound();
            startLevel();
        });
        
        levelSelectBtn.addEventListener('click', () => {
            playClickSound();
            createLevelButtons();
            levelSelectModal.classList.remove('hidden');
        });
        
        soundToggleBtn.addEventListener('click', toggleSound);
        
        musicToggleBtn.addEventListener('click', () => {
            playClickSound();
            toggleMusic();
        });
        

        
        closeSelectBtn.addEventListener('click', () => {
            playClickSound();
            levelSelectModal.classList.add('hidden');
        });
        
        resetProgressBtn.addEventListener('click', () => {
            playClickSound();
            if (confirm('ç¡®å®šè¦é‡ç½®æ‰€æœ‰è¿›åº¦å—ï¼Ÿè¿™å°†åˆ é™¤æ‚¨çš„æ‰€æœ‰æ¸¸æˆè®°å½•ï¼')) {
                resetProgress();
                initGame();
                messageDisplay.textContent = 'è¿›åº¦å·²é‡ç½®ï¼';
                setTimeout(() => {
                    messageDisplay.textContent = '';
                }, 2000);
            }
        });

        // é¡µé¢åŠ è½½æ—¶ç«‹å³éšè—å…³å¡é€‰æ‹©å™¨
        levelSelectModal.classList.add('hidden');
        
        // å¤„ç†é¦–æ¬¡ç”¨æˆ·äº¤äº’ï¼ˆç”¨äºå¯åŠ¨èƒŒæ™¯éŸ³ä¹ï¼‰
        let firstInteraction = true;
        function handleFirstInteraction() {
            if (firstInteraction && musicEnabled && backgroundMusic) {
                playBackgroundMusic();
                firstInteraction = false;
            }
        }

        // ç›‘å¬å„ç§ç”¨æˆ·äº¤äº’äº‹ä»¶
        document.addEventListener('click', handleFirstInteraction);
        document.addEventListener('keydown', handleFirstInteraction);
        document.addEventListener('touchstart', handleFirstInteraction);
        
        // å¼€å§‹æ¸¸æˆ
        initGame();
        gameLoop();
    </script>
</body>
</html>