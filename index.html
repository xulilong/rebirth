<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ÊãØÊïëZack</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            text-align: center;
            background-color: #222;
            color: white;
            margin: 0;
            padding: 20px;
            overflow: hidden;
        }
        #game-container {
            position: relative;
            width: 800px;
            height: 500px;
            margin: 0 auto;
            background-color: #333;
            border: 3px solid #555;
            overflow: hidden;
        }
        #player {
            position: absolute;
            width: 40px;
            height: 50px;
            z-index: 10;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        #player::before {
            content: 'üßô‚Äç‚ôÇÔ∏è';
            font-size: 35px;
            animation: fly 1s ease-in-out infinite alternate;
        }
        
        @keyframes fly {
            0% { transform: translateY(0px) rotate(-2deg); }
            100% { transform: translateY(-8px) rotate(2deg); }
        }
        #door {
            position: absolute;
            width: 60px;
            height: 100px;
            background: linear-gradient(135deg, #2c2c2c 0%, #1a1a1a 50%, #000 100%);
            border: 5px solid #8B4513;
            border-radius: 10px 10px 0 0;
            right: 20px;
            bottom: 0;
            z-index: 5;
            box-shadow: inset 0 0 20px rgba(0,0,0,0.8);
        }
        
        #door::before {
            content: 'üö™';
            position: absolute;
            font-size: 40px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            opacity: 0.8;
        }
        
        #door::after {
            content: '';
            position: absolute;
            width: 8px;
            height: 8px;
            background: #FFD700;
            border-radius: 50%;
            right: 8px;
            top: 45%;
            box-shadow: 0 0 5px rgba(255, 215, 0, 0.5);
        }
        
        /* ZackÊòæÁ§∫Ê†∑Âºè */
        .zack-display {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 200px;
            height: 200px;
            background: linear-gradient(45deg, #4CAF50, #45a049);
            border: 4px solid #2E7D32;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 80px;
            z-index: 20;
            animation: zackAppear 2s ease-out;
        }
        
        /* ÂØπËØùÊ°ÜÊ†∑Âºè */
        .dialogue-box {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            border: 3px solid #FFD700;
            border-radius: 15px;
            padding: 20px;
            max-width: 500px;
            min-width: 300px;
            z-index: 100;
            color: white;
            font-size: 18px;
            line-height: 1.5;
            text-align: center;
            animation: dialogueAppear 0.5s ease-out;
        }
        
        .dialogue-title {
            font-size: 24px;
            font-weight: bold;
            color: #FFD700;
            margin-bottom: 15px;
            border-bottom: 2px solid #FFD700;
            padding-bottom: 10px;
        }
        
        .dialogue-content {
            margin-bottom: 15px;
        }
        
        .dialogue-continue {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
        }
        
        .dialogue-continue:hover {
            background: #45a049;
        }
        
        @keyframes dialogueAppear {
            0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }
        
        @keyframes zackAppear {
            0% { transform: translate(-50%, -50%) scale(0); opacity: 0; }
            50% { transform: translate(-50%, -50%) scale(1.2); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }
        .trap {
            position: absolute;
            background-color: #8B4513;
            border: 2px solid #654321;
            z-index: 2;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
        }
        
        .trap::before {
            content: "üß±";
        }
        .level-info {
            font-size: 24px;
            margin: 10px 0;
        }
        #progress-info {
            font-size: 18px;
            color: #FFD700;
            font-weight: normal;
        }
        .controls {
            margin: 20px 0;
        }
        button {
            padding: 10px 20px;
            font-size: 16px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin: 0 10px;
        }
        button:hover {
            background-color: #45a049;
        }
        
        /* ÂÖ≥Âç°ÈÄâÊã©Âô®Ê†∑Âºè */
        #level-select {
            background-color: rgba(0,0,0,0.9);
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 100;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
        }
        
        #level-select.hidden {
            display: none !important;
        }
        
        #level-buttons {
            display: grid;
            grid-template-columns: repeat(10, 60px);
            gap: 10px;
            margin: 20px;
            max-height: 300px;
            overflow-y: auto;
        }
        
        .level-btn {
            width: 60px;
            height: 60px;
            border-radius: 10px;
            font-size: 16px;
            font-weight: bold;
        }
        
        .level-btn.unlocked {
            background-color: #4CAF50;
            border: 2px solid #45a049;
        }
        
        .level-btn.current {
            background-color: #FFD700;
            color: #333;
            border: 2px solid #FFA500;
        }
        
        .level-btn.locked {
            background-color: #666;
            color: #999;
            cursor: not-allowed;
            border: 2px solid #555;
        }
        
        #close-select-btn {
            background-color: #f44336;
            margin-top: 20px;
        }
        
        #close-select-btn:hover {
            background-color: #da190b;
        }
        
        #reset-progress-btn {
            background-color: #ff9800;
        }
        
        #reset-progress-btn:hover {
            background-color: #e68900;
        }
        
        /* Â∏ÆÂä©Èù¢ÊùøÊ†∑Âºè */
        #help-modal {
            background-color: rgba(0,0,0,0.95);
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 200;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            color: white;
            padding: 20px;
            overflow-y: auto;
        }
        
        #help-modal.hidden {
            display: none !important;
        }
        
        #help-modal h3 {
            color: #FFD700;
            margin-bottom: 20px;
            font-size: 28px;
        }
        
        #trap-guide {
            max-width: 800px;
            width: 100%;
        }
        
        .level-themes {
            max-width: 800px;
            width: 100%;
            margin-bottom: 30px;
            background-color: rgba(255,255,255,0.1);
            padding: 20px;
            border-radius: 10px;
        }
        
        .level-themes h4 {
            color: #FFD700;
            margin-bottom: 15px;
            font-size: 22px;
            border-bottom: 2px solid #FFD700;
            padding-bottom: 5px;
        }
        
        .theme-item {
            display: grid;
            grid-template-columns: 120px 1fr;
            gap: 15px;
            align-items: center;
            padding: 8px;
            margin-bottom: 5px;
            background-color: rgba(255,255,255,0.05);
            border-radius: 6px;
            border-left: 4px solid #9C27B0;
        }
        
        .theme-range {
            font-weight: bold;
            color: #9C27B0;
            font-size: 14px;
            text-align: center;
        }
        
        .theme-desc {
            color: #E0E0E0;
            font-size: 14px;
            line-height: 1.4;
        }
        
        .trap-category {
            margin-bottom: 30px;
            background-color: rgba(255,255,255,0.1);
            padding: 20px;
            border-radius: 10px;
        }
        
        .trap-category h4 {
            color: #FFD700;
            margin-bottom: 15px;
            font-size: 22px;
            border-bottom: 2px solid #FFD700;
            padding-bottom: 5px;
        }
        
        .trap-item {
            display: grid;
            grid-template-columns: 40px 150px 1fr;
            gap: 15px;
            align-items: center;
            padding: 10px;
            margin-bottom: 8px;
            background-color: rgba(255,255,255,0.05);
            border-radius: 8px;
            border-left: 4px solid #4CAF50;
        }
        
        .trap-icon {
            font-size: 24px;
            text-align: center;
        }
        
        .trap-name {
            font-weight: bold;
            color: #FFD700;
            font-size: 16px;
        }
        
        .trap-desc {
            color: #E0E0E0;
            font-size: 14px;
            line-height: 1.4;
        }
        
        #close-help-btn {
            background-color: #f44336;
            margin-top: 30px;
            padding: 15px 30px;
            font-size: 18px;
        }
        
        #close-help-btn:hover {
            background-color: #da190b;
        }
        
        /* Èü≥‰πêÊéßÂà∂ÊåâÈíÆÊ†∑Âºè */
        #music-toggle-btn {
            background-color: #9C27B0;
        }
        
        #music-toggle-btn:hover {
            background-color: #7B1FA2;
        }
        

        

        #message {
            font-size: 24px;
            height: 30px;
            margin: 10px 0;
            color: #FFD700;
        }
        .hidden {
            display: none;
        }
        .spike {
            position: absolute;
            width: 30px;
            height: 30px;
            background-color: #696969;
            bottom: 0;
            z-index: 2;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            border-radius: 50% 50% 50% 50% / 60% 60% 40% 40%;
        }
        
        .spike::before {
            content: "‚ö°";
        }
        .moving-trap {
            position: absolute;
            width: 40px;
            height: 40px;
            background-color: #FF6347;
            border: 2px solid #DC143C;
            border-radius: 50%;
            z-index: 2;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
        }
        
        .moving-trap::before {
            content: "üî•";
        }
        
        /* Êñ∞ÁöÑÈô∑Èò±Á±ªÂûãÊ†∑Âºè */
        .invisible-trap {
            position: absolute;
            background-color: rgba(128, 128, 128, 0.1);
            border: 2px dashed rgba(128, 128, 128, 0.3);
            z-index: 2;
            transition: opacity 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
        }
        
        .invisible-trap::before {
            content: "üëª";
            opacity: 0.3;
        }
        
        .invisible-trap.revealed {
            background-color: rgba(105, 105, 105, 0.8);
            border: 2px solid #696969;
        }
        
        .invisible-trap.revealed::before {
            opacity: 1;
        }
        
        .teleport-trap {
            position: absolute;
            width: 50px;
            height: 50px;
            background: radial-gradient(circle, #9C27B0, #673AB7);
            border-radius: 50%;
            z-index: 2;
            animation: teleportPulse 2s ease-in-out infinite;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
        }
        
        .teleport-trap::before {
            content: "üåÄ";
        }
        
        @keyframes teleportPulse {
            0%, 100% { transform: scale(1); opacity: 0.7; }
            50% { transform: scale(1.2); opacity: 1; }
        }
        
        .hunter-trap {
            position: absolute;
            width: 35px;
            height: 35px;
            background-color: #FF4500;
            border-radius: 50%;
            z-index: 2;
            border: 3px solid #FF6347;
            animation: hunterGlow 1s ease-in-out infinite alternate;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
        }
        
        .hunter-trap::before {
            content: "üéØ";
        }
        
        @keyframes hunterGlow {
            0% { box-shadow: 0 0 5px #FF4500; }
            100% { box-shadow: 0 0 15px #FF4500, 0 0 25px #FF4500; }
        }
        
        .blink-trap {
            position: absolute;
            background-color: #00BCD4;
            z-index: 2;
            animation: blinkTrap 3s ease-in-out infinite;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            border-radius: 50%;
        }
        
        .blink-trap::before {
            content: "üí´";
        }
        
        @keyframes blinkTrap {
            0%, 40% { opacity: 1; }
            50%, 90% { opacity: 0; }
            100% { opacity: 1; }
        }
        
        .gravity-trap {
            position: absolute;
            width: 60px;
            height: 60px;
            background: radial-gradient(circle, rgba(0,0,0,0.8), rgba(0,0,0,0.3));
            border: 3px solid #333;
            border-radius: 50%;
            z-index: 2;
            animation: gravityPull 2s ease-in-out infinite;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
        }
        
        .gravity-trap::before {
            content: "üï≥Ô∏è";
        }
        
        @keyframes gravityPull {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
        
        .split-trap {
            position: absolute;
            width: 45px;
            height: 45px;
            background-color: #32CD32;
            border: 2px solid #228B22;
            z-index: 2;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
        }
        
        .split-trap::before {
            content: "üí•";
        }
        
        .mirror-trap {
            position: absolute;
            width: 40px;
            height: 40px;
            background: linear-gradient(45deg, #C0C0C0, #808080);
            border-radius: 50%;
            z-index: 2;
            border: 2px solid #999;
            animation: mirrorShine 2s linear infinite;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
        }
        
        .mirror-trap::before {
            content: "ü™û";
        }
        
        @keyframes mirrorShine {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .freeze-trap {
            position: absolute;
            width: 40px;
            height: 40px;
            background: linear-gradient(45deg, #00E5FF, #0277BD);
            border-radius: 50%;
            z-index: 2;
            animation: freezeEffect 1.5s ease-in-out infinite;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
        }
        
        .freeze-trap::before {
            content: "üßä";
        }
        
        @keyframes freezeEffect {
            0%, 100% { transform: scale(1); filter: hue-rotate(0deg); }
            50% { transform: scale(0.9); filter: hue-rotate(90deg); }
        }
        
        .bounce-trap {
            position: absolute;
            width: 40px;
            height: 40px;
            background: linear-gradient(45deg, #FF1493, #FF69B4);
            border-radius: 50%;
            z-index: 2;
            animation: bounceEffect 1s ease-in-out infinite;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
        }
        
        .bounce-trap::before {
            content: "üèÄ";
        }
        
        @keyframes bounceEffect {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
        }
        
        .shrink-trap {
            position: absolute;
            width: 40px;
            height: 40px;
            background: linear-gradient(45deg, #FFD700, #FFA500);
            border-radius: 50%;
            z-index: 2;
            animation: shrinkEffect 2s ease-in-out infinite;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
        }
        
        .shrink-trap::before {
            content: "üîç";
        }
        
        @keyframes shrinkEffect {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(0.5); }
        }
        
        .speed-trap {
            position: absolute;
            width: 40px;
            height: 40px;
            background: linear-gradient(45deg, #00FF00, #32CD32);
            border-radius: 50%;
            z-index: 2;
            animation: speedEffect 0.5s linear infinite;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
        }
        
        .speed-trap::before {
            content: "‚ö°";
        }
        
        @keyframes speedEffect {
            0% { transform: rotate(0deg) scale(1); }
            100% { transform: rotate(360deg) scale(1.1); }
        }
        
        .clone-trap {
            position: absolute;
            width: 40px;
            height: 40px;
            background: linear-gradient(45deg, #8A2BE2, #9370DB);
            border-radius: 50%;
            z-index: 2;
            animation: cloneEffect 1.5s ease-in-out infinite;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
        }
        
        .clone-trap::before {
            content: "üë•";
        }
        
        @keyframes cloneEffect {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.5; transform: scale(1.2); }
        }
        
        /* ÁâπÊÆäÂÖ≥Âç°Êú∫Âà∂Ê†∑Âºè */
        .collectible {
            position: absolute;
            width: 30px;
            height: 30px;
            background: radial-gradient(circle, #FFD700, #FFA500);
            border-radius: 50%;
            z-index: 3;
            animation: collectibleFloat 2s ease-in-out infinite;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            border: 2px solid #FF8C00;
        }
        
        .collectible::before {
            content: "üíé";
        }
        
        @keyframes collectibleFloat {
            0%, 100% { transform: translateY(0px) scale(1); }
            50% { transform: translateY(-8px) scale(1.1); }
        }
        
        .key-item {
            position: absolute;
            width: 25px;
            height: 25px;
            background: linear-gradient(45deg, #FFD700, #FFC107);
            border-radius: 5px;
            z-index: 3;
            animation: keyGlow 1.5s ease-in-out infinite;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
        }
        
        .key-item::before {
            content: "üóùÔ∏è";
        }
        
        @keyframes keyGlow {
            0%, 100% { box-shadow: 0 0 5px #FFD700; }
            50% { box-shadow: 0 0 15px #FFD700, 0 0 25px #FFC107; }
        }
        
        .teleporter {
            position: absolute;
            width: 60px;
            height: 60px;
            background: radial-gradient(circle, rgba(138, 43, 226, 0.8), rgba(75, 0, 130, 0.6));
            border-radius: 50%;
            z-index: 2;
            animation: teleporterPulse 2s ease-in-out infinite;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            border: 3px solid #9370DB;
        }
        
        .teleporter::before {
            content: "üåÄ";
        }
        
        @keyframes teleporterPulse {
            0%, 100% { transform: scale(1); opacity: 0.8; }
            50% { transform: scale(1.2); opacity: 1; }
        }
        
        .switch {
            position: absolute;
            width: 40px;
            height: 40px;
            background: linear-gradient(45deg, #4CAF50, #45a049);
            border-radius: 10px;
            z-index: 3;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            border: 2px solid #388E3C;
            cursor: pointer;
        }
        
        .switch.activated {
            background: linear-gradient(45deg, #FF5722, #D84315);
            border-color: #BF360C;
        }
        
        .switch::before {
            content: "üîò";
        }
        
        .switch.activated::before {
            content: "üî¥";
        }
        
        .moving-platform {
            position: absolute;
            width: 80px;
            height: 20px;
            background: linear-gradient(45deg, #795548, #5D4037);
            border-radius: 10px;
            z-index: 2;
            border: 2px solid #4E342E;
        }
        
        /* ÈöêÂΩ¢Âú∞Èõ∑Ê†∑Âºè */
        .hidden-mine {
            position: absolute;
            background: transparent;
            border: none;
            cursor: crosshair;
            z-index: 1;
        }
        
        .hidden-mine.exploded {
            background: radial-gradient(circle, #ff4444, #cc0000);
            border: 2px solid #ff0000;
            border-radius: 50%;
            animation: mineExplode 0.5s ease-out;
        }
        
        @keyframes mineExplode {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(2); opacity: 0.8; }
            100% { transform: scale(3); opacity: 0; }
        }
        
        /* Ëø∑ÂÆ´Â¢ôÂ£ÅÊ†∑Âºè */
        .maze-wall {
            position: absolute;
            background-color: #8B4513;
            border: 1px solid #654321;
            box-shadow: inset 2px 2px 4px rgba(0,0,0,0.3);
            background-image: 
                linear-gradient(45deg, #A0522D 25%, transparent 25%), 
                linear-gradient(-45deg, #A0522D 25%, transparent 25%), 
                linear-gradient(45deg, transparent 75%, #A0522D 75%), 
                linear-gradient(-45deg, transparent 75%, #A0522D 75%);
            background-size: 8px 8px;
            background-position: 0 0, 0 4px, 4px -4px, -4px 0px;
            z-index: 1;
        }
        
        /* ÈªëÊöóÊ®°Âºè */
        .dark-mode {
            background: radial-gradient(circle at var(--light-x, 50%) var(--light-y, 50%), 
                        rgba(255,255,255,0.3) 0%, 
                        rgba(255,255,255,0.1) var(--light-radius, 100px), 
                        rgba(0,0,0,0.9) calc(var(--light-radius, 100px) + 20px));
        }
        
        /* Áé©ÂÆ∂ÈöêÂΩ¢ÊïàÊûú */
        .player-invisible {
            opacity: 0.3;
            filter: blur(1px);
        }
        
        /* ÈáçÂäõÁøªËΩ¨ÊïàÊûú */
        .gravity-flipped {
            transform: scaleY(-1);
        }
        
        /* ÊªëÂÜ∞ÊïàÊûú */
        .slippery-mode .player {
            transition: all 0.1s ease-out;
        }
        
        /* Êó∂Èó¥ÈôêÂà∂ÊòæÁ§∫ */
        .timer-display {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255, 0, 0, 0.8);
            color: white;
            padding: 5px 10px;
            border-radius: 15px;
            font-weight: bold;
            font-size: 16px;
            z-index: 10;
        }
        
        .timer-warning {
            animation: timerBlink 0.5s ease-in-out infinite;
        }
        
        @keyframes timerBlink {
            0%, 100% { background: rgba(255, 0, 0, 0.8); }
            50% { background: rgba(255, 100, 100, 0.8); }
        }
        
        /* ÁàÜÁÇ∏ÁâπÊïà */
        .explosion {
            position: absolute;
            width: 100px;
            height: 100px;
            z-index: 15;
            pointer-events: none;
        }
        
        .explosion::before {
            content: 'üí•';
            font-size: 80px;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            animation: explode 0.8s ease-out;
        }
        
        @keyframes explode {
            0% {
                transform: translate(-50%, -50%) scale(0.1);
                opacity: 1;
            }
            50% {
                transform: translate(-50%, -50%) scale(1.2);
                opacity: 1;
            }
            100% {
                transform: translate(-50%, -50%) scale(1.5);
                opacity: 0;
            }
        }
        
        /* ËøáÂÖ≥ÁâπÊïà */
        .level-complete {
            position: absolute;
            width: 100px;
            height: 100px;
            z-index: 15;
            pointer-events: none;
        }
        
        .level-complete::before {
            content: '‚ú®';
            font-size: 60px;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            animation: sparkle 1s ease-out;
        }
        
        @keyframes sparkle {
            0% {
                transform: translate(-50%, -50%) scale(0.5) rotate(0deg);
                opacity: 1;
            }
            50% {
                transform: translate(-50%, -50%) scale(1.2) rotate(180deg);
                opacity: 1;
            }
            100% {
                transform: translate(-50%, -50%) scale(1.5) rotate(360deg);
                opacity: 0;
            }
        }
    </style>
</head>
<body>
    <h1>ÊãØÊïëZack</h1>
    <div class="level-info">
        Á¨¨ <span id="level">1</span> ÂÖ≥ 
        <span id="progress-info">(ÊúÄÈ´òËÆ∞ÂΩï: Á¨¨ <span id="max-level">1</span> ÂÖ≥)</span>
        <span id="loop-counter" style="display: none; margin-left: 20px; color: #ff6b6b;">Âæ™ÁéØ: <span id="loop-count">0</span> Ê¨°</span>
    </div>
    <div id="message"></div>
    <div id="game-container">
        <div id="player"></div>
        <div id="door"></div>
        <!-- Èô∑Èò±Â∞ÜÁî±JSÂä®ÊÄÅÁîüÊàê -->
    </div>
    <div class="controls">
        <button id="restart-btn">ÈáçÊñ∞ÂºÄÂßãÂΩìÂâçÂÖ≥</button>
        <button id="next-btn" class="hidden">‰∏ã‰∏ÄÂÖ≥</button>
        <button id="level-select-btn">ÈÄâÊã©ÂÖ≥Âç°</button>
        <button id="sound-toggle-btn">üîä Èü≥Êïà</button>
        <button id="music-toggle-btn">üéµ Èü≥‰πê</button>
        <button id="help-btn">‚ùì Èô∑Èò±ËØ¥Êòé</button>
        <button id="reset-progress-btn">ÈáçÁΩÆËøõÂ∫¶</button>
    </div>
    <div id="level-select" class="hidden">
        <h3>ÈÄâÊã©ÂÖ≥Âç° (Â∑≤Ëß£ÈîÅ: Á¨¨1-<span id="unlocked-levels">1</span>ÂÖ≥)</h3>
        <div id="level-buttons"></div>
        <button id="close-select-btn">ÂÖ≥Èó≠</button>
    </div>
    
    <div id="help-modal" class="hidden">
        <h3>üéØ ÊãØÊïëZack - Ê∏∏ÊàèÊåáÂçó</h3>
        <div class="level-themes">
            <h4>üìñ ÊãØÊïë‰πãË∑Ø</h4>
            <div class="theme-item">
                <span class="theme-range">Á¨¨1ÂÖ≥</span>
                <span class="theme-desc">üè¢ ÂâçÂè∞ - ÂÆâÂÖ®ÈÄöÈÅìÔºåÁÜüÊÇâÊìç‰Ωú</span>
            </div>
            <div class="theme-item">
                <span class="theme-range">Á¨¨2ÂÖ≥</span>
                <span class="theme-desc">üçö Á¨¨‰∏ÄÈ£üÂ†Ç - Âú∞Èõ∑ÈòµÔºåÂØªÊâæ10Êù°ÂÆâÂÖ®Ë∑ØÂæÑ</span>
            </div>
            <div class="theme-item">
                <span class="theme-range">Á¨¨3-10ÂÖ≥</span>
                <span class="theme-desc">üëª ÂπªË±°Ëø∑ÂÆ´ - ËôöÂÆûÈöæËæ®ÁöÑÂπªÂ¢ÉËÄÉÈ™åÊÑüÁü•Âäõ</span>
            </div>
            <div class="theme-item">
                <span class="theme-range">Á¨¨11-20ÂÖ≥</span>
                <span class="theme-desc">üßä ÂÜ∞Â∞ÅÁåéÂú∫ - ÂØíÂÜ∞‰∏éËøΩÁåéËÄÖÁöÑËá¥ÂëΩËàûËπà</span>
            </div>
            <div class="theme-item">
                <span class="theme-range">Á¨¨21-30ÂÖ≥</span>
                <span class="theme-desc">üí• Â¥©ÂùèÁ©∫Èó¥ - Áé∞ÂÆûÂàÜË£ÇÔºåÈáçÂäõÂ§±ÊéßÁöÑÊ∑∑Ê≤å‰∏ñÁïå</span>
            </div>
            <div class="theme-item">
                <span class="theme-range">Á¨¨31-40ÂÖ≥</span>
                <span class="theme-desc">ü™û ÈïúÂÉè‰∏ñÁïå - Âú®ÂèçËΩ¨ÁöÑÁé∞ÂÆû‰∏≠ÂØªÊâæÁúüÁõ∏</span>
            </div>
            <div class="theme-item">
                <span class="theme-range">Á¨¨41-60ÂÖ≥</span>
                <span class="theme-desc">‚ö° Êó∂Á©∫‰π±ÊµÅ - Êó∂Èó¥‰∏éÁ©∫Èó¥ÁöÑÊâ≠Êõ≤ÊîπÂèò‰∏ÄÂàá</span>
            </div>
            <div class="theme-item">
                <span class="theme-range">Á¨¨61-80ÂÖ≥</span>
                <span class="theme-desc">üåÄ Âæ™ÁéØÊ∑±Ê∏ä - Â§öÈáçÂæ™ÁéØ‰∫§ÁªáÔºåËÄÉÈ™åÊÑèÂøóÂäõ</span>
            </div>
            <div class="theme-item">
                <span class="theme-range">Á¨¨81-100ÂÖ≥</span>
                <span class="theme-desc">üî• ÁªàÊûÅËØïÁÇº - ÊâìÁ†¥Âæ™ÁéØÁöÑÊúÄÂêéËÄÉÈ™åÔºåÈáçÁîüÂú®Âç≥</span>
            </div>
        </div>
        <div id="trap-guide">
            <div class="trap-category">
                <h4>Âü∫Á°ÄÈô∑Èò±</h4>
                <div class="trap-item">
                    <span class="trap-icon">üß±</span>
                    <span class="trap-name">Áü©ÂΩ¢Èô∑Èò±</span>
                    <span class="trap-desc">ÈùôÊÄÅÈöúÁ¢çÁâ©ÔºåËß¶Á¢∞Âç≥Ê≠ªÔºåÈúÄË¶ÅÁªïË°å</span>
                </div>
                <div class="trap-item">
                    <span class="trap-icon">‚ö°</span>
                    <span class="trap-name">Â∞ñÂà∫Èô∑Èò±</span>
                    <span class="trap-desc">Âú∞Èù¢Â∞ñÂà∫ÔºåËß¶Á¢∞Âç≥Ê≠ª</span>
                </div>
                <div class="trap-item">
                    <span class="trap-icon">üî•</span>
                    <span class="trap-name">ÁßªÂä®Èô∑Èò±</span>
                    <span class="trap-desc">‰ºöÂú®Âú∫ÊôØ‰∏≠ÁßªÂä®ÁöÑÁÅ´ÁêÉÔºåËß¶Á¢∞Âç≥Ê≠ª</span>
                </div>
            </div>
            
            <div class="trap-category">
                <h4>ÁâπÊÆäÈô∑Èò± (Á¨¨3ÂÖ≥ÂºÄÂßãÂá∫Áé∞)</h4>
                <div class="trap-item">
                    <span class="trap-icon">üëª</span>
                    <span class="trap-name">ÈöêÂΩ¢Èô∑Èò±</span>
                    <span class="trap-desc">Èù†ËøëÊó∂ÊâçÊòæÁé∞ÔºåËß¶Á¢∞Âç≥Ê≠ª</span>
                </div>
                <div class="trap-item">
                    <span class="trap-icon">üåÄ</span>
                    <span class="trap-name">‰º†ÈÄÅÈô∑Èò±</span>
                    <span class="trap-desc">ÈöèÊú∫‰º†ÈÄÅÁé©ÂÆ∂Âà∞ÂÖ∂‰ªñ‰ΩçÁΩÆ</span>
                </div>
                <div class="trap-item">
                    <span class="trap-icon">üéØ</span>
                    <span class="trap-name">ËøΩË∏™Èô∑Èò±</span>
                    <span class="trap-desc">‰∏ªÂä®ËøΩË∏™Áé©ÂÆ∂ÔºåËß¶Á¢∞Âç≥Ê≠ª</span>
                </div>
                <div class="trap-item">
                    <span class="trap-icon">üßä</span>
                    <span class="trap-name">ÂÜ∞ÂÜªÈô∑Èò±</span>
                    <span class="trap-desc">ÂÜªÁªìÁé©ÂÆ∂3ÁßíÊó†Ê≥ïÁßªÂä®</span>
                </div>
                <div class="trap-item">
                    <span class="trap-icon">üí•</span>
                    <span class="trap-name">ÂàÜË£ÇÈô∑Èò±</span>
                    <span class="trap-desc">Ëß¶Á¢∞ÂêéÂàÜË£ÇÊàê4‰∏™Â∞èÈô∑Èò±</span>
                </div>
                <div class="trap-item">
                    <span class="trap-icon">üï≥Ô∏è</span>
                    <span class="trap-name">ÈáçÂäõÈô∑Èò±</span>
                    <span class="trap-desc">Âê∏ÂºïÁé©ÂÆ∂Âà∞‰∏≠ÂøÉÁÑ∂ÂêéÁàÜÁÇ∏</span>
                </div>
                <div class="trap-item">
                    <span class="trap-icon">ü™û</span>
                    <span class="trap-name">ÈïúÂÉèÈô∑Èò±</span>
                    <span class="trap-desc">‰∏éÁé©ÂÆ∂ÂÅöÁõ∏ÂèçÁßªÂä®ÔºåËß¶Á¢∞Âç≥Ê≠ª</span>
                </div>
                <div class="trap-item">
                    <span class="trap-icon">üí´</span>
                    <span class="trap-name">Èó™ÁÉÅÈô∑Èò±</span>
                    <span class="trap-desc">ÂÆöÊúüÊ∂àÂ§±ÂíåÂá∫Áé∞ÔºåÈöêÂΩ¢Êó∂Êó†ÂÆ≥</span>
                </div>
                <div class="trap-item">
                    <span class="trap-icon">üèÄ</span>
                    <span class="trap-name">ÂºπË∑≥Èô∑Èò±</span>
                    <span class="trap-desc">ÊääÁé©ÂÆ∂ÂºπÈ£ûÂà∞ÈöèÊú∫‰ΩçÁΩÆ</span>
                </div>
                <div class="trap-item">
                    <span class="trap-icon">üîç</span>
                    <span class="trap-name">Áº©Â∞èÈô∑Èò±</span>
                    <span class="trap-desc">ËÆ©Áé©ÂÆ∂ÂèòÂ∞è5Áßí</span>
                </div>
                <div class="trap-item">
                    <span class="trap-icon">‚ö°</span>
                    <span class="trap-name">Âä†ÈÄüÈô∑Èò±</span>
                    <span class="trap-desc">ËÆ©Áé©ÂÆ∂ÁßªÂä®ÈÄüÂ∫¶ÁøªÂÄç5Áßí</span>
                </div>
                <div class="trap-item">
                    <span class="trap-icon">üë•</span>
                    <span class="trap-name">ÂÖãÈöÜÈô∑Èò±</span>
                    <span class="trap-desc">ÂàõÂª∫Ë∑üÈöèÁé©ÂÆ∂ÁöÑÂàÜË∫´</span>
                </div>
            </div>
            
            <div class="trap-category">
                <h4>ÁâπÊÆäÂÖ≥Âç°Êú∫Âà∂</h4>
                <div class="trap-item">
                    <span class="trap-icon">üíé</span>
                    <span class="trap-name">Êî∂ÈõÜÊåëÊàò</span>
                    <span class="trap-desc">Êî∂ÈõÜÊâÄÊúâÊ∞¥Êô∂ÊâçËÉΩÈÄöÂÖ≥</span>
                </div>
                <div class="trap-item">
                    <span class="trap-icon">üóùÔ∏è</span>
                    <span class="trap-name">Èí•ÂåôÈó®</span>
                    <span class="trap-desc">Êî∂ÈõÜÈí•ÂåôËß£ÈîÅÈÄöÂÖ≥Êù°‰ª∂</span>
                </div>
                <div class="trap-item">
                    <span class="trap-icon">‚è∞</span>
                    <span class="trap-name">Êó∂Èó¥ÈôêÂà∂</span>
                    <span class="trap-desc">Âú®ÈôêÂÆöÊó∂Èó¥ÂÜÖÂà∞ËææÈó®Âè£</span>
                </div>
                <div class="trap-item">
                    <span class="trap-icon">üåë</span>
                    <span class="trap-name">ÈªëÊöóÊ®°Âºè</span>
                    <span class="trap-desc">Âè™ËÉΩÁúãÂà∞Áé©ÂÆ∂Âë®Âõ¥ÁöÑÂ∞èËåÉÂõ¥</span>
                </div>
                <div class="trap-item">
                    <span class="trap-icon">üîÑ</span>
                    <span class="trap-name">ÂèçÂêëÊéßÂà∂</span>
                    <span class="trap-desc">ÊñπÂêëÈîÆË¢´ÂèçËΩ¨</span>
                </div>
                <div class="trap-item">
                    <span class="trap-icon">üßä</span>
                    <span class="trap-name">ÊªëÂÜ∞Ê®°Âºè</span>
                    <span class="trap-desc">Âú∞Èù¢ÂæàÊªëÔºåÊúâÊÉØÊÄßÊïàÊûú</span>
                </div>
                <div class="trap-item">
                    <span class="trap-icon">üåÄ</span>
                    <span class="trap-name">‰º†ÈÄÅÈó®</span>
                    <span class="trap-desc">Ë∏©‰∏äÂéª‰ºö‰º†ÈÄÅÂà∞ÈöèÊú∫‰ΩçÁΩÆ</span>
                </div>
                <div class="trap-item">
                    <span class="trap-icon">üîò</span>
                    <span class="trap-name">Êú∫ÂÖ≥ÂºÄÂÖ≥</span>
                    <span class="trap-desc">ÊøÄÊ¥ªÊâÄÊúâÂºÄÂÖ≥ÊâçËÉΩÈÄöÂÖ≥</span>
                </div>
                <div class="trap-item">
                    <span class="trap-icon">üîÑ</span>
                    <span class="trap-name">ÈáçÂäõÁøªËΩ¨</span>
                    <span class="trap-desc">‰∏ä‰∏ãÊñπÂêëË¢´È¢†ÂÄí</span>
                </div>
                <div class="trap-item">
                    <span class="trap-icon">üëª</span>
                    <span class="trap-name">ÈöêÂΩ¢Áä∂ÊÄÅ</span>
                    <span class="trap-desc">Áé©ÂÆ∂ÂèòÂæóÂçäÈÄèÊòé</span>
                </div>
                <div class="trap-item">
                    <span class="trap-icon">üí®</span>
                    <span class="trap-name">È£éÂäõÊïàÊûú</span>
                    <span class="trap-desc">È£é‰ºöÊé®Âä®Áé©ÂÆ∂ÁßªÂä®</span>
                </div>
                <div class="trap-item">
                    <span class="trap-icon">üöÄ</span>
                    <span class="trap-name">ÁßªÂä®Âπ≥Âè∞</span>
                    <span class="trap-desc">ÂèØ‰ª•Á´ôÂú®‰∏äÈù¢ÁßªÂä®ÁöÑÂπ≥Âè∞</span>
                </div>
            </div>
        </div>
        <button id="close-help-btn">ÂÖ≥Èó≠</button>
    </div>

    <script>
        // Ê∏∏ÊàèÁä∂ÊÄÅ
        const gameState = {
            currentLevel: 1,
            maxLevel: 10,
            maxUnlockedLevel: 1, // ÊúÄÈ´òËß£ÈîÅÂÖ≥Âç°
            player: { x: 50, y: 250 },
            isMoving: false,
            gameOver: false,
            traps: [],
            movingTraps: [],
            specialTraps: [], // ÁâπÊÆäÈô∑Èò±Êï∞ÁªÑ
            playerFrozen: false, // Áé©ÂÆ∂ÊòØÂê¶Ë¢´ÂÜ∞ÂÜª
            freezeEndTime: 0, // ÂÜ∞ÂÜªÁªìÊùüÊó∂Èó¥
            levelLayouts: {}, // Â≠òÂÇ®ÊØèÂÖ≥ÁöÑÈô∑Èò±Â∏ÉÂ±Ä
            loopCount: 0, // ÂΩìÂâçÂÖ≥Âç°ÁöÑÂæ™ÁéØÊ¨°Êï∞
            levelLoopCounts: {}, // ÊØè‰∏™ÂÖ≥Âç°ÁöÑÂæ™ÁéØÊ¨°Êï∞ËÆ∞ÂΩï
            // ÁâπÊÆäÂÖ≥Âç°Êú∫Âà∂
            specialMechanics: {
                isInvisible: false,        // Áé©ÂÆ∂ÈöêÂΩ¢
                isReversed: false,         // ÂèçÂêëÊéßÂà∂
                isGravityFlipped: false,   // ÈáçÂäõÁøªËΩ¨
                collectibles: [],          // Êî∂ÈõÜÂìÅ
                keys: 0,                   // Èí•ÂåôÊï∞Èáè
                requiredKeys: 0,           // ÈúÄË¶ÅÁöÑÈí•ÂåôÊï∞Èáè
                timeLimit: 0,              // Êó∂Èó¥ÈôêÂà∂ÔºàÁßíÔºâ
                startTime: 0,              // ÂÖ≥Âç°ÂºÄÂßãÊó∂Èó¥
                isDarkMode: false,         // ÈªëÊöóÊ®°Âºè
                lightRadius: 100,          // ÂÖâÁÖßÂçäÂæÑ
                isSlippery: false,         // ÊªëÂÜ∞Ê®°Âºè
                momentum: { x: 0, y: 0 },  // ÊªëÂÜ∞Âä®Èáè
                teleporters: [],           // ‰º†ÈÄÅÈó®
                switches: [],              // ÂºÄÂÖ≥
                movingPlatforms: [],       // ÁßªÂä®Âπ≥Âè∞
                windForce: { x: 0, y: 0 }  // È£éÂäõ
            }
        };

        // Êú¨Âú∞Â≠òÂÇ®Áõ∏ÂÖ≥ÂáΩÊï∞
        function saveProgress() {
            try {
                localStorage.setItem('wizardGame_maxLevel', gameState.maxUnlockedLevel);
                localStorage.setItem('wizardGame_currentLevel', gameState.currentLevel);
            } catch (e) {
                console.log('Êó†Ê≥ï‰øùÂ≠òËøõÂ∫¶:', e);
            }
        }

        function loadProgress() {
            try {
                const savedMaxLevel = localStorage.getItem('wizardGame_maxLevel');
                const savedCurrentLevel = localStorage.getItem('wizardGame_currentLevel');
                
                if (savedMaxLevel) {
                    gameState.maxUnlockedLevel = parseInt(savedMaxLevel);
                }
                if (savedCurrentLevel) {
                    gameState.currentLevel = Math.min(parseInt(savedCurrentLevel), gameState.maxUnlockedLevel);
                }
            } catch (e) {
                console.log('Êó†Ê≥ïÂä†ËΩΩËøõÂ∫¶:', e);
            }
        }

        function resetProgress() {
            try {
                localStorage.removeItem('wizardGame_maxLevel');
                localStorage.removeItem('wizardGame_currentLevel');
                gameState.maxUnlockedLevel = 1;
                gameState.currentLevel = 1;
            } catch (e) {
                console.log('Êó†Ê≥ïÈáçÁΩÆËøõÂ∫¶:', e);
            }
        }

        // DOMÂÖÉÁ¥†
        const levelDisplay = document.getElementById('level');
        const maxLevelDisplay = document.getElementById('max-level');
        const unlockedLevelsDisplay = document.getElementById('unlocked-levels');
        const messageDisplay = document.getElementById('message');
        const loopCounterDisplay = document.getElementById('loop-counter');
        const loopCountDisplay = document.getElementById('loop-count');
        const gameContainer = document.getElementById('game-container');
        const player = document.getElementById('player');
        const door = document.getElementById('door');
        const nextBtn = document.getElementById('next-btn');
        const restartBtn = document.getElementById('restart-btn');
        const levelSelectBtn = document.getElementById('level-select-btn');
        const soundToggleBtn = document.getElementById('sound-toggle-btn');
        const musicToggleBtn = document.getElementById('music-toggle-btn');
        const resetProgressBtn = document.getElementById('reset-progress-btn');
        const levelSelectModal = document.getElementById('level-select');
        const levelButtonsContainer = document.getElementById('level-buttons');
        const closeSelectBtn = document.getElementById('close-select-btn');
        const helpBtn = document.getElementById('help-btn');
        const helpModal = document.getElementById('help-modal');
        const closeHelpBtn = document.getElementById('close-help-btn');

        // Ê∏∏ÊàèÂèòÈáè
        let gameWidth = 800;
        let gameHeight = 500;
        let doorRect = door.getBoundingClientRect();
        let basePlayerSpeed = 8;
        let playerSpeed = 8;
        let animationFrame;
        let trapInterval;
        
        // Èü≥ÊïàÁ≥ªÁªü
        let audioContext;
        let soundEnabled = true;
        
        // ËÉåÊôØÈü≥‰πêÁ≥ªÁªü
        let backgroundMusic;
        let musicEnabled = true;
        let musicVolume = 0.1; // ËÉåÊôØÈü≥‰πêÈü≥ÈáèÔºà10%Ôºâ

        // ÂàùÂßãÂåñÈü≥È¢ë‰∏ä‰∏ãÊñá
        function initAudio() {
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                // ‰ªéÊú¨Âú∞Â≠òÂÇ®Âä†ËΩΩÈü≥ÊïàËÆæÁΩÆ
                const savedSoundSetting = localStorage.getItem('wizardGame_soundEnabled');
                if (savedSoundSetting !== null) {
                    soundEnabled = savedSoundSetting === 'true';
                }
                updateSoundButton();
                
                // ÂàùÂßãÂåñËÉåÊôØÈü≥‰πê
                initBackgroundMusic();
            } catch (e) {
                console.log('Èü≥È¢ë‰∏çÊîØÊåÅ:', e);
                soundEnabled = false;
                updateSoundButton();
            }
        }

        // ÂàùÂßãÂåñËÉåÊôØÈü≥‰πê
        function initBackgroundMusic() {
            try {
                // Â∞ùËØïÂ§öÁßçÂèØËÉΩÁöÑÊñá‰ª∂Âêç
                const possiblePaths = [
                    'background_music.wav',
                    'backgroud_music.wav', // Áî®Êà∑ÊèêÂà∞ÁöÑÂéüÂßãÂêçÁß∞ÔºàÂèØËÉΩÊúâÊãºÂÜôÈîôËØØÔºâ
                    './background_music.wav',
                    './backgroud_music.wav'
                ];
                
                backgroundMusic = new Audio();
                backgroundMusic.loop = true; // Âæ™ÁéØÊí≠Êîæ
                backgroundMusic.volume = musicVolume;
                
                // ‰ªéÊú¨Âú∞Â≠òÂÇ®Âä†ËΩΩÈü≥‰πêËÆæÁΩÆ
                const savedMusicSetting = localStorage.getItem('wizardGame_musicEnabled');
                const savedMusicVolume = localStorage.getItem('wizardGame_musicVolume');
                
                if (savedMusicSetting !== null) {
                    musicEnabled = savedMusicSetting === 'true';
                }
                // Âõ∫ÂÆöÈü≥Èáè‰∏∫10%Ôºå‰∏ç‰ªéÊú¨Âú∞Â≠òÂÇ®ËØªÂèñ
                musicVolume = 0.1;
                backgroundMusic.volume = musicVolume;
                
                // Ê∑ªÂä†Èü≥È¢ë‰∫ã‰ª∂ÁõëÂê¨Âô®
                backgroundMusic.addEventListener('loadstart', () => {
                    console.log('ÂºÄÂßãÂä†ËΩΩËÉåÊôØÈü≥‰πê...');
                });
                
                backgroundMusic.addEventListener('canplaythrough', () => {
                    console.log('ËÉåÊôØÈü≥‰πêÂä†ËΩΩÂÆåÊàêÔºåÂèØ‰ª•Êí≠Êîæ');
                    updateMusicButton();
                    if (musicEnabled && !firstInteraction) {
                        playBackgroundMusic();
                    }
                });
                
                backgroundMusic.addEventListener('error', (e) => {
                    console.log('ËÉåÊôØÈü≥‰πêÂä†ËΩΩÂ§±Ë¥•:', e);
                    console.log('ÂΩìÂâçÂ∞ùËØïÁöÑÊñá‰ª∂Ë∑ØÂæÑ:', backgroundMusic.src);
                    // Â∞ùËØï‰∏ã‰∏Ä‰∏™Êñá‰ª∂Ë∑ØÂæÑ
                    tryNextMusicPath();
                });
                
                backgroundMusic.addEventListener('play', () => {
                    console.log('ËÉåÊôØÈü≥‰πêÂºÄÂßãÊí≠Êîæ');
                });
                
                backgroundMusic.addEventListener('pause', () => {
                    console.log('ËÉåÊôØÈü≥‰πêÊöÇÂÅú');
                });
                
                // ÂºÄÂßãÂ∞ùËØïÂä†ËΩΩÁ¨¨‰∏Ä‰∏™Ë∑ØÂæÑ
                let currentPathIndex = 0;
                
                function tryNextMusicPath() {
                    if (currentPathIndex < possiblePaths.length) {
                        const path = possiblePaths[currentPathIndex];
                        console.log('Â∞ùËØïÂä†ËΩΩÈü≥‰πêÊñá‰ª∂:', path);
                        backgroundMusic.src = path;
                        backgroundMusic.load();
                        currentPathIndex++;
                    } else {
                        console.log('ÊâÄÊúâÈü≥‰πêÊñá‰ª∂Ë∑ØÂæÑÈÉΩÂ∞ùËØïÂ§±Ë¥•');
                        musicEnabled = false;
                        updateMusicButton();

                    }
                }
                
                // ÂºÄÂßãÂ∞ùËØïÁ¨¨‰∏Ä‰∏™Ë∑ØÂæÑ
                tryNextMusicPath();
                
                updateMusicButton();
                
            } catch (e) {
                console.log('ËÉåÊôØÈü≥‰πêÂàùÂßãÂåñÂ§±Ë¥•:', e);
                musicEnabled = false;
                updateMusicButton();
            }
        }

        // Êí≠ÊîæËÉåÊôØÈü≥‰πê
        function playBackgroundMusic() {
            if (backgroundMusic && musicEnabled) {
                console.log('Â∞ùËØïÊí≠ÊîæËÉåÊôØÈü≥‰πê, Èü≥Èáè:', backgroundMusic.volume);
                console.log('Èü≥‰πêÊñá‰ª∂Áä∂ÊÄÅ:', {
                    src: backgroundMusic.src,
                    readyState: backgroundMusic.readyState,
                    paused: backgroundMusic.paused,
                    currentTime: backgroundMusic.currentTime,
                    duration: backgroundMusic.duration
                });
                
                backgroundMusic.play().then(() => {
                    console.log('ËÉåÊôØÈü≥‰πêÊí≠ÊîæÊàêÂäü');
                }).catch(e => {
                    console.log('ËÉåÊôØÈü≥‰πêÊí≠ÊîæÂ§±Ë¥•:', e);
                    if (e.name === 'NotAllowedError') {
                        console.log('ÊµèËßàÂô®ÈòªÊ≠¢‰∫ÜËá™Âä®Êí≠ÊîæÔºåÈúÄË¶ÅÁî®Êà∑‰∫§‰∫í');

                    }
                });
            } else {
                console.log('Êí≠ÊîæÊù°‰ª∂‰∏çÊª°Ë∂≥:', {
                    hasBackgroundMusic: !!backgroundMusic,
                    musicEnabled: musicEnabled
                });
            }
        }

        // ÊöÇÂÅúËÉåÊôØÈü≥‰πê
        function pauseBackgroundMusic() {
            if (backgroundMusic) {
                backgroundMusic.pause();
            }
        }

        // ÂàáÊç¢ËÉåÊôØÈü≥‰πêÂºÄÂÖ≥
        function toggleMusic() {
            musicEnabled = !musicEnabled;
            localStorage.setItem('wizardGame_musicEnabled', musicEnabled);
            
            if (musicEnabled) {
                console.log('Áî®Êà∑ÊâãÂä®ÂêØÁî®ËÉåÊôØÈü≥‰πê');
                playBackgroundMusic();
            } else {
                console.log('Áî®Êà∑ÊâãÂä®Á¶ÅÁî®ËÉåÊôØÈü≥‰πê');
                pauseBackgroundMusic();
            }
            
            updateMusicButton();
        }



        // ÂàáÊç¢Èü≥ÊïàÂºÄÂÖ≥
        function toggleSound() {
            soundEnabled = !soundEnabled;
            localStorage.setItem('wizardGame_soundEnabled', soundEnabled);
            updateSoundButton();
            
            // Êí≠ÊîæÊµãËØïÈü≥Êïà
            if (soundEnabled) {
                playClickSound();
            }
        }

        // Êõ¥Êñ∞Èü≥ÊïàÊåâÈíÆÊòæÁ§∫
        function updateSoundButton() {
            if (soundToggleBtn) {
                soundToggleBtn.textContent = soundEnabled ? 'üîä Èü≥Êïà' : 'üîá Èü≥Êïà';
                soundToggleBtn.style.opacity = soundEnabled ? '1' : '0.6';
            }
        }

        // Êõ¥Êñ∞ËÉåÊôØÈü≥‰πêÊåâÈíÆÊòæÁ§∫
        function updateMusicButton() {
            if (musicToggleBtn) {
                musicToggleBtn.textContent = musicEnabled ? 'üéµ Èü≥‰πê' : 'üîá Èü≥‰πê';
                musicToggleBtn.style.opacity = musicEnabled ? '1' : '0.6';
            }
        }



        // ÁîüÊàêÁàÜÁÇ∏Èü≥Êïà
        function playExplosionSound() {
            if (!soundEnabled || !audioContext) return;
            
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            // ÁàÜÁÇ∏Èü≥ÊïàÔºö‰ΩéÈ¢ëÂô™Èü≥
            oscillator.type = 'sawtooth';
            oscillator.frequency.setValueAtTime(150, audioContext.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(50, audioContext.currentTime + 0.5);
            
            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
            
            oscillator.start();
            oscillator.stop(audioContext.currentTime + 0.5);
        }

        // ÁîüÊàêËøáÂÖ≥Èü≥Êïà
        function playSuccessSound() {
            if (!soundEnabled || !audioContext) return;
            
            // Êí≠Êîæ‰∏ÄÁ≥ªÂàó‰∏äÂçáÁöÑÈü≥Á¨¶
            const notes = [523.25, 659.25, 783.99, 1046.50]; // C5, E5, G5, C6
            
            notes.forEach((frequency, index) => {
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime + index * 0.15);
                
                gainNode.gain.setValueAtTime(0, audioContext.currentTime + index * 0.15);
                gainNode.gain.linearRampToValueAtTime(0.2, audioContext.currentTime + index * 0.15 + 0.05);
                gainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + index * 0.15 + 0.3);
                
                oscillator.start(audioContext.currentTime + index * 0.15);
                oscillator.stop(audioContext.currentTime + index * 0.15 + 0.3);
            });
        }

        // ÁîüÊàêÊåâÈîÆÈü≥Êïà
        function playClickSound() {
            if (!soundEnabled || !audioContext) return;
            
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.type = 'square';
            oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(600, audioContext.currentTime + 0.1);
            
            gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
            
            oscillator.start();
            oscillator.stop(audioContext.currentTime + 0.1);
        }
        
        // ÈîÆÁõòÁä∂ÊÄÅËøΩË∏™
        const keys = {
            ArrowUp: false,
            ArrowDown: false,
            ArrowLeft: false,
            ArrowRight: false
        };

        // Êõ¥Êñ∞ËøõÂ∫¶ÊòæÁ§∫
        function updateProgressDisplay() {
            maxLevelDisplay.textContent = gameState.maxUnlockedLevel;
            unlockedLevelsDisplay.textContent = gameState.maxUnlockedLevel;
        }

        // ÂàõÂª∫ÂÖ≥Âç°ÈÄâÊã©ÊåâÈíÆ
        function createLevelButtons() {
            levelButtonsContainer.innerHTML = '';
            
            for (let i = 1; i <= gameState.maxLevel; i++) {
                const btn = document.createElement('button');
                btn.textContent = i;
                btn.className = 'level-btn';
                
                if (i <= gameState.maxUnlockedLevel) {
                    if (i === gameState.currentLevel) {
                        btn.className += ' current';
                    } else {
                        btn.className += ' unlocked';
                    }
                    btn.onclick = () => selectLevel(i);
                } else {
                    btn.className += ' locked';
                    btn.disabled = true;
                }
                
                levelButtonsContainer.appendChild(btn);
            }
        }

        // ÈÄâÊã©ÂÖ≥Âç°
        function selectLevel(level) {
            if (level <= gameState.maxUnlockedLevel) {
                playClickSound();
                gameState.currentLevel = level;
                saveProgress();
                levelSelectModal.classList.add('hidden');
                startLevel();
            }
        }

        // ÂºÄÂßãÂÖ≥Âç°
        function startLevel() {
            gameState.gameOver = false;
            gameState.player = { x: 50, y: 250 };
            gameState.traps = [];
            gameState.movingTraps = [];
            
            messageDisplay.textContent = '';
            nextBtn.classList.add('hidden');
            
            // Ê∏ÖÈô§‰πãÂâçÁöÑÈô∑Èò±
            document.querySelectorAll('.trap, .spike, .moving-trap, .hidden-mine, .maze-wall').forEach(el => el.remove());
            
            updatePlayerPosition();
            setupLevel();
            updateProgressDisplay();
        }

        // ÂàùÂßãÂåñÊ∏∏Êàè
        function initGame() {
            // ÂàùÂßãÂåñÈü≥È¢ëÁ≥ªÁªü
            initAudio();
            
            // Âä†ËΩΩ‰øùÂ≠òÁöÑËøõÂ∫¶
            loadProgress();
            
            gameState.gameOver = false;
            gameState.player = { x: 50, y: 250 };
            gameState.traps = [];
            gameState.movingTraps = [];
            
            messageDisplay.textContent = '';
            nextBtn.classList.add('hidden');
            
            // Á°Æ‰øùÂÖ≥Âç°ÈÄâÊã©Âô®ÊòØÈöêËóèÁöÑ
            levelSelectModal.classList.add('hidden');
            
            updatePlayerPosition();
            setupLevel();
            updateProgressDisplay();
            
            // Ê∏ÖÈô§‰πãÂâçÁöÑÈô∑Èò±
            document.querySelectorAll('.trap, .spike, .moving-trap, .hidden-mine, .maze-wall').forEach(el => el.remove());
        }

        // ËÆæÁΩÆÂΩìÂâçÂÖ≥Âç°
        function setupLevel() {
            levelDisplay.textContent = gameState.currentLevel;
            
            // Ê†πÊçÆÂÖ≥Âç°Ë∞ÉÊï¥Áé©ÂÆ∂ÁßªÂä®ÈÄüÂ∫¶ÔºàÈ´òÂÖ≥Âç°Á®çÂæÆÂø´‰∏ÄÁÇπ‰ª•Â∫îÂØπÊõ¥Â§öÈô∑Èò±Ôºâ
            playerSpeed = basePlayerSpeed + Math.floor(gameState.currentLevel / 20);
            
            // ÂàùÂßãÂåñÂæ™ÁéØËÆ°Êï∞Âô®
            initLoopCounter();
            
            // ÈáçÁΩÆÁâπÊÆäÊú∫Âà∂
            resetSpecialMechanics();
            
            // ËÆæÁΩÆÁâπÊÆäÂÖ≥Âç°Êú∫Âà∂
            setupSpecialMechanics();
            
            // ÊòæÁ§∫ÂÖ≥Âç°‰∏ªÈ¢òÊèêÁ§∫
            showLevelTheme();
            
            // Êõ¥Êñ∞Èó®ÁöÑ‰ΩçÁΩÆ
            updateDoorPosition();
            
            // Ê†πÊçÆÂÖ≥Âç°ËÆæÁΩÆÈô∑Èò±ÔºàÁîüÊàêÊñ∞Â∏ÉÂ±ÄÔºâ
            createTraps(false);
            
            // ËÆæÁΩÆÁßªÂä®Èô∑Èò±ÔºàÁîüÊàêÊñ∞Â∏ÉÂ±ÄÔºâ
            setupMovingTraps(false);
        }

        // ÈáçÁΩÆÁâπÊÆäÊú∫Âà∂
        function resetSpecialMechanics() {
            const sm = gameState.specialMechanics;
            sm.isInvisible = false;
            sm.isReversed = false;
            sm.isGravityFlipped = false;
            sm.collectibles = [];
            sm.keys = 0;
            sm.requiredKeys = 0;
            sm.timeLimit = 0;
            sm.startTime = 0;
            sm.isDarkMode = false;
            sm.lightRadius = 100;
            sm.isSlippery = false;
            sm.momentum = { x: 0, y: 0 };
            sm.teleporters = [];
            sm.switches = [];
            sm.movingPlatforms = [];
            sm.windForce = { x: 0, y: 0 };
            
            // Ê∏ÖÈô§UIÂÖÉÁ¥†
            document.querySelectorAll('.collectible, .key-item, .teleporter, .switch, .moving-platform, .timer-display').forEach(el => el.remove());
            
            // ÈáçÁΩÆÁé©ÂÆ∂Ê†∑Âºè
            player.classList.remove('player-invisible', 'gravity-flipped');
            gameContainer.classList.remove('dark-mode', 'slippery-mode');
        }
        
        // ËÆæÁΩÆÁâπÊÆäÂÖ≥Âç°Êú∫Âà∂
        function setupSpecialMechanics() {
            const level = gameState.currentLevel;
            const sm = gameState.specialMechanics;
            
            // Á¨¨5ÂÖ≥ÔºöÊî∂ÈõÜÈíªÁü≥ÂÖ≥Âç°
            if (level === 5) {
                createCollectibles(3);
            }
            // Á¨¨8ÂÖ≥ÔºöÈí•ÂåôÈó®ÂÖ≥Âç°
            else if (level === 8) {
                sm.requiredKeys = 2;
                createKeys(2);
            }
            // Á¨¨12ÂÖ≥ÔºöÊó∂Èó¥ÈôêÂà∂ÂÖ≥Âç°
            else if (level === 12) {
                sm.timeLimit = 15; // 15ÁßíÈôêÂà∂
                sm.startTime = Date.now();
                createTimerDisplay();
            }
            // Á¨¨15ÂÖ≥ÔºöÈªëÊöóÂÖ≥Âç°
            else if (level === 15) {
                sm.isDarkMode = true;
                sm.lightRadius = 80;
                gameContainer.classList.add('dark-mode');
            }
            // Á¨¨18ÂÖ≥ÔºöÂèçÂêëÊéßÂà∂ÂÖ≥Âç°
            else if (level === 18) {
                sm.isReversed = true;
            }
            // Á¨¨22ÂÖ≥ÔºöÊªëÂÜ∞ÂÖ≥Âç°
            else if (level === 22) {
                sm.isSlippery = true;
                gameContainer.classList.add('slippery-mode');
            }
            // Á¨¨25ÂÖ≥Ôºö‰º†ÈÄÅÈó®ÂÖ≥Âç°
            else if (level === 25) {
                createTeleporters(2);
            }
            // Á¨¨28ÂÖ≥ÔºöÂºÄÂÖ≥Èó®ÂÖ≥Âç°
            else if (level === 28) {
                createSwitches(3);
            }
            // Á¨¨32ÂÖ≥ÔºöÈáçÂäõÁøªËΩ¨ÂÖ≥Âç°
            else if (level === 32) {
                sm.isGravityFlipped = true;
                player.classList.add('gravity-flipped');
            }
            // Á¨¨35ÂÖ≥ÔºöÁé©ÂÆ∂ÈöêÂΩ¢ÂÖ≥Âç°
            else if (level === 35) {
                sm.isInvisible = true;
                player.classList.add('player-invisible');
            }
            // Á¨¨40ÂÖ≥ÔºöÈ£éÂäõÂÖ≥Âç°
            else if (level === 40) {
                sm.windForce = { x: 2, y: 0 }; // ÂêëÂè≥ÁöÑÈ£é
            }
            // Á¨¨45ÂÖ≥ÔºöÁßªÂä®Âπ≥Âè∞ÂÖ≥Âç°
            else if (level === 45) {
                createMovingPlatforms(2);
            }
            // Á¨¨50ÂÖ≥ÔºöÁªºÂêàÊåëÊàò
            else if (level === 50) {
                sm.timeLimit = 20;
                sm.startTime = Date.now();
                sm.requiredKeys = 1;
                createTimerDisplay();
                createKeys(1);
                createCollectibles(2);
            }
            // Á¨¨55ÂÖ≥ÔºöÂ§öÈáç‰º†ÈÄÅËø∑ÂÆ´
            else if (level === 55) {
                createTeleporters(4);
                sm.isDarkMode = true;
                gameContainer.classList.add('dark-mode');
            }
            // Á¨¨60ÂÖ≥ÔºöÊûÅÈÄüÊåëÊàò
            else if (level === 60) {
                sm.timeLimit = 10;
                sm.startTime = Date.now();
                sm.isSlippery = true;
                createTimerDisplay();
                gameContainer.classList.add('slippery-mode');
            }
            // Á¨¨65ÂÖ≥ÔºöÈöêÂΩ¢Ê≥ïÂ∏à
            else if (level === 65) {
                sm.isInvisible = true;
                sm.isReversed = true;
                player.classList.add('player-invisible');
            }
            // Á¨¨70ÂÖ≥ÔºöÈ£éÊö¥‰∏≠ÂøÉ
            else if (level === 70) {
                sm.windForce = { x: 3, y: 2 };
                sm.timeLimit = 25;
                sm.startTime = Date.now();
                createTimerDisplay();
            }
            // Á¨¨75ÂÖ≥ÔºöÈáçÂäõÊ∑∑‰π±
            else if (level === 75) {
                sm.isGravityFlipped = true;
                sm.isSlippery = true;
                player.classList.add('gravity-flipped');
                gameContainer.classList.add('slippery-mode');
            }
            // Á¨¨80ÂÖ≥ÔºöÁªàÊûÅÊú∫ÂÖ≥
            else if (level === 80) {
                createSwitches(5);
                sm.timeLimit = 30;
                sm.startTime = Date.now();
                createTimerDisplay();
                sm.isDarkMode = true;
                gameContainer.classList.add('dark-mode');
            }
            // Á¨¨85ÂÖ≥ÔºöËÆ∞ÂøÜËØïÁÇº
            else if (level === 85) {
                createCollectibles(5);
                createKeys(3);
                sm.requiredKeys = 3;
                sm.isReversed = true;
            }
            // Á¨¨90ÂÖ≥ÔºöÊó∂Á©∫Êâ≠Êõ≤
            else if (level === 90) {
                sm.timeLimit = 15;
                sm.startTime = Date.now();
                createTimerDisplay();
                createTeleporters(3);
                sm.windForce = { x: -2, y: 1 };
                sm.isSlippery = true;
                gameContainer.classList.add('slippery-mode');
            }
            // Á¨¨95ÂÖ≥ÔºöÊúÄÁªàËÄÉÈ™åÂâçÂ•è
            else if (level === 95) {
                createCollectibles(3);
                createKeys(2);
                sm.requiredKeys = 2;
                createSwitches(3);
                sm.timeLimit = 35;
                sm.startTime = Date.now();
                createTimerDisplay();
                sm.isDarkMode = true;
                gameContainer.classList.add('dark-mode');
            }
            // Á¨¨99ÂÖ≥ÔºöÁªàÊûÅÂâçÂ§ú
            else if (level === 99) {
                sm.isInvisible = true;
                sm.isReversed = true;
                sm.isGravityFlipped = true;
                sm.isSlippery = true;
                sm.timeLimit = 20;
                sm.startTime = Date.now();
                createTimerDisplay();
                createTeleporters(2);
                sm.windForce = { x: 2, y: -1 };
                player.classList.add('player-invisible', 'gravity-flipped');
                gameContainer.classList.add('dark-mode', 'slippery-mode');
            }
            // Á¨¨100ÂÖ≥ÔºöÈáçÁîü‰πãÈó®
            else if (level === 100) {
                // ÊúÄÁªàÂÖ≥Âç°ÔºöÊâÄÊúâÊú∫Âà∂ÁöÑÁªàÊûÅÁªÑÂêà
                createCollectibles(1); // Âè™ÈúÄË¶Å1‰∏™ÁâπÊÆäÊ∞¥Êô∂
                createKeys(1);
                sm.requiredKeys = 1;
                createSwitches(1);
                createTeleporters(1);
                sm.timeLimit = 60; // ÁªôË∂≥Â§üÊó∂Èó¥
                sm.startTime = Date.now();
                createTimerDisplay();
                // ‰∏çÊ∑ªÂä†Â§™Â§öÂπ≤Êâ∞ÔºåËÆ©Áé©ÂÆ∂‰∏ìÊ≥®‰∫éÊúÄÂêéÁöÑÊåëÊàò
            }
            
            // È´òÁ∫ßÂÖ≥Âç°ÁöÑÈöèÊú∫ÁâπÊÆäÊú∫Âà∂ (ÊØè10ÂÖ≥‰∏ÄÊ¨°ÁâπÊÆäÊú∫Âà∂)
            if (level > 60 && level % 10 === 0 && ![70, 80, 90, 100].includes(level)) {
                const randomMechanics = [
                    () => { sm.isDarkMode = true; gameContainer.classList.add('dark-mode'); },
                    () => { sm.isReversed = true; },
                    () => { sm.isSlippery = true; gameContainer.classList.add('slippery-mode'); },
                    () => { sm.windForce = { x: Math.random() * 4 - 2, y: Math.random() * 4 - 2 }; },
                    () => { createTeleporters(Math.floor(Math.random() * 3) + 1); },
                    () => { 
                        sm.timeLimit = 20 + Math.random() * 10; 
                        sm.startTime = Date.now(); 
                        createTimerDisplay(); 
                    }
                ];
                
                const randomMechanic = randomMechanics[Math.floor(Math.random() * randomMechanics.length)];
                randomMechanic();
            }
        }
        
        // ÊòæÁ§∫ÂÖ≥Âç°‰∏ªÈ¢ò
        function showLevelTheme() {
            let themeMessage = '';
            
            if (gameState.currentLevel === 1) {
                showDialogue([
                    'üè¢ ÂâçÂè∞',
                    '‰Ω†Ë¢´Âõ∞Âú®‰∫ÜMTÔºåËøôÂ∑≤ÁªèÊòØ‰Ω†Á¨¨16Ê¨°Âæ™ÁéØ‰∫ÜÔºÅÔºÅÔºÅ',
                    '‰Ω†‰∏çÁü•ÈÅìÂèëÁîü‰∫Ü‰ªÄ‰πàÔºå‰ΩÜÊòØ‰Ω†ÁöÑÁõ¥ËßâÂëäËØâ‰Ω†Ôºå',
                    '‰∏ÄÂÆöÊúâ‰ªÄ‰πàÈáçË¶ÅÁöÑ‰ªªÂä°Á≠âÁùÄ‰Ω†„ÄÇ',
                    '‰∏çË¶ÅÈóÆ‰∏∫‰ªÄ‰πàÔºåÊØïÁ´üÁîµËßÜÂâßÈáå‰∏ÄËà¨ÈÉΩÊòØËøô‰πàÊºîÁöÑ„ÄÇ'
                ]);
                return;
            } else if (gameState.currentLevel === 2) {
                showDialogue([
                    'üçö Á¨¨‰∏ÄÈ£üÂ†Ç',
                    'Âæ™ÁéØÔºüÂºÄ‰ªÄ‰πàÁé©Á¨ëÔºü',
                    '‰Ωú‰∏∫‰∏Ä‰∏™ÊâìÂ∑•‰∫∫ÔºåËøòÊòØÂπ≤È•≠ÈáçË¶ÅÔºÅ',
                    '12ÁÇπÂçä‰∫ÜÔºåÂÜ≤ÔºÅÔºÅÔºÅ',
                    '‚ö†Ô∏è Â∞èÂøÉÂú∞Èù¢ÁöÑÈöêÂΩ¢Âú∞Èõ∑ÔºÅ'
                ]);
                return;
            } else if (gameState.currentLevel >= 3 && gameState.currentLevel <= 10) {
                themeMessage = 'üëª ÂπªË±°Ëø∑ÂÆ´ÔºöËôöÂÆûÈöæËæ®ÁöÑÂπªÂ¢ÉËÄÉÈ™åÁùÄ‰Ω†ÁöÑÊÑüÁü•';
            } else if (gameState.currentLevel >= 11 && gameState.currentLevel <= 20) {
                themeMessage = 'üßä ÂÜ∞Â∞ÅÁåéÂú∫ÔºöÂØíÂÜ∞‰∏éËøΩÁåéËÄÖÁöÑËá¥ÂëΩËàûËπà';
            } else if (gameState.currentLevel >= 21 && gameState.currentLevel <= 30) {
                themeMessage = 'üí• Â¥©ÂùèÁ©∫Èó¥ÔºöÁé∞ÂÆûÂºÄÂßãÂàÜË£ÇÔºåÈáçÂäõÂ§±ÂéªÊéßÂà∂';
            } else if (gameState.currentLevel >= 31 && gameState.currentLevel <= 40) {
                themeMessage = 'ü™û ÈïúÂÉè‰∏ñÁïåÔºöÂú®ÂèçËΩ¨ÁöÑÁé∞ÂÆû‰∏≠ÂØªÊâæÁúüÁõ∏';
            } else if (gameState.currentLevel >= 41 && gameState.currentLevel <= 60) {
                themeMessage = '‚ö° Êó∂Á©∫‰π±ÊµÅÔºöÊó∂Èó¥‰∏éÁ©∫Èó¥ÁöÑÊâ≠Êõ≤ÊîπÂèòÁùÄ‰∏ÄÂàá';
            } else if (gameState.currentLevel >= 61 && gameState.currentLevel <= 80) {
                themeMessage = 'üåÄ Âæ™ÁéØÊ∑±Ê∏äÔºöÂ§öÈáçÂæ™ÁéØ‰∫§ÁªáÔºåËÄÉÈ™åÁùÄ‰Ω†ÁöÑÊÑèÂøó';
            } else if (gameState.currentLevel >= 81) {
                themeMessage = 'üî• ÁªàÊûÅËØïÁÇºÔºöÊâìÁ†¥Âæ™ÁéØÁöÑÊúÄÂêéËÄÉÈ™åÔºåÈáçÁîüÂú®Âç≥';
            }
            
            // ÁâπÊÆäÂÖ≥Âç°ÁöÑÁâπÊÆäÊèêÁ§∫
            const sm = gameState.specialMechanics;
            if (gameState.currentLevel === 5) {
                themeMessage = 'üíé ËÆ∞ÂøÜÊ∞¥Êô∂ÔºöÊî∂ÈõÜÊâÄÊúâÊ∞¥Êô∂ÊÅ¢Â§çËÆ∞ÂøÜ';
            } else if (gameState.currentLevel === 8) {
                themeMessage = 'üóùÔ∏è Â∞ÅÂç∞‰πãÈó®ÔºöÂØªÊâæÈí•ÂåôËß£ÂºÄÂ∞ÅÂç∞';
            } else if (gameState.currentLevel === 12) {
                themeMessage = '‚è∞ Êó∂Èó¥Ë£ÇÁºùÔºöÂú®Êó∂Èó¥Â¥©Â°åÂâçÈÄÉËÑ±';
            } else if (gameState.currentLevel === 15) {
                themeMessage = 'üåë ÈªëÊöóÊ∑±Ê∏äÔºöÂú®Êó†Â∞ΩÈªëÊöó‰∏≠ÂØªÊâæÂÖâÊòé';
            } else if (gameState.currentLevel === 18) {
                themeMessage = 'üîÑ Ê∑∑‰π±ÊÑèËØÜÔºöÊÄùÁª¥Ë¢´Êâ≠Êõ≤‰∫Ü';
            } else if (gameState.currentLevel === 22) {
                themeMessage = 'üßä ÂÜ∞Èúú‰∏ñÁïåÔºöÂú∞Èù¢ÁªìÂÜ∞ÔºåÂ∞èÂøÉÊªëÂÄí';
            } else if (gameState.currentLevel === 25) {
                themeMessage = 'üåÄ Á©∫Èó¥Èó®ÔºöÂà©Áî®‰º†ÈÄÅÈó®Á©øË∂äÁ©∫Èó¥';
            } else if (gameState.currentLevel === 28) {
                themeMessage = 'üîò Êú∫ÂÖ≥Ëø∑ÂÆ´ÔºöÊøÄÊ¥ªÊâÄÊúâÊú∫ÂÖ≥ÂºÄÂêØÂá∫Ë∑Ø';
            } else if (gameState.currentLevel === 32) {
                themeMessage = 'üîÑ ÈáçÂäõÂºÇÂ∏∏Ôºö‰∏ä‰∏ãÈ¢†ÂÄíÁöÑ‰∏ñÁïå';
            } else if (gameState.currentLevel === 35) {
                themeMessage = 'üëª ÁÅµ‰ΩìÁä∂ÊÄÅÔºö‰Ω†ÂèòÂæóÂçäÈÄèÊòé‰∫Ü';
            } else if (gameState.currentLevel === 40) {
                themeMessage = 'üí® È£éÊö¥‰πãÁúºÔºöÂº∫È£éÂú®Êé®Âä®ÁùÄ‰Ω†';
            } else if (gameState.currentLevel === 45) {
                themeMessage = 'üöÄ ÊµÆÁ©∫Âπ≥Âè∞ÔºöË∑≥‰∏äÁßªÂä®ÁöÑÂπ≥Âè∞';
            } else if (gameState.currentLevel === 50) {
                themeMessage = 'üî• ÁªàÊûÅËÄÉÈ™åÔºöÊó∂Èó¥„ÄÅÈí•Âåô„ÄÅÊ∞¥Êô∂ÁöÑ‰∏âÈáçËØïÁÇº';
            } else if (gameState.currentLevel === 55) {
                themeMessage = 'üåÄ ‰º†ÈÄÅËø∑ÂÆ´ÔºöÂú®ÈªëÊöó‰∏≠ÂØªÊâæÊ≠£Á°ÆÁöÑ‰º†ÈÄÅÈó®';
            } else if (gameState.currentLevel === 60) {
                themeMessage = '‚ö° ÊûÅÈÄüÈÄÉËÑ±ÔºöÊªëÂÜ∞Âú∫‰∏äÁöÑÁîüÊ≠ªÊó∂ÈÄü';
            } else if (gameState.currentLevel === 65) {
                themeMessage = 'üëª ÈöêÂΩ¢Ê≥ïÂ∏àÔºöÂú®Ê∑∑‰π±‰∏≠‰øùÊåÅÈöêÂΩ¢';
            } else if (gameState.currentLevel === 70) {
                themeMessage = 'üå™Ô∏è È£éÊö¥‰∏≠ÂøÉÔºöÂú®ÁãÇÈ£é‰∏≠ÂØªÊâæÂá∫Ë∑Ø';
            } else if (gameState.currentLevel === 75) {
                themeMessage = 'üîÑ ÈáçÂäõÊ∑∑‰π±ÔºöÈ¢†ÂÄí‰∏ñÁïåÁöÑÊªëÂÜ∞ÊåëÊàò';
            } else if (gameState.currentLevel === 80) {
                themeMessage = 'üîò ÁªàÊûÅÊú∫ÂÖ≥ÔºöÈªëÊöó‰∏≠ÁöÑ‰∫îÈáçÊú∫ÂÖ≥';
            } else if (gameState.currentLevel === 85) {
                themeMessage = 'üß† ËÆ∞ÂøÜËØïÁÇºÔºöÂú®Ê∑∑‰π±‰∏≠Êî∂ÈõÜÂ§±ËêΩÁöÑËÆ∞ÂøÜ';
            } else if (gameState.currentLevel === 90) {
                themeMessage = '‚ö° Êó∂Á©∫Êâ≠Êõ≤Ôºö‰º†ÈÄÅÈó®‰∏≠ÁöÑÊªëÂÜ∞È£éÊö¥';
            } else if (gameState.currentLevel === 95) {
                themeMessage = 'üåü ÊúÄÁªàËÄÉÈ™åÔºöÈªëÊöó‰∏≠ÁöÑÁªºÂêàËØïÁÇº';
            } else if (gameState.currentLevel === 99) {
                themeMessage = 'üíÄ ÁªàÊûÅÂâçÂ§úÔºöÊâÄÊúâËØÖÂííÁöÑÈõÜÂêà‰Ωì';
            } else if (gameState.currentLevel === 100) {
                themeMessage = 'üåÖ ÈáçÁîü‰πãÈó®ÔºöÊâìÁ†¥Âæ™ÁéØÔºåËé∑ÂæóÁúüÊ≠£ÁöÑËá™Áî±';
            }
            
            if (themeMessage) {
                messageDisplay.textContent = themeMessage;
                setTimeout(() => {
                    if (messageDisplay.textContent === themeMessage) {
                        messageDisplay.textContent = '';
                    }
                }, 3000);
            }
        }

        // ÂàõÂª∫Êî∂ÈõÜÂìÅ
        function createCollectibles(count) {
            const sm = gameState.specialMechanics;
            for (let i = 0; i < count; i++) {
                const collectible = document.createElement('div');
                collectible.className = 'collectible';
                collectible.style.left = (150 + Math.random() * (gameWidth - 300)) + 'px';
                collectible.style.top = (50 + Math.random() * (gameHeight - 150)) + 'px';
                gameContainer.appendChild(collectible);
                sm.collectibles.push(collectible);
            }
        }
        
        // ÂàõÂª∫Èí•Âåô
        function createKeys(count) {
            const sm = gameState.specialMechanics;
            for (let i = 0; i < count; i++) {
                const key = document.createElement('div');
                key.className = 'key-item';
                key.style.left = (150 + Math.random() * (gameWidth - 300)) + 'px';
                key.style.top = (50 + Math.random() * (gameHeight - 150)) + 'px';
                gameContainer.appendChild(key);
            }
        }
        
        // ÂàõÂª∫‰º†ÈÄÅÈó®
        function createTeleporters(count) {
            const sm = gameState.specialMechanics;
            for (let i = 0; i < count; i++) {
                const teleporter = document.createElement('div');
                teleporter.className = 'teleporter';
                teleporter.style.left = (100 + Math.random() * (gameWidth - 260)) + 'px';
                teleporter.style.top = (50 + Math.random() * (gameHeight - 150)) + 'px';
                teleporter.dataset.teleporterId = i;
                gameContainer.appendChild(teleporter);
                sm.teleporters.push(teleporter);
            }
        }
        
        // ÂàõÂª∫ÂºÄÂÖ≥
        function createSwitches(count) {
            const sm = gameState.specialMechanics;
            for (let i = 0; i < count; i++) {
                const switchEl = document.createElement('div');
                switchEl.className = 'switch';
                switchEl.style.left = (150 + Math.random() * (gameWidth - 300)) + 'px';
                switchEl.style.top = (50 + Math.random() * (gameHeight - 150)) + 'px';
                switchEl.dataset.activated = 'false';
                gameContainer.appendChild(switchEl);
                sm.switches.push(switchEl);
            }
        }
        
        // ÂàõÂª∫ÁßªÂä®Âπ≥Âè∞
        function createMovingPlatforms(count) {
            const sm = gameState.specialMechanics;
            for (let i = 0; i < count; i++) {
                const platform = document.createElement('div');
                platform.className = 'moving-platform';
                platform.style.left = (100 + Math.random() * (gameWidth - 280)) + 'px';
                platform.style.top = (100 + Math.random() * (gameHeight - 200)) + 'px';
                
                const platformData = {
                    element: platform,
                    x: parseFloat(platform.style.left),
                    y: parseFloat(platform.style.top),
                    speedX: (Math.random() - 0.5) * 4,
                    speedY: (Math.random() - 0.5) * 4,
                    width: 80,
                    height: 20
                };
                
                gameContainer.appendChild(platform);
                sm.movingPlatforms.push(platformData);
            }
        }
        
        // ÂàõÂª∫ËÆ°Êó∂Âô®ÊòæÁ§∫
        function createTimerDisplay() {
            const timer = document.createElement('div');
            timer.className = 'timer-display';
            timer.id = 'timer-display';
            gameContainer.appendChild(timer);
        }
        
        // ÁîüÊàêÂÖ≥Âç°Â∏ÉÂ±ÄÁßçÂ≠ê
        function generateLevelSeed(level) {
            return level * 12345; // ‰ΩøÁî®ÂÖ≥Âç°Êï∞ÁîüÊàêÂõ∫ÂÆöÁßçÂ≠ê
        }
        
        // Âü∫‰∫éÁßçÂ≠êÁöÑÈöèÊú∫Êï∞ÁîüÊàêÂô®
        function seededRandom(seed) {
            const x = Math.sin(seed) * 10000;
            return x - Math.floor(x);
        }
        
        // ÊòæÁ§∫ÂØπËØùÊ°Ü
        function showDialogue(messages) {
            const dialogueBox = document.createElement('div');
            dialogueBox.className = 'dialogue-box';
            
            const title = document.createElement('div');
            title.className = 'dialogue-title';
            title.textContent = messages[0];
            
            const content = document.createElement('div');
            content.className = 'dialogue-content';
            
            // ÊòæÁ§∫Èô§Ê†áÈ¢òÂ§ñÁöÑÊâÄÊúâÊ∂àÊÅØ
            for (let i = 1; i < messages.length; i++) {
                const line = document.createElement('div');
                line.textContent = messages[i];
                line.style.marginBottom = '8px';
                content.appendChild(line);
            }
            
            const continueBtn = document.createElement('button');
            continueBtn.className = 'dialogue-continue';
            continueBtn.textContent = 'ÁªßÁª≠';
            continueBtn.onclick = () => {
                dialogueBox.remove();
            };
            
            dialogueBox.appendChild(title);
            dialogueBox.appendChild(content);
            dialogueBox.appendChild(continueBtn);
            
            document.body.appendChild(dialogueBox);
        }
        
        // ÂàõÂª∫Âú∞Èõ∑Âú∫ - Á¨¨‰∫åÂÖ≥‰∏ìÁî®ÔºàËø∑ÂÆ´ÂºèÂ∏ÉÂ±ÄÔºâ
        function createMineField() {
            // ÂàùÂßãÂåñÂÖ≥Âç°Â∏ÉÂ±ÄÂ≠òÂÇ®
            if (!gameState.levelLayouts[gameState.currentLevel]) {
                gameState.levelLayouts[gameState.currentLevel] = {
                    staticTraps: [],
                    movingTraps: []
                };
            }
            
            const gridSize = 40; // ÁΩëÊ†ºÂ§ßÂ∞è
            const cols = Math.floor(gameWidth / gridSize);
            const rows = Math.floor(gameHeight / gridSize);
            
            console.log(`Ëø∑ÂÆ´ÁΩëÊ†ºÂ§ßÂ∞è: ${cols}x${rows}`);
            
            // ÂàõÂª∫Ëø∑ÂÆ´Âú∞Âõæ - trueË°®Á§∫Â¢ôÂ£ÅÔºàÂú∞Èõ∑ÔºâÔºåfalseË°®Á§∫ÈÄöÈÅì
            const maze = Array(rows).fill().map(() => Array(cols).fill(true));
            
            // Âõ∫ÂÆöÂ∏ÉÂ±ÄÔºöÁé©ÂÆ∂Âú®Â∑¶‰∏äËßíÔºåÈó®Âú®Âè≥‰∏ãËßí
            const safeStartX = 1; // Â∑¶‰∏äËßí
            const safeStartY = 1;
            const safeEndX = cols - 2; // Âè≥‰∏ãËßí
            const safeEndY = rows - 2;
            
            // ‰øùÂ≠òÁªàÁÇπ‰ΩçÁΩÆÂà∞ÂÖ®Â±ÄÂèòÈáèÔºå‰æõÈó®‰ΩçÁΩÆÊõ¥Êñ∞‰ΩøÁî®
            window.mazeEndPoint = { x: safeEndX, y: safeEndY };
            
            console.log(`Ëø∑ÂÆ´Â∞∫ÂØ∏: ${cols}x${rows}, Ëµ∑ÁÇπ: (${safeStartX}, ${safeStartY}), ÁªàÁÇπ: (${safeEndX}, ${safeEndY})`);
            
            // ÁîüÊàêÁúüÊ≠£Â§çÊùÇÁöÑËø∑ÂÆ´
            function generateMaze() {
                console.log('ÂºÄÂßãÁîüÊàêËø∑ÂÆ´...');
                
                let attempts = 0;
                const maxAttempts = 10;
                
                while (attempts < maxAttempts) {
                    attempts++;
                    console.log(`Ëø∑ÂÆ´ÁîüÊàêÂ∞ùËØï ${attempts}/${maxAttempts}`);
                    
                    // ÂàùÂßãÂåñÔºöÂÖ®ÈÉ®ËÆæ‰∏∫Â¢ôÂ£Å
                    for (let y = 0; y < rows; y++) {
                        for (let x = 0; x < cols; x++) {
                            maze[y][x] = true;
                        }
                    }
                    
                    // ‰ΩøÁî®ÊîπËøõÁöÑÊ∑±Â∫¶‰ºòÂÖàÊêúÁ¥¢ÁîüÊàêÂ§çÊùÇËø∑ÂÆ´
                    const visited = Array(rows).fill().map(() => Array(cols).fill(false));
                    const stack = [];
                    
                    // ‰ªéËµ∑ÁÇπÂºÄÂßã
                    let currentX = safeStartX;
                    let currentY = safeStartY;
                    maze[currentY][currentX] = false;
                    visited[currentY][currentX] = true;
                    
                    while (true) {
                        // Ëé∑ÂèñÊú™ËÆøÈóÆÁöÑÈÇªÂ±ÖÔºàË∑ùÁ¶ª‰∏∫2ÁöÑ‰ΩçÁΩÆÔºâ
                        const neighbors = [];
                        let directions = [
                            [0, -2], [2, 0], [0, 2], [-2, 0] // ‰∏ä„ÄÅÂè≥„ÄÅ‰∏ã„ÄÅÂ∑¶
                        ];
                        
                        // Êô∫ËÉΩÊñπÂêëÈÄâÊã©ÔºöÂàõÈÄ†Â§çÊùÇË∑ØÂæÑ‰ΩÜÈÅøÂÖçÁÆÄÂçïÂ∫ïÈÉ®ÈÄöÈÅì
                        if (currentY > rows * 0.7) {
                            // Â¶ÇÊûúÂú®Â∫ïÈÉ®30%Âå∫ÂüüÔºåÂº∫ÁÉà‰ºòÂÖàÂêë‰∏äÂíåÂ∑¶Âè≥ÔºåÈÅøÂÖçÂêë‰∏ã
                            directions = [[0, -2], [2, 0], [-2, 0]]; // ÁßªÈô§Âêë‰∏ãÈÄâÈ°π
                        } else if (currentY > rows / 2) {
                            // Â¶ÇÊûúÂú®‰∏≠‰∏ãÈÉ®ÂàÜÔºå‰ºòÂÖàÂêë‰∏äÂíåÂ∑¶Âè≥
                            directions = [[0, -2], [2, 0], [-2, 0], [0, 2]];
                        } else {
                            // Â¶ÇÊûúÂú®‰∏äÂçäÈÉ®ÂàÜÔºåÂπ≥Ë°°ÂêÑ‰∏™ÊñπÂêë‰ΩÜÁ®çÂæÆÂÅèÂêëÂè≥‰∏ã
                            directions = [[2, 0], [0, 2], [0, -2], [-2, 0]];
                        }
                        
                        for (const [dx, dy] of directions) {
                            const nx = currentX + dx;
                            const ny = currentY + dy;
                            
                            if (nx >= 1 && nx < cols - 1 && ny >= 1 && ny < rows - 1 && !visited[ny][nx]) {
                                neighbors.push([nx, ny, dx, dy]);
                            }
                        }
                        
                        if (neighbors.length > 0) {
                            // Êô∫ËÉΩÈÄâÊã©ÈÇªÂ±ÖÔºåÈÅøÂÖçÁÆÄÂçïË∑ØÂæÑ
                            let selectedNeighbor;
                            
                            if (neighbors.length === 1) {
                                selectedNeighbor = neighbors[0];
                            } else {
                                // Êô∫ËÉΩÈÄâÊã©ÈÇªÂ±ÖÔºö‰ºòÂÖàÈÄâÊã©ÊúùÂêëÁªàÁÇπ‰ΩÜÈÅøÂÖçÁÆÄÂçïË∑ØÂæÑÁöÑÊñπÂêë
                                const towardsEndNeighbors = neighbors.filter(([nx, ny, dx, dy]) => {
                                    // ËÆ°ÁÆóÊòØÂê¶ÊúùÂêëÁªàÁÇπÊñπÂêë
                                    const towardsRight = dx > 0 && nx < safeEndX;
                                    const towardsDown = dy > 0 && ny < safeEndY;
                                    const towardsEnd = towardsRight || towardsDown;
                                    
                                    // ÈÅøÂÖçÂú®Â∫ïÈÉ®Âå∫ÂüüÂàõÂª∫Ê∞¥Âπ≥ÈÄöÈÅì
                                    const inBottomArea = ny > rows * 0.8;
                                    const isHorizontal = dy === 0;
                                    const wouldCreateBottomChannel = inBottomArea && isHorizontal;
                                    
                                    return towardsEnd && !wouldCreateBottomChannel;
                                });
                                
                                if (towardsEndNeighbors.length > 0) {
                                    selectedNeighbor = towardsEndNeighbors[Math.floor(Math.random() * towardsEndNeighbors.length)];
                                } else {
                                    // Â¶ÇÊûúÊ≤°ÊúâÊúùÂêëÁªàÁÇπÁöÑÂ•ΩÈÄâÊã©ÔºåÈÄâÊã©ÈùûÂ∫ïÈÉ®ÈÄöÈÅìÁöÑÊñπÂêë
                                    const nonBottomNeighbors = neighbors.filter(([nx, ny, dx, dy]) => {
                                        return !(dy === 0 && ny > rows * 0.8); // ÈÅøÂÖçÂ∫ïÈÉ®Ê∞¥Âπ≥ÈÄöÈÅì
                                    });
                                    
                                    if (nonBottomNeighbors.length > 0) {
                                        selectedNeighbor = nonBottomNeighbors[Math.floor(Math.random() * nonBottomNeighbors.length)];
                                    } else {
                                        selectedNeighbor = neighbors[Math.floor(Math.random() * neighbors.length)];
                                    }
                                }
                            }
                            
                            const [nx, ny, dx, dy] = selectedNeighbor;
                            
                            // ÊâìÈÄöÂà∞ÈÇªÂ±ÖÁöÑË∑ØÂæÑ
                            maze[currentY + dy/2][currentX + dx/2] = false;
                            maze[ny][nx] = false;
                            visited[ny][nx] = true;
                            
                            // Â∞ÜÂΩìÂâç‰ΩçÁΩÆÂéãÂÖ•Ê†à
                            stack.push([currentX, currentY]);
                            currentX = nx;
                            currentY = ny;
                        } else if (stack.length > 0) {
                            // ÂõûÊ∫Ø
                            [currentX, currentY] = stack.pop();
                        } else {
                            break;
                        }
                    }
                    
                    // Á°Æ‰øùÁªàÁÇπÂèØËææ
                    maze[safeEndY][safeEndX] = false;
                    
                    // Âº∫Âà∂ÂàõÂª∫‰∏ÄÊù°‰ªéËµ∑ÁÇπÂà∞ÁªàÁÇπÁöÑÂ§çÊùÇË∑ØÂæÑÔºà‰Ωú‰∏∫‰øùÂ∫ïÔºâ
                    createGuaranteedPath(safeStartX, safeStartY, safeEndX, safeEndY);
                    
                    // Ê∑ªÂä†‰∏Ä‰∫õÈ¢ùÂ§ñÁöÑËøûÊé•ÔºåÂ¢ûÂä†Ë∑ØÂæÑÂ§öÊ†∑ÊÄßÔºàÈÅøÂÖçÂ∫ïÈÉ®ÈÄöÈÅìÔºâ
                    const extraConnections = Math.floor(Math.random() * 6) + 3;
                    for (let i = 0; i < extraConnections; i++) {
                        const x = 2 + Math.floor(Math.random() * (cols - 4));
                        // ÈÅøÂÖçÂú®Â∫ïÈÉ®20%Âå∫ÂüüÊ∑ªÂä†È¢ùÂ§ñËøûÊé•
                        const y = 2 + Math.floor(Math.random() * (rows * 0.8 - 4));
                        
                        // ÈöèÊú∫ÊâìÈÄö‰∏Ä‰∫õÂ¢ôÂ£Å
                        if (maze[y][x] && Math.random() < 0.5) {
                            // Ê£ÄÊü•Âë®Âõ¥ÊòØÂê¶ÊúâÈÄöÈÅì
                            const hasAdjacentPath = [
                                [0, 1], [1, 0], [0, -1], [-1, 0]
                            ].some(([dx, dy]) => {
                                const nx = x + dx;
                                const ny = y + dy;
                                return nx >= 0 && nx < cols && ny >= 0 && ny < rows && !maze[ny][nx];
                            });
                            
                            // È¢ùÂ§ñÊ£ÄÊü•Ôºö‰∏çË¶ÅÂàõÂª∫ÈïøÁöÑÊ∞¥Âπ≥ÈÄöÈÅì
                            const wouldCreateLongHorizontal = checkForLongHorizontalPath(x, y);
                            
                            if (hasAdjacentPath && !wouldCreateLongHorizontal) {
                                maze[y][x] = false;
                            }
                        }
                    }
                    
                    // Ê£ÄÊü•Âπ∂ÁßªÈô§ÂèØËÉΩÁöÑÂ∫ïÈÉ®ÈïøÈÄöÈÅì
                    removeBottomHorizontalPaths();
                    
                    // Ê£ÄÊü•ËøûÈÄöÊÄß
                    if (isPathExists(safeStartX, safeStartY, safeEndX, safeEndY)) {
                        console.log(`Ëø∑ÂÆ´ÁîüÊàêÊàêÂäüÔºÅÂ∞ùËØïÊ¨°Êï∞: ${attempts}`);
                        return; // ÊàêÂäüÁîüÊàêÂèØËææËø∑ÂÆ´
                    } else {
                        console.log(`Á¨¨${attempts}Ê¨°Â∞ùËØïÂ§±Ë¥•ÔºåËµ∑ÁÇπÂà∞ÁªàÁÇπ‰∏çËøûÈÄöÔºåÈáçÊñ∞ÁîüÊàê...`);
                        // Â¶ÇÊûú‰∏çËøûÈÄöÔºåÂº∫Âà∂ÂàõÂª∫Ë∑ØÂæÑ
                        if (attempts === maxAttempts) {
                            console.log('ËææÂà∞ÊúÄÂ§ßÂ∞ùËØïÊ¨°Êï∞ÔºåÂº∫Âà∂ÂàõÂª∫ËøûÈÄöË∑ØÂæÑ');
                            forceCreatePath(safeStartX, safeStartY, safeEndX, safeEndY);
                            return;
                        }
                    }
                }
            }
            
            // Ê£ÄÊü•‰∏§ÁÇπ‰πãÈó¥ÊòØÂê¶Â≠òÂú®Ë∑ØÂæÑÔºàBFSÁÆóÊ≥ïÔºâ
            function isPathExists(startX, startY, endX, endY) {
                const visited = Array(rows).fill().map(() => Array(cols).fill(false));
                const queue = [[startX, startY]];
                visited[startY][startX] = true;
                
                const directions = [[0, 1], [1, 0], [0, -1], [-1, 0]];
                
                while (queue.length > 0) {
                    const [x, y] = queue.shift();
                    
                    // Âà∞ËææÁªàÁÇπ
                    if (x === endX && y === endY) {
                        return true;
                    }
                    
                    // Ê£ÄÊü•Âõõ‰∏™ÊñπÂêë
                    for (const [dx, dy] of directions) {
                        const nx = x + dx;
                        const ny = y + dy;
                        
                        if (nx >= 0 && nx < cols && ny >= 0 && ny < rows && 
                            !visited[ny][nx] && !maze[ny][nx]) {
                            visited[ny][nx] = true;
                            queue.push([nx, ny]);
                        }
                    }
                }
                
                return false;
            }
            
            // Âº∫Âà∂ÂàõÂª∫‰ªéËµ∑ÁÇπÂà∞ÁªàÁÇπÁöÑË∑ØÂæÑ
            function forceCreatePath(startX, startY, endX, endY) {
                console.log('Âº∫Âà∂ÂàõÂª∫Ë∑ØÂæÑ...');
                
                // È¶ñÂÖàÁ°Æ‰øùÁªàÁÇπÁªùÂØπÂèØËææ - Ê∏ÖÁêÜÊõ¥Â§ßËåÉÂõ¥
                console.log('Âº∫Âà∂Ê∏ÖÁêÜÁªàÁÇπÂë®Âõ¥Êõ¥Â§ßÂå∫Âüü...');
                for (let dx = -2; dx <= 2; dx++) {
                    for (let dy = -2; dy <= 2; dy++) {
                        const ex = endX + dx;
                        const ey = endY + dy;
                        
                        if (ex >= 0 && ex < cols && ey >= 0 && ey < rows) {
                            maze[ey][ex] = false;
                            console.log(`Âº∫Âà∂Ê∏ÖÁêÜÁªàÁÇπ: (${ex}, ${ey})`);
                        }
                    }
                }
                
                // ‰ΩøÁî®A*ÁÆóÊ≥ïÊâæÂà∞ÊúÄÁü≠Ë∑ØÂæÑÂπ∂ÊâìÈÄö
                const path = findPathAStar(startX, startY, endX, endY);
                
                if (path && path.length > 0) {
                    // ÊâìÈÄöË∑ØÂæÑ‰∏äÁöÑÊâÄÊúâÁÇπÔºåÂπ∂Âú®Ë∑ØÂæÑÂë®Âõ¥ÁïôÂá∫Á©∫Èó¥
                    for (const [x, y] of path) {
                        maze[y][x] = false;
                        // Âú®Ë∑ØÂæÑ‰∏§‰æß‰πüÊ∏ÖÁêÜ‰∏Ä‰∫õÁ©∫Èó¥
                        if (x > 0) maze[y][x-1] = false;
                        if (x < cols-1) maze[y][x+1] = false;
                    }
                    console.log(`Âº∫Âà∂Ë∑ØÂæÑÂàõÂª∫ÂÆåÊàêÔºåË∑ØÂæÑÈïøÂ∫¶: ${path.length}`);
                } else {
                    // Â¶ÇÊûúA*Â§±Ë¥•Ôºå‰ΩøÁî®ÁÆÄÂçïÁöÑÁõ¥Á∫øË∑ØÂæÑ
                    console.log('A*ÁÆóÊ≥ïÂ§±Ë¥•Ôºå‰ΩøÁî®Êõ≤ÊäòË∑ØÂæÑ');
                    createStraightPath(startX, startY, endX, endY);
                }
                
                // ÊúÄÂêéÂÜçÊ¨°Á°Æ‰øùÁªàÁÇπÂèØËææ
                ensureEndPointAccessible(endX, endY);
            }
            
            // Á°Æ‰øùÁªàÁÇπÁªùÂØπÂèØËææ
            function ensureEndPointAccessible(endX, endY) {
                console.log('ÊúÄÁªàÁ°Æ‰øùÁªàÁÇπÂèØËææ...');
                
                // Âú®ÁªàÁÇπÂë®Âõ¥ÂàõÂª∫ÂçÅÂ≠óÂΩ¢ÈÄöÈÅì
                const crossPaths = [
                    [[endX-1, endY], [endX-2, endY]], // Â∑¶
                    [[endX+1, endY], [endX+2, endY]], // Âè≥
                    [[endX, endY-1], [endX, endY-2]], // ‰∏ä
                    [[endX, endY+1], [endX, endY+2]]  // ‰∏ã
                ];
                
                for (const pathPair of crossPaths) {
                    for (const [x, y] of pathPair) {
                        if (x >= 0 && x < cols && y >= 0 && y < rows) {
                            maze[y][x] = false;
                        }
                    }
                }
                
                console.log('ÁªàÁÇπÂçÅÂ≠óÂΩ¢ÈÄöÈÅìÂàõÂª∫ÂÆåÊàê');
            }
            
            // A*ÂØªË∑ØÁÆóÊ≥ï
            function findPathAStar(startX, startY, endX, endY) {
                const openSet = [{x: startX, y: startY, g: 0, h: 0, f: 0, parent: null}];
                const closedSet = new Set();
                
                function heuristic(x, y) {
                    return Math.abs(x - endX) + Math.abs(y - endY);
                }
                
                while (openSet.length > 0) {
                    // ÊâæÂà∞fÂÄºÊúÄÂ∞èÁöÑËäÇÁÇπ
                    openSet.sort((a, b) => a.f - b.f);
                    const current = openSet.shift();
                    
                    const currentKey = `${current.x},${current.y}`;
                    if (closedSet.has(currentKey)) continue;
                    closedSet.add(currentKey);
                    
                    // Âà∞ËææÁªàÁÇπ
                    if (current.x === endX && current.y === endY) {
                        const path = [];
                        let node = current;
                        while (node) {
                            path.unshift([node.x, node.y]);
                            node = node.parent;
                        }
                        return path;
                    }
                    
                    // Ê£ÄÊü•ÈÇªÂ±Ö
                    const directions = [[0, 1], [1, 0], [0, -1], [-1, 0]];
                    for (const [dx, dy] of directions) {
                        const nx = current.x + dx;
                        const ny = current.y + dy;
                        const neighborKey = `${nx},${ny}`;
                        
                        if (nx >= 0 && nx < cols && ny >= 0 && ny < rows && !closedSet.has(neighborKey)) {
                            const g = current.g + 1;
                            const h = heuristic(nx, ny);
                            const f = g + h;
                            
                            openSet.push({
                                x: nx, y: ny, g, h, f,
                                parent: current
                            });
                        }
                    }
                }
                
                return null; // Ê≤°ÊúâÊâæÂà∞Ë∑ØÂæÑ
            }
            
            // ÂàõÂª∫Â§çÊùÇÁöÑÊõ≤ÊäòË∑ØÂæÑÔºàÈÅøÂÖçÁÆÄÂçïÁõ¥Á∫øÔºâ
            function createStraightPath(startX, startY, endX, endY) {
                console.log('ÂàõÂª∫Â§çÊùÇÊõ≤ÊäòË∑ØÂæÑ...');
                
                let x = startX;
                let y = startY;
                maze[y][x] = false;
                
                // ÂàõÂª∫Êõ≤ÊäòË∑ØÂæÑÔºåÈÅøÂÖçÁÆÄÂçïÁöÑLÂΩ¢
                const pathPoints = [];
                
                // Ê∑ªÂä†‰∏≠Èó¥ËΩ¨ÊäòÁÇπÔºåÂàõÈÄ†Êõ¥Â§çÊùÇÁöÑË∑ØÂæÑ
                const midX1 = Math.floor((startX + endX) / 3);
                const midY1 = Math.floor((startY + endY) / 3);
                const midX2 = Math.floor((startX + endX) * 2 / 3);
                const midY2 = Math.floor((startY + endY) * 2 / 3);
                
                // ÈöèÊú∫ÈÄâÊã©Ë∑ØÂæÑÊñπÂºè
                const pathType = Math.floor(Math.random() * 3);
                
                if (pathType === 0) {
                    // Ë∑ØÂæÑ1: ÂÖàÂêëÂè≥ÔºåÂÜçÂêë‰∏ãÔºåÂÜçÂêëÂè≥
                    pathPoints.push([midX1, startY]);
                    pathPoints.push([midX1, midY2]);
                    pathPoints.push([endX, midY2]);
                    pathPoints.push([endX, endY]);
                } else if (pathType === 1) {
                    // Ë∑ØÂæÑ2: ÂÖàÂêë‰∏ãÔºåÂÜçÂêëÂè≥ÔºåÂÜçÂêë‰∏ã
                    pathPoints.push([startX, midY1]);
                    pathPoints.push([midX2, midY1]);
                    pathPoints.push([midX2, endY]);
                    pathPoints.push([endX, endY]);
                } else {
                    // Ë∑ØÂæÑ3: Â§çÊùÇZÂ≠óÂΩ¢Ë∑ØÂæÑ
                    pathPoints.push([midX1, startY]);
                    pathPoints.push([midX1, midY1]);
                    pathPoints.push([midX2, midY1]);
                    pathPoints.push([midX2, endY]);
                    pathPoints.push([endX, endY]);
                }
                
                // ËøûÊé•ÊâÄÊúâË∑ØÂæÑÁÇπ
                let currentX = startX;
                let currentY = startY;
                
                for (const [targetX, targetY] of pathPoints) {
                    // Ê∞¥Âπ≥ÁßªÂä®
                    while (currentX !== targetX) {
                        maze[currentY][currentX] = false;
                        currentX += (targetX > currentX) ? 1 : -1;
                    }
                    // ÂûÇÁõ¥ÁßªÂä®
                    while (currentY !== targetY) {
                        maze[currentY][currentX] = false;
                        currentY += (targetY > currentY) ? 1 : -1;
                    }
                    maze[currentY][currentX] = false;
                }
                
                // Á°Æ‰øùÁªàÁÇπÂèØËææ
                maze[endY][endX] = false;
                
                console.log('Â§çÊùÇÊõ≤ÊäòË∑ØÂæÑÂàõÂª∫ÂÆåÊàê');
            }
            
            // ÂàõÂª∫‰øùËØÅËøûÈÄöÁöÑÂ§çÊùÇË∑ØÂæÑ
            function createGuaranteedPath(startX, startY, endX, endY) {
                console.log('ÂàõÂª∫‰øùËØÅËøûÈÄöÁöÑÂ§çÊùÇË∑ØÂæÑ...');
                
                // ÂàõÂª∫‰∏ÄÊù°Â§çÊùÇÁöÑZÂ≠óÂΩ¢Ë∑ØÂæÑÔºåÈÅøÂÖçÁÆÄÂçïÁöÑLÂΩ¢ÊàñÁõ¥Á∫ø
                const pathPoints = [];
                
                // ËÆ°ÁÆó‰∏≠Èó¥ËΩ¨ÊäòÁÇπÔºåÂàõÈÄ†Â§çÊùÇË∑ØÂæÑ
                const midX1 = Math.floor(startX + (endX - startX) * 0.3);
                const midY1 = Math.floor(startY + (endY - startY) * 0.6); // ÂÅè‰∏ã‰∏ÄÁÇπ
                const midX2 = Math.floor(startX + (endX - startX) * 0.7);
                const midY2 = Math.floor(startY + (endY - startY) * 0.3); // ÂÅè‰∏ä‰∏ÄÁÇπ
                
                // ÂàõÂª∫Â§çÊùÇÁöÑË∑ØÂæÑÔºöËµ∑ÁÇπ -> ‰∏≠‰∏ã -> Âè≥‰∏ä -> ÁªàÁÇπ
                pathPoints.push([startX, startY]);
                pathPoints.push([midX1, startY]); // ÂÖàÂêëÂè≥
                pathPoints.push([midX1, midY1]); // ÂÜçÂêë‰∏ã
                pathPoints.push([midX2, midY1]); // ÂÜçÂêëÂè≥
                pathPoints.push([midX2, midY2]); // Âêë‰∏ä
                pathPoints.push([endX, midY2]); // ÂêëÂè≥
                pathPoints.push([endX, endY]); // ÊúÄÂêéÂêë‰∏ãÂà∞ÁªàÁÇπ
                
                // ËøûÊé•ÊâÄÊúâË∑ØÂæÑÁÇπ
                for (let i = 0; i < pathPoints.length - 1; i++) {
                    const [x1, y1] = pathPoints[i];
                    const [x2, y2] = pathPoints[i + 1];
                    
                    // ËøûÊé•‰∏§ÁÇπ‰πãÈó¥ÁöÑË∑ØÂæÑ
                    let currentX = x1;
                    let currentY = y1;
                    
                    // ÂÖàÊ∞¥Âπ≥ÁßªÂä®
                    while (currentX !== x2) {
                        if (currentX >= 0 && currentX < cols && currentY >= 0 && currentY < rows) {
                            maze[currentY][currentX] = false;
                        }
                        currentX += (x2 > currentX) ? 1 : -1;
                    }
                    
                    // ÂÜçÂûÇÁõ¥ÁßªÂä®
                    while (currentY !== y2) {
                        if (currentX >= 0 && currentX < cols && currentY >= 0 && currentY < rows) {
                            maze[currentY][currentX] = false;
                        }
                        currentY += (y2 > currentY) ? 1 : -1;
                    }
                    
                    // Á°Æ‰øùÁªàÁÇπ‰πüË¢´Ê†áËÆ∞
                    if (currentX >= 0 && currentX < cols && currentY >= 0 && currentY < rows) {
                        maze[currentY][currentX] = false;
                    }
                }
                
                console.log('‰øùËØÅËøûÈÄöÁöÑÂ§çÊùÇË∑ØÂæÑÂàõÂª∫ÂÆåÊàê');
            }
            
            // Ê£ÄÊü•ÊòØÂê¶‰ºöÂàõÂª∫ÈïøÁöÑÊ∞¥Âπ≥ÈÄöÈÅì
            function checkForLongHorizontalPath(x, y) {
                if (!maze[y][x]) return false; // Â¶ÇÊûúÂ∑≤ÁªèÊòØÈÄöÈÅìÔºå‰∏çÊ£ÄÊü•
                
                let leftCount = 0;
                let rightCount = 0;
                
                // Ê£ÄÊü•Â∑¶‰æßËøûÁª≠ÈÄöÈÅì
                for (let i = x - 1; i >= 0 && !maze[y][i]; i--) {
                    leftCount++;
                }
                
                // Ê£ÄÊü•Âè≥‰æßËøûÁª≠ÈÄöÈÅì
                for (let i = x + 1; i < cols && !maze[y][i]; i++) {
                    rightCount++;
                }
                
                // Â¶ÇÊûúÊÄªÈïøÂ∫¶Ë∂ÖËøáËø∑ÂÆ´ÂÆΩÂ∫¶ÁöÑ30%ÔºåËÆ§‰∏∫ÊòØÈïøÈÄöÈÅì
                return (leftCount + rightCount + 1) > cols * 0.3;
            }
            
            // ÁßªÈô§Â∫ïÈÉ®ÁöÑÈïøÊ∞¥Âπ≥ÈÄöÈÅì
            function removeBottomHorizontalPaths() {
                const bottomThreshold = rows * 0.8; // Â∫ïÈÉ®20%Âå∫Âüü
                
                for (let y = Math.floor(bottomThreshold); y < rows; y++) {
                    let consecutiveCount = 0;
                    let startX = -1;
                    
                    for (let x = 0; x < cols; x++) {
                        if (!maze[y][x]) { // Â¶ÇÊûúÊòØÈÄöÈÅì
                            if (startX === -1) startX = x;
                            consecutiveCount++;
                        } else {
                            // ÈÅáÂà∞Â¢ôÂ£ÅÔºåÊ£ÄÊü•‰πãÂâçÁöÑËøûÁª≠ÈÄöÈÅì
                            if (consecutiveCount > cols * 0.4) { // Â¶ÇÊûúË∂ÖËøá40%ÂÆΩÂ∫¶
                                // ÈöèÊú∫Â∞ÅÂ†µ‰∏Ä‰∫õ‰ΩçÁΩÆÔºåÊâìÊñ≠ÈïøÈÄöÈÅì
                                for (let i = startX; i < startX + consecutiveCount; i += 3) {
                                    if (i !== safeStartX && i !== safeEndX) { // ‰∏çÂ∞ÅÂ†µËµ∑ÁÇπÁªàÁÇπ
                                        maze[y][i] = true;
                                    }
                                }
                                console.log(`ÁßªÈô§Â∫ïÈÉ®ÈïøÈÄöÈÅì: y=${y}, ÈïøÂ∫¶=${consecutiveCount}`);
                            }
                            consecutiveCount = 0;
                            startX = -1;
                        }
                    }
                    
                    // Ê£ÄÊü•Ë°åÊú´ÁöÑËøûÁª≠ÈÄöÈÅì
                    if (consecutiveCount > cols * 0.4) {
                        for (let i = startX; i < startX + consecutiveCount; i += 3) {
                            if (i !== safeStartX && i !== safeEndX) {
                                maze[y][i] = true;
                            }
                        }
                        console.log(`ÁßªÈô§Â∫ïÈÉ®ÈïøÈÄöÈÅì(Ë°åÊú´): y=${y}, ÈïøÂ∫¶=${consecutiveCount}`);
                    }
                }
            }
            
            // Á°Æ‰øùËµ∑ÁÇπÂà∞ÁªàÁÇπÁöÑËøûÈÄöÊÄß
            function ensureConnectivity() {
                // ‰ΩøÁî®BFSÊ£ÄÊü•ËøûÈÄöÊÄß
                function isConnected(startX, startY, endX, endY) {
                    const visited = Array(rows).fill().map(() => Array(cols).fill(false));
                    const queue = [[startX, startY]];
                    visited[startY][startX] = true;
                    
                    while (queue.length > 0) {
                        const [x, y] = queue.shift();
                        
                        if (x === endX && y === endY) {
                            return true;
                        }
                        
                        const directions = [[0, 1], [1, 0], [0, -1], [-1, 0]];
                        for (const [dx, dy] of directions) {
                            const nx = x + dx;
                            const ny = y + dy;
                            
                            if (nx >= 0 && nx < cols && ny >= 0 && ny < rows && 
                                !maze[ny][nx] && !visited[ny][nx]) {
                                visited[ny][nx] = true;
                                queue.push([nx, ny]);
                            }
                        }
                    }
                    return false;
                }
                
                // Â¶ÇÊûú‰∏çËøûÈÄöÔºåÂàõÂª∫ËøûÊé•Ë∑ØÂæÑ
                if (!isConnected(safeStartX, safeStartY, safeEndX, safeEndY)) {
                    console.log('Ëø∑ÂÆ´‰∏çËøûÈÄöÔºåÂàõÂª∫ËøûÊé•Ë∑ØÂæÑ...');
                    
                    // ‰ΩøÁî®A*ÁÆóÊ≥ïÂàõÂª∫ÊúÄÁü≠Ë∑ØÂæÑ
                    const path = findPath(safeStartX, safeStartY, safeEndX, safeEndY);
                    
                    // ÊâìÈÄöË∑ØÂæÑ
                    for (const [x, y] of path) {
                        maze[y][x] = false;
                        // Á®çÂæÆÊâ©ÂÆΩË∑ØÂæÑ
                        if (Math.random() < 0.3) {
                            const directions = [[0, 1], [1, 0], [0, -1], [-1, 0]];
                            const [dx, dy] = directions[Math.floor(Math.random() * directions.length)];
                            const nx = x + dx;
                            const ny = y + dy;
                            if (nx > 0 && nx < cols - 1 && ny > 0 && ny < rows - 1) {
                                maze[ny][nx] = false;
                            }
                        }
                    }
                }
            }
            
            // A*Ë∑ØÂæÑÊü•ÊâæÁÆóÊ≥ï
            function findPath(startX, startY, endX, endY) {
                const openSet = [[startX, startY, 0, Math.abs(startX - endX) + Math.abs(startY - endY)]];
                const cameFrom = new Map();
                const gScore = new Map();
                gScore.set(`${startX},${startY}`, 0);
                
                while (openSet.length > 0) {
                    openSet.sort((a, b) => (a[2] + a[3]) - (b[2] + b[3]));
                    const [x, y, g, h] = openSet.shift();
                    
                    if (x === endX && y === endY) {
                        // ÈáçÂª∫Ë∑ØÂæÑ
                        const path = [];
                        let current = `${x},${y}`;
                        while (current) {
                            const [cx, cy] = current.split(',').map(Number);
                            path.unshift([cx, cy]);
                            current = cameFrom.get(current);
                        }
                        return path;
                    }
                    
                    const directions = [[0, 1], [1, 0], [0, -1], [-1, 0]];
                    for (const [dx, dy] of directions) {
                        const nx = x + dx;
                        const ny = y + dy;
                        
                        if (nx >= 0 && nx < cols && ny >= 0 && ny < rows) {
                            const tentativeG = g + 1;
                            const key = `${nx},${ny}`;
                            
                            if (!gScore.has(key) || tentativeG < gScore.get(key)) {
                                cameFrom.set(key, `${x},${y}`);
                                gScore.set(key, tentativeG);
                                const h = Math.abs(nx - endX) + Math.abs(ny - endY);
                                openSet.push([nx, ny, tentativeG, h]);
                            }
                        }
                    }
                }
                
                return [[startX, startY], [endX, endY]]; // Â§áÁî®Áõ¥Á∫øË∑ØÂæÑ
            }
            
            // ÁîüÊàêËø∑ÂÆ´
            generateMaze();
            
            // ÊúÄÁªàÈ™åËØÅËøûÈÄöÊÄß
            if (isPathExists(safeStartX, safeStartY, safeEndX, safeEndY)) {
                console.log('‚úÖ Ëø∑ÂÆ´ËøûÈÄöÊÄßÈ™åËØÅÈÄöËøáÔºÅ');
                
                // ËÆ°ÁÆóÂπ∂ÊòæÁ§∫ÊúÄÁü≠Ë∑ØÂæÑÈïøÂ∫¶
                const shortestPath = findPathAStar(safeStartX, safeStartY, safeEndX, safeEndY);
                if (shortestPath) {
                    console.log(`üìè ÊúÄÁü≠Ë∑ØÂæÑÈïøÂ∫¶: ${shortestPath.length} Ê≠•`);
                }
                
                // Âç≥‰ΩøËøûÈÄöÊÄßÈÄöËøáÔºå‰πüË¶ÅÁ°Æ‰øùÁªàÁÇπÂë®Âõ¥ÊúâË∂≥Â§üÁ©∫Èó¥
                ensureEndPointAccessible(safeEndX, safeEndY);
            } else {
                console.error('‚ùå Ëø∑ÂÆ´ËøûÈÄöÊÄßÈ™åËØÅÂ§±Ë¥•ÔºÅÂº∫Âà∂‰øÆÂ§ç...');
                forceCreatePath(safeStartX, safeStartY, safeEndX, safeEndY);
            }
            
            // ÊúÄÁªàÁöÑÊúÄÁªàÈ™åËØÅ
            if (!isPathExists(safeStartX, safeStartY, safeEndX, safeEndY)) {
                console.error('üö® ‰∏•ÈáçÈîôËØØÔºöÂº∫Âà∂‰øÆÂ§çÂêé‰ªçÁÑ∂‰∏çËøûÈÄöÔºÅ');
                // ÂàõÂª∫ÊúÄÁÆÄÂçïÁöÑÁõ¥Êé•Ë∑ØÂæÑ
                let x = safeStartX, y = safeStartY;
                while (x !== safeEndX || y !== safeEndY) {
                    maze[y][x] = false;
                    if (x < safeEndX) x++;
                    else if (x > safeEndX) x--;
                    else if (y < safeEndY) y++;
                    else if (y > safeEndY) y--;
                }
                maze[safeEndY][safeEndX] = false;
                console.log('üîß Â∫îÊÄ•‰øÆÂ§çÂÆåÊàê');
            }
            
            // Á°Æ‰øùËµ∑ÂßãÁÇπÂíåÁªàÁÇπÂë®Âõ¥ÊúâË∂≥Â§üÁöÑÁ©∫Èó¥ÂíåÈÄöÈÅì
            console.log('Ê∏ÖÁêÜËµ∑ÁÇπÂíåÁªàÁÇπÂë®Âõ¥Âå∫Âüü...');
            
            // Ê∏ÖÁêÜËµ∑ÁÇπÂë®Âõ¥3x3Âå∫Âüü
            for (let dx = -1; dx <= 1; dx++) {
                for (let dy = -1; dy <= 1; dy++) {
                    const sx = safeStartX + dx;
                    const sy = safeStartY + dy;
                    
                    if (sx >= 0 && sx < cols && sy >= 0 && sy < rows) {
                        maze[sy][sx] = false;
                        console.log(`Ê∏ÖÁêÜËµ∑ÁÇπÂë®Âõ¥: (${sx}, ${sy})`);
                    }
                }
            }
            
            // Ê∏ÖÁêÜÁªàÁÇπÂë®Âõ¥3x3Âå∫Âüü
            for (let dx = -1; dx <= 1; dx++) {
                for (let dy = -1; dy <= 1; dy++) {
                    const ex = safeEndX + dx;
                    const ey = safeEndY + dy;
                    
                    if (ex >= 0 && ex < cols && ey >= 0 && ey < rows) {
                        maze[ey][ex] = false;
                        console.log(`Ê∏ÖÁêÜÁªàÁÇπÂë®Âõ¥: (${ex}, ${ey})`);
                    }
                }
            }
            
            // È¢ùÂ§ñÁ°Æ‰øùÁªàÁÇπÊúâËá≥Â∞ë‰∏ÄÊù°ÈÄöÂêëÂ§ñÈÉ®ÁöÑÈÄöÈÅì
            const directions = [[0, 1], [1, 0], [0, -1], [-1, 0]]; // Âè≥„ÄÅ‰∏ã„ÄÅÂ∑¶„ÄÅ‰∏ä
            let hasExternalConnection = false;
            
            for (const [dx, dy] of directions) {
                const checkX = safeEndX + dx * 2;
                const checkY = safeEndY + dy * 2;
                
                if (checkX >= 0 && checkX < cols && checkY >= 0 && checkY < rows) {
                    // ÂàõÂª∫ÈÄöÂêëÂ§ñÈÉ®ÁöÑÈÄöÈÅì
                    maze[safeEndY + dy][safeEndX + dx] = false;
                    maze[checkY][checkX] = false;
                    hasExternalConnection = true;
                    console.log(`‰∏∫ÁªàÁÇπÂàõÂª∫Â§ñÈÉ®ËøûÊé•: (${safeEndX + dx}, ${safeEndY + dy}) -> (${checkX}, ${checkY})`);
                    break;
                }
            }
            
            if (!hasExternalConnection) {
                console.warn('Êó†Ê≥ï‰∏∫ÁªàÁÇπÂàõÂª∫Â§ñÈÉ®ËøûÊé•Ôºå‰ΩøÁî®Âº∫Âà∂Ë∑ØÂæÑ');
            }
            
            // Ëé∑ÂèñÁé©ÂÆ∂ÂÆûÈôÖÂÉèÁ¥†‰ΩçÁΩÆÔºàÁªü‰∏ÄÂ£∞ÊòéÔºâ
            const playerPixelX = gameState.player.x;
            const playerPixelY = gameState.player.y;
            const playerCenterX = playerPixelX + 20; // Áé©ÂÆ∂‰∏≠ÂøÉÁÇπ
            const playerCenterY = playerPixelY + 25;
            const playerGridX = Math.floor(playerCenterX / gridSize);
            const playerGridY = Math.floor(playerCenterY / gridSize);
            
            console.log(`Áé©ÂÆ∂Ëµ∑Âßã‰ΩçÁΩÆ: ÂÉèÁ¥†(${playerPixelX}, ${playerPixelY}), ‰∏≠ÂøÉ(${playerCenterX}, ${playerCenterY}), ÁΩëÊ†º(${playerGridX}, ${playerGridY})`);
            
            // Á°Æ‰øùÁé©ÂÆ∂Ëµ∑Âßã‰ΩçÁΩÆÁªùÂØπÂÆâÂÖ®
            for (let dx = -1; dx <= 1; dx++) {
                for (let dy = -1; dy <= 1; dy++) {
                    const px = playerGridX + dx;
                    const py = playerGridY + dy;
                    
                    if (px >= 0 && px < cols && py >= 0 && py < rows) {
                        maze[py][px] = false;
                        console.log(`Ê∏ÖÈô§Áé©ÂÆ∂Âë®Âõ¥ÁΩëÊ†º: (${px}, ${py})`);
                    }
                }
            }
            
            // Ê†πÊçÆËø∑ÂÆ´Âú∞ÂõæÊîæÁΩÆÂú∞Èõ∑ÔºàÂ¢ôÂ£ÅÔºâ
            let placedMines = 0;
            
            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    if (maze[y][x]) { // Â¶ÇÊûúÊòØÂ¢ôÂ£ÅÔºåÊîæÁΩÆÂú∞Èõ∑
                        const mine = document.createElement('div');
                        mine.className = 'maze-wall';
                        mine.style.position = 'absolute';
                        mine.style.left = (x * gridSize) + 'px';
                        mine.style.top = (y * gridSize) + 'px';
                        mine.style.width = gridSize + 'px';
                        mine.style.height = gridSize + 'px';
                        mine.style.backgroundColor = '#8B4513'; // Ê£ïËâ≤Â¢ôÂ£Å
                        mine.style.border = '1px solid #654321';
                        mine.style.boxShadow = 'inset 2px 2px 4px rgba(0,0,0,0.3)';
                        mine.dataset.isMine = 'true';
                        mine.style.zIndex = '1';
                        
                        gameContainer.appendChild(mine);
                        gameState.traps.push(mine);
                        
                        // ‰øùÂ≠òÂú∞Èõ∑Â∏ÉÂ±Ä‰ø°ÊÅØ
                        gameState.levelLayouts[gameState.currentLevel].staticTraps.push({
                            className: 'maze-wall',
                            left: x * gridSize,
                            top: y * gridSize,
                            width: gridSize,
                            height: gridSize,
                            isMine: true
                        });
                        
                        placedMines++;
                    }
                }
            }
            
            console.log(`Á¨¨‰∫åÂÖ≥Ëø∑ÂÆ´ÔºöÁîüÊàê‰∫Ü${placedMines}‰∏™Â¢ôÂ£ÅÔºåÁ∫ØËø∑ÂÆ´ÊåëÊàò`);
            
            // Ëø∑ÂÆ´ÁîüÊàêÂÆåÊàêÂêéÁ´ãÂç≥Êõ¥Êñ∞Èó®ÁöÑ‰ΩçÁΩÆ
            updateDoorPosition();
        }

        // ÂàõÂª∫ÁâπÊÆäÈô∑Èò± - Ê†πÊçÆÂÖ≥Âç°‰∏ªÈ¢òÈÄâÊã©Èô∑Èò±Á±ªÂûã
        function createSpecialTrap(trap, seed, seedCounter, sizeMultiplier) {
            // Ê†πÊçÆÂÖ≥Âç°ËåÉÂõ¥Á°ÆÂÆöÂèØÁî®ÁöÑÈô∑Èò±Á±ªÂûã
            let availableTypes = [];
            
            if (gameState.currentLevel >= 3 && gameState.currentLevel <= 10) {
                // Á¨¨3-10ÂÖ≥ÔºöÂü∫Á°ÄÁâπÊÆäÈô∑Èò±
                availableTypes = ['invisible', 'teleport', 'bounce'];
            } else if (gameState.currentLevel >= 11 && gameState.currentLevel <= 20) {
                // Á¨¨11-20ÂÖ≥ÔºöËøΩË∏™ÂíåÂÜ∞ÂÜª‰∏ªÈ¢ò
                availableTypes = ['hunter', 'freeze', 'invisible'];
            } else if (gameState.currentLevel >= 21 && gameState.currentLevel <= 30) {
                // Á¨¨21-30ÂÖ≥ÔºöÂàÜË£ÇÂíåÈáçÂäõ‰∏ªÈ¢ò
                availableTypes = ['split', 'gravity', 'teleport'];
            } else if (gameState.currentLevel >= 31 && gameState.currentLevel <= 40) {
                // Á¨¨31-40ÂÖ≥ÔºöÈïúÂÉèÂíåÈó™ÁÉÅ‰∏ªÈ¢ò
                availableTypes = ['mirror', 'blink', 'hunter'];
            } else if (gameState.currentLevel >= 41 && gameState.currentLevel <= 60) {
                // Á¨¨41-60ÂÖ≥ÔºöÂèòÂåñÊïàÊûú‰∏ªÈ¢ò
                availableTypes = ['shrink', 'speed', 'clone', 'bounce'];
            } else if (gameState.currentLevel >= 61 && gameState.currentLevel <= 80) {
                // Á¨¨61-80ÂÖ≥ÔºöÊ∑∑ÂêàËøõÈò∂
                availableTypes = ['gravity', 'split', 'mirror', 'freeze', 'hunter'];
            } else if (gameState.currentLevel >= 81) {
                // Á¨¨81-100ÂÖ≥ÔºöÁªàÊûÅÊåëÊàòÔºåÊâÄÊúâÁ±ªÂûã
                availableTypes = ['invisible', 'teleport', 'hunter', 'blink', 'gravity', 'split', 'mirror', 'freeze', 'bounce', 'shrink', 'speed', 'clone'];
            }
            
            const typeIndex = Math.floor(seededRandom(seed + seedCounter++) * availableTypes.length);
            const trapType = availableTypes[typeIndex];
            
            const baseSize = 40;
            const width = baseSize * sizeMultiplier;
            const height = baseSize * sizeMultiplier;
            const left = 100 + seededRandom(seed + seedCounter++) * (gameWidth - 200 - width);
            const bottom = seededRandom(seed + seedCounter++) * (gameHeight - height - 50);
            
            switch(trapType) {
                case 'invisible':
                    trap.className = 'invisible-trap';
                    trap.dataset.trapType = 'invisible';
                    trap.dataset.revealed = 'false';
                    break;
                case 'teleport':
                    trap.className = 'teleport-trap';
                    trap.dataset.trapType = 'teleport';
                    break;
                case 'hunter':
                    trap.className = 'hunter-trap';
                    trap.dataset.trapType = 'hunter';
                    trap.dataset.huntSpeed = '2';
                    break;
                case 'blink':
                    trap.className = 'blink-trap';
                    trap.dataset.trapType = 'blink';
                    trap.dataset.visible = 'true';
                    break;
                case 'gravity':
                    trap.className = 'gravity-trap';
                    trap.dataset.trapType = 'gravity';
                    trap.dataset.pullForce = '3';
                    break;
                case 'split':
                    trap.className = 'split-trap';
                    trap.dataset.trapType = 'split';
                    trap.dataset.hasTriggered = 'false';
                    break;
                case 'mirror':
                    trap.className = 'mirror-trap';
                    trap.dataset.trapType = 'mirror';
                    break;
                case 'freeze':
                    trap.className = 'freeze-trap';
                    trap.dataset.trapType = 'freeze';
                    break;
                case 'bounce':
                    trap.className = 'bounce-trap';
                    trap.dataset.trapType = 'bounce';
                    break;
                case 'shrink':
                    trap.className = 'shrink-trap';
                    trap.dataset.trapType = 'shrink';
                    break;
                case 'speed':
                    trap.className = 'speed-trap';
                    trap.dataset.trapType = 'speed';
                    break;
                case 'clone':
                    trap.className = 'clone-trap';
                    trap.dataset.trapType = 'clone';
                    trap.dataset.hasTriggered = 'false';
                    break;
            }
            
            trap.style.width = width + 'px';
            trap.style.height = height + 'px';
            trap.style.left = left + 'px';
            trap.style.bottom = bottom + 'px';
            
            // ‰øùÂ≠òÁâπÊÆäÈô∑Èò±‰ø°ÊÅØ
            gameState.levelLayouts[gameState.currentLevel].staticTraps.push({
                className: trap.className,
                trapType: trapType,
                width: width,
                height: height,
                left: left,
                bottom: bottom,
                data: {...trap.dataset}
            });
            
            return seedCounter;
        }
        
        // Ë∑ØÂæÑÊü•ÊâæÁÆóÊ≥ï - Á°Æ‰øùÁé©ÂÆ∂ÂèØ‰ª•Âà∞ËææÈó®Âè£
        function hasValidPath(traps, startX, startY, endX, endY) {
            const gridSize = 15; // ÂáèÂ∞èÁΩëÊ†ºÂ§ßÂ∞è‰ª•ÊèêÈ´òÁ≤æÂ∫¶
            const cols = Math.ceil(gameWidth / gridSize);
            const rows = Math.ceil(gameHeight / gridSize);
            
            // ÂàõÂª∫ÁΩëÊ†ºÂú∞Âõæ (false = ÂèØÈÄöË°å, true = ÈöúÁ¢ç)
            const grid = Array(rows).fill().map(() => Array(cols).fill(false));
            
            // Ê†áËÆ∞Èô∑Èò±‰ΩçÁΩÆÔºåÂ¢ûÂä†‰∏Ä‰∫õÁºìÂÜ≤Âå∫
            traps.forEach(trap => {
                const buffer = 1; // Â¢ûÂä†1Ê†ºÁºìÂÜ≤Âå∫
                const left = Math.max(0, Math.floor(trap.left / gridSize) - buffer);
                const right = Math.min(cols, Math.ceil((trap.left + trap.width) / gridSize) + buffer);
                
                // Â§ÑÁêÜ‰∏çÂêåÁ±ªÂûãÁöÑÈô∑Èò±ÂùêÊ†áÁ≥ªÁªü
                let top, bottom;
                if (trap.className === 'spike') {
                    // Â∞ñÂà∫Èô∑Èò±Âú®Â∫ïÈÉ®ÔºåÂç†ÊçÆÂ∫ïÈÉ®Âá†Ë°å
                    top = Math.max(0, Math.floor((gameHeight - 30) / gridSize) - buffer);
                    bottom = rows;
                } else {
                    // ÂÖ∂‰ªñÈô∑Èò±‰ΩøÁî®topÂùêÊ†á
                    top = Math.max(0, Math.floor(trap.top / gridSize) - buffer);
                    bottom = Math.min(rows, Math.ceil((trap.top + trap.height) / gridSize) + buffer);
                }
                
                // Ê†áËÆ∞ÁΩëÊ†º‰∏∫ÈöúÁ¢ç
                for (let y = top; y < bottom; y++) {
                    for (let x = left; x < right; x++) {
                        if (y >= 0 && y < rows && x >= 0 && x < cols) {
                            grid[y][x] = true; // Ê†áËÆ∞‰∏∫ÈöúÁ¢ç
                        }
                    }
                }
            });
            
            // ËΩ¨Êç¢ÂùêÊ†áÂà∞ÁΩëÊ†ºÁ≥ªÁªü
            const startGridX = Math.floor(startX / gridSize);
            const startGridY = Math.floor((gameHeight - startY) / gridSize);
            const endGridX = Math.floor(endX / gridSize);
            const endGridY = Math.floor((gameHeight - endY) / gridSize);
            
            // Á°Æ‰øùËµ∑ÂßãÁÇπÂíåÁªàÁÇπÂú®ÊúâÊïàËåÉÂõ¥ÂÜÖ
            if (startGridX < 0 || startGridX >= cols || startGridY < 0 || startGridY >= rows ||
                endGridX < 0 || endGridX >= cols || endGridY < 0 || endGridY >= rows) {
                console.log('Ëµ∑ÂßãÁÇπÊàñÁªàÁÇπË∂ÖÂá∫ËæπÁïå');
                return false;
            }
            
            // Ê∏ÖÁêÜËµ∑ÂßãÁÇπÂíåÁªàÁÇπÂë®Âõ¥ÁöÑÈöúÁ¢çÁâ©ÔºåÁ°Æ‰øùÂÆÉ‰ª¨ÂèØÈÄöË°å
            const clearRadius = 2;
            for (let dy = -clearRadius; dy <= clearRadius; dy++) {
                for (let dx = -clearRadius; dx <= clearRadius; dx++) {
                    const clearX = startGridX + dx;
                    const clearY = startGridY + dy;
                    if (clearX >= 0 && clearX < cols && clearY >= 0 && clearY < rows) {
                        grid[clearY][clearX] = false;
                    }
                    
                    const clearEndX = endGridX + dx;
                    const clearEndY = endGridY + dy;
                    if (clearEndX >= 0 && clearEndX < cols && clearEndY >= 0 && clearEndY < rows) {
                        grid[clearEndY][clearEndX] = false;
                    }
                }
            }
            
            // BFSË∑ØÂæÑÊü•Êâæ
            const queue = [[startGridX, startGridY, 0]]; // Ê∑ªÂä†Ë∑ùÁ¶ª‰ø°ÊÅØ
            const visited = Array(rows).fill().map(() => Array(cols).fill(false));
            visited[startGridY][startGridX] = true;
            
            // 4ÊñπÂêëÁßªÂä® (‰∏çÂåÖÊã¨ÂØπËßíÁ∫øÔºåÊõ¥‰∏•Ê†º)
            const directions = [[0, 1], [1, 0], [0, -1], [-1, 0]];
            
            let maxDistance = 0;
            const maxSearchDistance = cols + rows; // ÈôêÂà∂ÊêúÁ¥¢Ë∑ùÁ¶ª
            
            while (queue.length > 0) {
                const [x, y, distance] = queue.shift();
                maxDistance = Math.max(maxDistance, distance);
                
                // Â¶ÇÊûúÊêúÁ¥¢Ë∑ùÁ¶ªËøáÈïøÔºåÂèØËÉΩÈô∑ÂÖ•Ê≠ªÂæ™ÁéØ
                if (distance > maxSearchDistance) {
                    break;
                }
                
                // Ê£ÄÊü•ÊòØÂê¶Âà∞ËææÁõÆÊ†áÂå∫ÂüüÔºàÂÖÅËÆ∏‰∏ÄÂÆöËåÉÂõ¥Ôºâ
                if (Math.abs(x - endGridX) <= 2 && Math.abs(y - endGridY) <= 2) {
                    console.log(`ÊâæÂà∞Ë∑ØÂæÑÔºåÊêúÁ¥¢Ë∑ùÁ¶ª: ${distance}`);
                    return true;
                }
                
                // Êé¢Á¥¢Áõ∏ÈÇªÊ†ºÂ≠ê
                for (const [dx, dy] of directions) {
                    const nx = x + dx;
                    const ny = y + dy;
                    
                    if (nx >= 0 && nx < cols && ny >= 0 && ny < rows && 
                        !visited[ny][nx] && !grid[ny][nx]) {
                        visited[ny][nx] = true;
                        queue.push([nx, ny, distance + 1]);
                    }
                }
            }
            
            console.log(`Êú™ÊâæÂà∞Ë∑ØÂæÑÔºåÊúÄÂ§ßÊêúÁ¥¢Ë∑ùÁ¶ª: ${maxDistance}`);
            return false; // Ê≤°ÊúâÊâæÂà∞Ë∑ØÂæÑ
        }
        
        // ÂàõÂª∫ÈùôÊÄÅÈô∑Èò±
        function createTraps(useExistingLayout = false) {
            // Á¨¨‰∏ÄÂÖ≥Ê≤°Êúâ‰ªª‰ΩïÈô∑Èò± - ÂâçÂè∞ÂÆâÂÖ®ÈÄöÈÅì
            if (gameState.currentLevel === 1) {
                return;
            }
            
            // Á¨¨‰∫åÂÖ≥ÁâπÊÆäÂ§ÑÁêÜ - Á¨¨‰∏ÄÈ£üÂ†ÇÂú∞Èõ∑Èòµ
            if (gameState.currentLevel === 2) {
                if (useExistingLayout && gameState.levelLayouts[gameState.currentLevel]) {
                    // ÈáçÁî®Áé∞ÊúâÂú∞Èõ∑Â∏ÉÂ±Ä
                    const layout = gameState.levelLayouts[gameState.currentLevel];
                    
                    // Ëé∑ÂèñÁé©ÂÆ∂ÂΩìÂâç‰ΩçÁΩÆ
                    const playerPixelX = gameState.player.x;
                    const playerPixelY = gameState.player.y;
                    const playerSize = 30;
                    
                    for (const mineData of layout.staticTraps) {
                        if (mineData.isMine && mineData.className === 'maze-wall') {
                            // Âè™ÈáçÂª∫Â¢ôÂ£ÅÔºå‰∏çÈáçÂª∫ÈöêËóèÂú∞Èõ∑
                            const mine = document.createElement('div');
                            mine.className = mineData.className;
                            mine.style.position = 'absolute';
                            mine.style.left = mineData.left + 'px';
                            mine.style.top = mineData.top + 'px';
                            mine.style.width = mineData.width + 'px';
                            mine.style.height = mineData.height + 'px';
                            mine.dataset.isMine = 'true';
                            mine.style.zIndex = '1';
                            
                            // Ëø∑ÂÆ´Â¢ôÂ£ÅÊ†∑Âºè
                            mine.style.backgroundColor = '#8B4513';
                            mine.style.border = '1px solid #654321';
                            mine.style.boxShadow = 'inset 2px 2px 4px rgba(0,0,0,0.3)';
                            
                            gameContainer.appendChild(mine);
                            gameState.traps.push(mine);
                        }
                    }
                } else {
                    createMineField();
                }
                return;
            }
            
            // Â¶ÇÊûúË¶ÅÈáçÁî®Áé∞ÊúâÂ∏ÉÂ±Ä
            if (useExistingLayout && gameState.levelLayouts[gameState.currentLevel]) {
                const layout = gameState.levelLayouts[gameState.currentLevel];
                
                // ÈáçÂª∫ÈùôÊÄÅÈô∑Èò±
                for (const trapData of layout.staticTraps) {
                    const trap = document.createElement('div');
                    trap.className = trapData.className;
                    
                    if (trapData.trapType) {
                        // ÈáçÂª∫ÁâπÊÆäÈô∑Èò±
                        trap.dataset.trapType = trapData.trapType;
                        if (trapData.data) {
                            Object.assign(trap.dataset, trapData.data);
                        }
                        trap.style.width = trapData.width + 'px';
                        trap.style.height = trapData.height + 'px';
                        trap.style.left = trapData.left + 'px';
                        trap.style.bottom = trapData.bottom + 'px';
                    } else if (trapData.className === 'trap') {
                        trap.style.width = trapData.width + 'px';
                        trap.style.height = trapData.height + 'px';
                        trap.style.left = trapData.left + 'px';
                        trap.style.bottom = trapData.bottom + 'px';
                    } else {
                        trap.style.left = trapData.left + 'px';
                    }
                    
                    gameContainer.appendChild(trap);
                    gameState.traps.push(trap);
                }
                return;
            }
            
            // ÁîüÊàêÊñ∞ÁöÑÂ∏ÉÂ±Ä - Á°Æ‰øùÊúâÂèØÈÄöË°åË∑ØÂæÑ
            const seed = generateLevelSeed(gameState.currentLevel);
            let seedCounter = 0;
            let attempts = 0;
            const maxAttempts = 10;
            
            // Ê†πÊçÆÂÖ≥Âç°Êï∞ÈáèÈÄíÂ¢ûÈöæÂ∫¶
            let trapCount;
            if (gameState.currentLevel <= 10) {
                trapCount = gameState.currentLevel * 2; // Á¨¨2ÂÖ≥ÂºÄÂßãÔºå2,4,6,8...‰∏™Èô∑Èò±
            } else if (gameState.currentLevel <= 30) {
                trapCount = 20 + (gameState.currentLevel - 10) * 3; // Á¨¨11ÂÖ≥Ëµ∑ÔºåÊØèÂÖ≥Â¢ûÂä†3‰∏™
            } else if (gameState.currentLevel <= 60) {
                trapCount = 80 + (gameState.currentLevel - 30) * 2; // Á¨¨31ÂÖ≥Ëµ∑ÔºåÊØèÂÖ≥Â¢ûÂä†2‰∏™
            } else {
                trapCount = 140 + (gameState.currentLevel - 60); // Á¨¨61ÂÖ≥Ëµ∑ÔºåÊØèÂÖ≥Â¢ûÂä†1‰∏™
            }
            
            // ÂàùÂßãÂåñÂÖ≥Âç°Â∏ÉÂ±ÄÂ≠òÂÇ®
            if (!gameState.levelLayouts[gameState.currentLevel]) {
                gameState.levelLayouts[gameState.currentLevel] = {
                    staticTraps: [],
                    movingTraps: []
                };
            }
            
            // Áé©ÂÆ∂Ëµ∑Âßã‰ΩçÁΩÆÂíåÈó®ÁöÑ‰ΩçÁΩÆ
            const playerStartX = 50;
            const playerStartY = gameHeight - 100;
            const doorX = gameWidth - 80;
            const doorY = gameHeight - 100;
            
            let validLayout = false;
            
            while (!validLayout && attempts < maxAttempts) {
                attempts++;
                seedCounter = attempts * 1000; // ÊØèÊ¨°Â∞ùËØï‰ΩøÁî®‰∏çÂêåÁöÑÁßçÂ≠êÂÅèÁßª
                
                // ‰∏¥Êó∂Èô∑Èò±Êï∞ÁªÑÁî®‰∫éË∑ØÂæÑÈ™åËØÅ
                const tempTraps = [];
                
                // Ê†πÊçÆÂ∞ùËØïÊ¨°Êï∞Âä®ÊÄÅË∞ÉÊï¥Èô∑Èò±Êï∞Èáè
                const adjustedTrapCount = Math.max(1, trapCount - Math.floor(attempts * trapCount / maxAttempts));
                
                // ÁîüÊàêÈô∑Èò±
                for (let i = 0; i < adjustedTrapCount; i++) {
                    // Ê†πÊçÆÂÖ≥Âç°Èò∂ÊÆµË∞ÉÊï¥Èô∑Èò±ÊØî‰æã
                    let specialChance, spikeChance, trapChance;
                    
                    if (gameState.currentLevel <= 10) {
                        specialChance = Math.min(0.1 + gameState.currentLevel * 0.02, 0.3);
                        spikeChance = 0.5;
                        trapChance = 0.3;
                    } else if (gameState.currentLevel <= 30) {
                        specialChance = 0.4;
                        spikeChance = 0.4;
                        trapChance = 0.2;
                    } else if (gameState.currentLevel <= 60) {
                        specialChance = 0.6;
                        spikeChance = 0.3;
                        trapChance = 0.1;
                    } else {
                        specialChance = 0.7;
                        spikeChance = 0.25;
                        trapChance = 0.05;
                    }
                    
                    const randomValue = seededRandom(seed + seedCounter++);
                    const sizeMultiplier = 1 + gameState.currentLevel * 0.005;
                    
                    let trapData = {};
                    let trapPlaced = false;
                    let placementAttempts = 0;
                    
                    while (!trapPlaced && placementAttempts < 50) {
                        placementAttempts++;
                        
                        if (randomValue < specialChance && gameState.currentLevel >= 3) {
                            // ÁâπÊÆäÈô∑Èò±
                            const width = 40 * sizeMultiplier;
                            const height = 40 * sizeMultiplier;
                            const left = 120 + seededRandom(seed + seedCounter++) * (gameWidth - 240 - width);
                            const top = 60 + seededRandom(seed + seedCounter++) * (gameHeight - height - 120);
                            
                            // Êõ¥‰∏•Ê†ºÁöÑÂÆâÂÖ®Âå∫ÂüüÊ£ÄÊü•
                            const safeRadius = 120; // Â¢ûÂ§ßÂÆâÂÖ®ÂçäÂæÑ
                            const distToStart = Math.sqrt(Math.pow(left + width/2 - playerStartX, 2) + Math.pow(top + height/2 - playerStartY, 2));
                            const distToEnd = Math.sqrt(Math.pow(left + width/2 - doorX, 2) + Math.pow(top + height/2 - doorY, 2));
                            
                            // Ê£ÄÊü•‰∏≠Èó¥ÈÄöÈÅìÂå∫Âüü
                            const midChannelY = gameHeight - 150;
                            const inMidChannel = (top < midChannelY + 50 && top + height > midChannelY - 50);
                            
                            if (distToStart > safeRadius && distToEnd > safeRadius && !inMidChannel) {
                                trapData = {
                                    left: left,
                                    top: top,
                                    width: width,
                                    height: height,
                                    className: 'special-trap'
                                };
                                trapPlaced = true;
                            }
                        } else if (randomValue < specialChance + spikeChance) {
                            // Â∞ñÂà∫Èô∑Èò±
                            const left = 120 + seededRandom(seed + seedCounter++) * (gameWidth - 240 - 30);
                            
                            // Êõ¥‰∏•Ê†ºÁöÑÊ∞¥Âπ≥ÂÆâÂÖ®Ë∑ùÁ¶ª
                            const safeDistance = 100;
                            if (Math.abs(left + 15 - playerStartX) > safeDistance && 
                                Math.abs(left + 15 - doorX) > safeDistance) {
                                trapData = {
                                    left: left,
                                    top: 0,
                                    width: 30,
                                    height: 20,
                                    className: 'spike'
                                };
                                trapPlaced = true;
                            }
                        } else if (randomValue < specialChance + spikeChance + trapChance) {
                            // Áü©ÂΩ¢Èô∑Èò±
                            const width = Math.min((30 + seededRandom(seed + seedCounter++) * 70) * sizeMultiplier, 120);
                            const height = Math.min((20 + seededRandom(seed + seedCounter++) * 50) * sizeMultiplier, 80);
                            const left = 120 + seededRandom(seed + seedCounter++) * (gameWidth - 240 - width);
                            const top = 60 + seededRandom(seed + seedCounter++) * (gameHeight - height - 120);
                            
                            // Êõ¥‰∏•Ê†ºÁöÑÂÆâÂÖ®Âå∫ÂüüÊ£ÄÊü•
                            const safeRadius = 120;
                            const distToStart = Math.sqrt(Math.pow(left + width/2 - playerStartX, 2) + Math.pow(top + height/2 - playerStartY, 2));
                            const distToEnd = Math.sqrt(Math.pow(left + width/2 - doorX, 2) + Math.pow(top + height/2 - doorY, 2));
                            
                            // Ê£ÄÊü•‰∏≠Èó¥ÈÄöÈÅìÂå∫Âüü
                            const midChannelY = gameHeight - 150;
                            const inMidChannel = (top < midChannelY + 50 && top + height > midChannelY - 50);
                            
                            if (distToStart > safeRadius && distToEnd > safeRadius && !inMidChannel) {
                                trapData = {
                                    left: left,
                                    top: top,
                                    width: width,
                                    height: height,
                                    className: 'trap'
                                };
                                trapPlaced = true;
                            }
                        } else {
                            // ÈªòËÆ§Â∞ñÂà∫Èô∑Èò±
                            const left = 120 + seededRandom(seed + seedCounter++) * (gameWidth - 240 - 30);
                            
                            // Êõ¥‰∏•Ê†ºÁöÑÊ∞¥Âπ≥ÂÆâÂÖ®Ë∑ùÁ¶ª
                            const safeDistance = 100;
                            if (Math.abs(left + 15 - playerStartX) > safeDistance && 
                                Math.abs(left + 15 - doorX) > safeDistance) {
                                trapData = {
                                    left: left,
                                    top: 0,
                                    width: 30,
                                    height: 20,
                                    className: 'spike'
                                };
                                trapPlaced = true;
                            }
                        }
                    }
                    
                    if (trapPlaced) {
                        tempTraps.push(trapData);
                    }
                }
                
                // Ê£ÄÊü•ÊòØÂê¶ÊúâÊúâÊïàË∑ØÂæÑ
                if (hasValidPath(tempTraps, playerStartX, playerStartY, doorX, doorY)) {
                    validLayout = true;
                    
                    // ÂàõÂª∫ÂÆûÈôÖÁöÑÈô∑Èò±ÂÖÉÁ¥†
                    tempTraps.forEach((trapData, index) => {
                        const trap = document.createElement('div');
                        
                        if (trapData.className === 'special-trap' && gameState.currentLevel >= 3) {
                            seedCounter = createSpecialTrap(trap, seed, seedCounter + index * 10, 1 + gameState.currentLevel * 0.005);
                        } else {
                            trap.className = trapData.className;
                            trap.style.width = trapData.width + 'px';
                            trap.style.height = trapData.height + 'px';
                            trap.style.left = trapData.left + 'px';
                            
                            if (trapData.className === 'spike') {
                                // Â∞ñÂà∫Èô∑Èò±Âõ∫ÂÆöÂú®Â∫ïÈÉ®
                                trap.style.bottom = '0px';
                            } else {
                                // ËΩ¨Êç¢‰∏∫bottomÂùêÊ†áÁ≥ªÁªü
                                trap.style.bottom = (gameHeight - trapData.top - trapData.height) + 'px';
                            }
                            
                            // ‰øùÂ≠òÂ∏ÉÂ±Ä‰ø°ÊÅØ
                            gameState.levelLayouts[gameState.currentLevel].staticTraps.push({
                                className: trapData.className,
                                width: trapData.width,
                                height: trapData.height,
                                left: trapData.left,
                                bottom: trapData.className === 'spike' ? 0 : (gameHeight - trapData.top - trapData.height)
                            });
                        }
                        
                        gameContainer.appendChild(trap);
                        gameState.traps.push(trap);
                    });
                }
            }
            
            // Â¶ÇÊûúÂ§öÊ¨°Â∞ùËØïÂêé‰ªçÊó†Ê≥ïÁîüÊàêÊúâÊïàÂ∏ÉÂ±ÄÔºåÂàôÁîüÊàê‰∏Ä‰∏™ÁÆÄÂåñÁöÑÂ∏ÉÂ±Ä
            if (!validLayout) {
                console.log(`ÂÖ≥Âç° ${gameState.currentLevel}: Êó†Ê≥ïÁîüÊàêÊúâÊïàË∑ØÂæÑÔºå‰ΩøÁî®ÁÆÄÂåñÂ∏ÉÂ±Ä`);
                
                // ÁîüÊàê‰øùËØÅÂèØÈÄöË°åÁöÑÁÆÄÂåñÂ∏ÉÂ±Ä
                const simpleTrapCount = Math.min(3, Math.max(1, Math.floor(gameState.currentLevel / 10)));
                const safePositions = [];
                
                // ËÆ°ÁÆóÂÆâÂÖ®‰ΩçÁΩÆÔºåÁ°Æ‰øùÁïôÂá∫ÈÄöÈÅì
                const channelWidth = 150; // ÈÄöÈÅìÂÆΩÂ∫¶
                const channelCenterX = gameWidth / 2;
                
                for (let i = 0; i < simpleTrapCount; i++) {
                    let trapX;
                    if (i % 2 === 0) {
                        // Â∑¶‰æßÈô∑Èò±
                        trapX = 150 + (i / 2) * 100;
                        if (trapX > channelCenterX - channelWidth / 2 - 50) {
                            trapX = channelCenterX - channelWidth / 2 - 50;
                        }
                    } else {
                        // Âè≥‰æßÈô∑Èò±
                        trapX = channelCenterX + channelWidth / 2 + 50 + Math.floor(i / 2) * 100;
                        if (trapX > gameWidth - 200) {
                            trapX = gameWidth - 200;
                        }
                    }
                    
                    // Á°Æ‰øù‰∏ç‰∏éËµ∑ÂßãÁÇπÂíåÁªàÁÇπÂÜ≤Á™Å
                    if (Math.abs(trapX - playerStartX) > 80 && Math.abs(trapX - doorX) > 80) {
                        safePositions.push(trapX);
                    }
                }
                
                // ÂàõÂª∫ÁÆÄÂåñÈô∑Èò±
                for (let i = 0; i < Math.min(safePositions.length, simpleTrapCount); i++) {
                    const trap = document.createElement('div');
                    trap.className = 'spike';
                    trap.style.left = safePositions[i] + 'px';
                    trap.style.bottom = '0px';
                    trap.style.width = '30px';
                    trap.style.height = '20px';
                    
                    gameState.levelLayouts[gameState.currentLevel].staticTraps.push({
                        className: 'spike',
                        left: safePositions[i],
                        width: 30,
                        height: 20
                    });
                    
                    gameContainer.appendChild(trap);
                    gameState.traps.push(trap);
                }
                
                // È™åËØÅÁÆÄÂåñÂ∏ÉÂ±ÄÊòØÂê¶ÂèØÈÄöË°å
                const simplifiedTraps = safePositions.map(x => ({
                    left: x,
                    top: 0,
                    width: 30,
                    height: 20,
                    className: 'spike'
                }));
                
                if (hasValidPath(simplifiedTraps, playerStartX, playerStartY, doorX, doorY)) {
                    console.log(`ÂÖ≥Âç° ${gameState.currentLevel}: ÁÆÄÂåñÂ∏ÉÂ±ÄÈ™åËØÅÈÄöËøá`);
                } else {
                    console.log(`ÂÖ≥Âç° ${gameState.currentLevel}: ÁÆÄÂåñÂ∏ÉÂ±ÄÈ™åËØÅÂ§±Ë¥•Ôºå‰ΩøÁî®ÊúÄÂ∞èÂ∏ÉÂ±Ä`);
                    // Ê∏ÖÈô§ÊâÄÊúâÈô∑Èò±ÔºåÂè™‰øùÁïô‰∏Ä‰∏™ËøúÁ¶ªÈÄöÈÅìÁöÑÈô∑Èò±
                    gameState.traps.forEach(trap => trap.remove());
                    gameState.traps = [];
                    gameState.levelLayouts[gameState.currentLevel].staticTraps = [];
                    
                    if (gameState.currentLevel > 1) {
                        const trap = document.createElement('div');
                        trap.className = 'spike';
                        trap.style.left = (gameWidth * 0.3) + 'px';
                        trap.style.bottom = '0px';
                        trap.style.width = '30px';
                        trap.style.height = '20px';
                        
                        gameState.levelLayouts[gameState.currentLevel].staticTraps.push({
                            className: 'spike',
                            left: gameWidth * 0.3,
                            width: 30,
                            height: 20
                        });
                        
                        gameContainer.appendChild(trap);
                        gameState.traps.push(trap);
                    }
                }
            } else {
                console.log(`ÂÖ≥Âç° ${gameState.currentLevel}: ÊàêÂäüÁîüÊàêÊúâÊïàË∑ØÂæÑÂ∏ÉÂ±Ä (Â∞ùËØïÊ¨°Êï∞: ${attempts})`);
            }
        }

        // ËÆæÁΩÆÁßªÂä®Èô∑Èò±
        function setupMovingTraps(useExistingLayout = false) {
            // Á¨¨1-3ÂÖ≥Ê≤°ÊúâÁßªÂä®Èô∑Èò±
            if (gameState.currentLevel <= 3) {
                return;
            }
            
            // Â¶ÇÊûúË¶ÅÈáçÁî®Áé∞ÊúâÂ∏ÉÂ±Ä
            if (useExistingLayout && gameState.levelLayouts[gameState.currentLevel]) {
                const layout = gameState.levelLayouts[gameState.currentLevel];
                
                // ÈáçÂª∫ÁßªÂä®Èô∑Èò±
                for (const trapData of layout.movingTraps) {
                    const movingTrap = document.createElement('div');
                    movingTrap.className = 'moving-trap';
                    
                    movingTrap.style.left = trapData.startX + 'px';
                    movingTrap.style.top = trapData.startY + 'px';
                    
                    gameContainer.appendChild(movingTrap);
                    gameState.movingTraps.push({
                        element: movingTrap,
                        x: trapData.startX,
                        y: trapData.startY,
                        speedX: trapData.speedX,
                        speedY: trapData.speedY
                    });
                }
                
                // ÂºÄÂßãÁßªÂä®Èô∑Èò±
                if (trapInterval) clearInterval(trapInterval);
                const updateInterval = Math.max(15, 35 - gameState.currentLevel * 0.2);
                trapInterval = setInterval(moveTraps, updateInterval);
                return;
            }
            
            // ÁîüÊàêÊñ∞ÁöÑÁßªÂä®Èô∑Èò±Â∏ÉÂ±Ä
            const seed = generateLevelSeed(gameState.currentLevel);
            let seedCounter = 1000; // ‰ΩøÁî®‰∏çÂêåÁöÑËµ∑ÂßãÂÄºÈÅøÂÖç‰∏éÈùôÊÄÅÈô∑Èò±ÂÜ≤Á™Å
            
            // Ê†πÊçÆÂÖ≥Âç°ÈÄíÂ¢ûÁßªÂä®Èô∑Èò±Êï∞Èáè
            let movingTrapCount;
            if (gameState.currentLevel <= 15) {
                movingTrapCount = Math.floor((gameState.currentLevel - 3) / 3); // Á¨¨4ÂÖ≥ÂºÄÂßãÔºåÊØè3ÂÖ≥Â¢ûÂä†1‰∏™
            } else if (gameState.currentLevel <= 50) {
                movingTrapCount = 4 + Math.floor((gameState.currentLevel - 15) / 5); // Á¨¨16ÂÖ≥Ëµ∑ÔºåÊØè5ÂÖ≥Â¢ûÂä†1‰∏™
            } else {
                movingTrapCount = Math.min(11 + Math.floor((gameState.currentLevel - 50) / 10), 20); // Á¨¨51ÂÖ≥Ëµ∑ÔºåÊØè10ÂÖ≥Â¢ûÂä†1‰∏™ÔºåÊúÄÂ§ö20‰∏™
            }
            
            for (let i = 0; i < movingTrapCount; i++) {
                const movingTrap = document.createElement('div');
                movingTrap.className = 'moving-trap';
                
                // ‰ΩøÁî®ÁßçÂ≠êÁîüÊàêÂõ∫ÂÆöÁöÑÂàùÂßã‰ΩçÁΩÆÂíåÁßªÂä®ÊñπÂêëÔºåÈÅøÂºÄËµ∑ÂßãÁÇπÂíåÈó®Âè£
                let startX, startY;
                let attempts = 0;
                do {
                    startX = 100 + seededRandom(seed + seedCounter++) * (gameWidth - 200);
                    startY = 50 + seededRandom(seed + seedCounter++) * (gameHeight - 100);
                    attempts++;
                } while (attempts < 20 && (
                    (startX < 150 && startY > gameHeight - 150) || // ÈÅøÂºÄËµ∑ÂßãÂå∫Âüü
                    (startX > gameWidth - 150 && startY > gameHeight - 150) // ÈÅøÂºÄÈó®Âè£Âå∫Âüü
                ));
                
                // Ê†πÊçÆÂÖ≥Âç°Ë∞ÉÊï¥ÁßªÂä®ÈÄüÂ∫¶
                const baseSpeed = 2 + gameState.currentLevel * 0.05; // ÈÄüÂ∫¶ÈöèÂÖ≥Âç°Â¢ûÂä†
                const maxSpeed = Math.min(baseSpeed, 8); // ÈôêÂà∂ÊúÄÂ§ßÈÄüÂ∫¶
                const speedX = (seededRandom(seed + seedCounter++) - 0.5) * maxSpeed;
                const speedY = (seededRandom(seed + seedCounter++) - 0.5) * maxSpeed;
                
                movingTrap.style.left = startX + 'px';
                movingTrap.style.top = startY + 'px';
                
                gameContainer.appendChild(movingTrap);
                gameState.movingTraps.push({
                    element: movingTrap,
                    x: startX,
                    y: startY,
                    speedX: speedX,
                    speedY: speedY
                });
                
                // ‰øùÂ≠òÁßªÂä®Èô∑Èò±Â∏ÉÂ±Ä‰ø°ÊÅØ
                gameState.levelLayouts[gameState.currentLevel].movingTraps.push({
                    startX: startX,
                    startY: startY,
                    speedX: speedX,
                    speedY: speedY
                });
            }
            
            // ÂºÄÂßãÁßªÂä®Èô∑Èò±ÔºåÈ´òÂÖ≥Âç°Êõ¥Êñ∞È¢ëÁéáÊõ¥È´ò
            if (trapInterval) clearInterval(trapInterval);
            const updateInterval = Math.max(15, 35 - gameState.currentLevel * 0.2); // Êõ¥Êñ∞Èó¥ÈöîÈöèÂÖ≥Âç°ÂáèÂ∞ë
            trapInterval = setInterval(moveTraps, updateInterval);
        }

        // ÁßªÂä®Èô∑Èò±
        function moveTraps() {
            gameState.movingTraps.forEach(trap => {
                trap.x += trap.speedX;
                trap.y += trap.speedY;
                
                // ËæπÁïåÊ£ÄÊµã
                if (trap.x <= 0 || trap.x >= gameWidth - 40) {
                    trap.speedX *= -1;
                }
                if (trap.y <= 0 || trap.y >= gameHeight - 40) {
                    trap.speedY *= -1;
                }
                
                trap.element.style.left = trap.x + 'px';
                trap.element.style.top = trap.y + 'px';
            });
        }

        // Êõ¥Êñ∞Áé©ÂÆ∂‰ΩçÁΩÆ
        function updatePlayerPosition() {
            player.style.left = gameState.player.x + 'px';
            player.style.top = gameState.player.y + 'px';
        }
        
        // Êõ¥Êñ∞Èó®ÁöÑ‰ΩçÁΩÆ
        function updateDoorPosition() {
            if (gameState.currentLevel === 2) {
                // Á¨¨‰∫åÂÖ≥ÔºöÈó®Âú®Ëø∑ÂÆ´ÁªàÁÇπÔºå‰ΩøÁî®ÂÖ®Â±ÄÂèòÈáèÂ≠òÂÇ®ÁöÑÁªàÁÇπ‰ΩçÁΩÆ
                if (window.mazeEndPoint) {
                    const gridSize = 40;
                    const doorX = window.mazeEndPoint.x * gridSize;
                    const doorY = window.mazeEndPoint.y * gridSize;
                    
                    door.style.right = 'auto';
                    door.style.left = doorX + 'px';
                    door.style.bottom = 'auto';
                    door.style.top = doorY + 'px';
                    
                    console.log(`Èó®‰ΩçÁΩÆÊõ¥Êñ∞: ÁΩëÊ†º(${window.mazeEndPoint.x}, ${window.mazeEndPoint.y}), ÂÉèÁ¥†(${doorX}, ${doorY})`);
                } else {
                    // Â¶ÇÊûúÊ≤°ÊúâÁªàÁÇπ‰ø°ÊÅØÔºå‰ΩøÁî®ÈªòËÆ§‰ΩçÁΩÆ
                    console.warn('Ê≤°ÊúâËø∑ÂÆ´ÁªàÁÇπ‰ø°ÊÅØÔºå‰ΩøÁî®ÈªòËÆ§Èó®‰ΩçÁΩÆ');
                    const gridSize = 40;
                    const cols = Math.floor(gameWidth / gridSize);
                    const rows = Math.floor(gameHeight / gridSize);
                    const doorX = (cols - 2) * gridSize;
                    const doorY = (rows - 2) * gridSize;
                    
                    door.style.right = 'auto';
                    door.style.left = doorX + 'px';
                    door.style.bottom = 'auto';
                    door.style.top = doorY + 'px';
                }
            } else {
                // ÂÖ∂‰ªñÂÖ≥Âç°ÔºöÈó®Âú®Âè≥‰æß
                door.style.left = 'auto';
                door.style.right = '20px';
                door.style.top = 'auto';
                door.style.bottom = '0';
            }
        }
        
        // Âæ™ÁéØÊ¨°Êï∞Áõ∏ÂÖ≥ÂáΩÊï∞
        function initLoopCounter() {
            // ÂàùÂßãÂåñÂΩìÂâçÂÖ≥Âç°ÁöÑÂæ™ÁéØÊ¨°Êï∞
            if (!gameState.levelLoopCounts[gameState.currentLevel]) {
                gameState.levelLoopCounts[gameState.currentLevel] = 0;
            }
            gameState.loopCount = gameState.levelLoopCounts[gameState.currentLevel];
            updateLoopCounterDisplay();
        }
        
        function incrementLoopCount() {
            // Â¢ûÂä†Âæ™ÁéØÊ¨°Êï∞
            gameState.loopCount++;
            gameState.levelLoopCounts[gameState.currentLevel] = gameState.loopCount;
            updateLoopCounterDisplay();
            
            // ÊòæÁ§∫Âæ™ÁéØÊèêÁ§∫Ê∂àÊÅØ
            if (gameState.currentLevel === 2) {
                if (gameState.loopCount === 1) {
                    showLoopMessage('üîÑ ÂºÄÂßãÂæ™ÁéØÔºÅÊØèÊ¨°Â§±Ë¥•ÈÉΩÊòØÂ≠¶‰π†ÁöÑÊú∫‰ºö');
                } else if (gameState.loopCount === 5) {
                    showLoopMessage('üí™ Á¨¨5Ê¨°Âæ™ÁéØÔºÅ‰Ω†Ê≠£Âú®ÊéåÊè°Ëø∑ÂÆ´ÁöÑÁßòÂØÜ');
                } else if (gameState.loopCount === 10) {
                    showLoopMessage('üéØ Á¨¨10Ê¨°Âæ™ÁéØÔºÅÂùöÊåÅÂ∞±ÊòØËÉúÂà©');
                } else if (gameState.loopCount % 15 === 0) {
                    showLoopMessage(`üåü Á¨¨${gameState.loopCount}Ê¨°Âæ™ÁéØÔºÅÊ∞∏‰∏çÊîæÂºÉÁöÑÁ≤æÁ•ûÂÄºÂæóÊï¨‰Ω©`);
                }
            }
        }
        
        function updateLoopCounterDisplay() {
            // Êõ¥Êñ∞Âæ™ÁéØÊ¨°Êï∞ÊòæÁ§∫
            if (gameState.currentLevel === 2) {
                loopCounterDisplay.style.display = 'inline';
                loopCountDisplay.textContent = gameState.loopCount;
            } else {
                loopCounterDisplay.style.display = 'none';
            }
        }
        
        function showLoopMessage(message) {
            // ÊòæÁ§∫Âæ™ÁéØÁõ∏ÂÖ≥ÁöÑÈºìÂä±Ê∂àÊÅØ
            messageDisplay.textContent = message;
            messageDisplay.style.color = '#ff6b6b';
            setTimeout(() => {
                if (messageDisplay.textContent === message) {
                    messageDisplay.textContent = '';
                    messageDisplay.style.color = '';
                }
            }, 3000);
        }
        
        function resetLoopCounter() {
            // ÈáçÁΩÆÂΩìÂâçÂÖ≥Âç°ÁöÑÂæ™ÁéØÊ¨°Êï∞ÔºàËøõÂÖ•Êñ∞ÂÖ≥Âç°Êó∂Ë∞ÉÁî®Ôºâ
            gameState.loopCount = 0;
            gameState.levelLoopCounts[gameState.currentLevel] = 0;
            updateLoopCounterDisplay();
        }

        // Â§ÑÁêÜÁâπÊÆäÈô∑Èò±
        function handleSpecialTrap(trap) {
            const trapType = trap.dataset.trapType;
            
            switch(trapType) {
                case 'teleport':
                    // ‰º†ÈÄÅÈô∑Èò±ÔºöÈöèÊú∫‰º†ÈÄÅÁé©ÂÆ∂
                    playClickSound(); // ‰º†ÈÄÅÈü≥Êïà
                    gameState.player.x = 50 + Math.random() * (gameWidth - 150);
                    gameState.player.y = 50 + Math.random() * (gameHeight - 100);
                    updatePlayerPosition();
                    messageDisplay.textContent = 'üí´ ‰º†ÈÄÅ‰∫ÜÔºÅ';
                    setTimeout(() => {
                        if (messageDisplay.textContent.includes('‰º†ÈÄÅ‰∫Ü')) {
                            messageDisplay.textContent = '';
                        }
                    }, 1500);
                    break;
                    
                case 'freeze':
                    // ÂÜ∞ÂÜªÈô∑Èò±ÔºöÂÜªÁªìÁé©ÂÆ∂3Áßí
                    gameState.playerFrozen = true;
                    gameState.freezeEndTime = Date.now() + 3000;
                    player.style.filter = 'hue-rotate(240deg) brightness(0.7)';
                    messageDisplay.textContent = 'üßä Ë¢´ÂÜ∞ÂÜª‰∫ÜÔºÅ';
                    setTimeout(() => {
                        gameState.playerFrozen = false;
                        player.style.filter = '';
                        if (messageDisplay.textContent.includes('Ë¢´ÂÜ∞ÂÜª‰∫Ü')) {
                            messageDisplay.textContent = '';
                        }
                    }, 3000);
                    break;
                    
                case 'split':
                    // ÂàÜË£ÇÈô∑Èò±ÔºöÂàÜË£ÇÊàê4‰∏™Â∞èÈô∑Èò±
                    if (trap.dataset.hasTriggered === 'false') {
                        trap.dataset.hasTriggered = 'true';
                        createSplitTraps(trap);
                        trap.remove();
                        gameState.traps = gameState.traps.filter(t => t !== trap);
                    }
                    break;
                    
                case 'gravity':
                    // ÈáçÂäõÈô∑Èò±ÔºöÊääÁé©ÂÆ∂ÊãâÂêë‰∏≠ÂøÉÁÑ∂ÂêéÁàÜÁÇ∏
                    const trapRect = trap.getBoundingClientRect();
                    const centerX = trapRect.left + trapRect.width / 2 - gameContainer.getBoundingClientRect().left;
                    const centerY = trapRect.top + trapRect.height / 2 - gameContainer.getBoundingClientRect().top;
                    gameState.player.x = centerX - 20;
                    gameState.player.y = centerY - 25;
                    updatePlayerPosition();
                    setTimeout(() => gameOver(), 500);
                    break;
                    
                case 'bounce':
                    // ÂºπË∑≥Èô∑Èò±ÔºöÊääÁé©ÂÆ∂ÂºπÂà∞ÈöèÊú∫ÊñπÂêë
                    playClickSound();
                    const bounceForce = 100;
                    const angle = Math.random() * 2 * Math.PI;
                    gameState.player.x += Math.cos(angle) * bounceForce;
                    gameState.player.y += Math.sin(angle) * bounceForce;
                    
                    // Á°Æ‰øùÁé©ÂÆ∂‰∏ç‰ºöË¢´ÂºπÂá∫ËæπÁïå
                    gameState.player.x = Math.max(0, Math.min(gameWidth - 40, gameState.player.x));
                    gameState.player.y = Math.max(0, Math.min(gameHeight - 50, gameState.player.y));
                    updatePlayerPosition();
                    
                    messageDisplay.textContent = 'üèÄ Ë¢´ÂºπÈ£û‰∫ÜÔºÅ';
                    setTimeout(() => {
                        if (messageDisplay.textContent.includes('Ë¢´ÂºπÈ£û‰∫Ü')) {
                            messageDisplay.textContent = '';
                        }
                    }, 1500);
                    break;
                    
                case 'shrink':
                    // Áº©Â∞èÈô∑Èò±ÔºöËÆ©Áé©ÂÆ∂ÂèòÂ∞è5Áßí
                    player.style.transform = 'scale(0.5)';
                    messageDisplay.textContent = 'üîç ÂèòÂ∞è‰∫ÜÔºÅ';
                    setTimeout(() => {
                        player.style.transform = '';
                        if (messageDisplay.textContent.includes('ÂèòÂ∞è‰∫Ü')) {
                            messageDisplay.textContent = '';
                        }
                    }, 5000);
                    break;
                    
                case 'speed':
                    // Âä†ÈÄüÈô∑Èò±ÔºöËÆ©Áé©ÂÆ∂ÁßªÂä®ÈÄüÂ∫¶ÁøªÂÄç5Áßí
                    const originalSpeed = playerSpeed;
                    playerSpeed *= 2;
                    player.style.filter = 'hue-rotate(120deg) brightness(1.2)';
                    messageDisplay.textContent = '‚ö° Âä†ÈÄü‰∫ÜÔºÅ';
                    setTimeout(() => {
                        playerSpeed = originalSpeed;
                        player.style.filter = '';
                        if (messageDisplay.textContent.includes('Âä†ÈÄü‰∫Ü')) {
                            messageDisplay.textContent = '';
                        }
                    }, 5000);
                    break;
                    
                case 'clone':
                    // ÂÖãÈöÜÈô∑Èò±ÔºöÂàõÂª∫Áé©ÂÆ∂ÁöÑÈïúÂÉè
                    if (trap.dataset.hasTriggered === 'false') {
                        trap.dataset.hasTriggered = 'true';
                        createPlayerClone();
                        messageDisplay.textContent = 'üë• Âá∫Áé∞‰∫ÜÂàÜË∫´ÔºÅ';
                        setTimeout(() => {
                            if (messageDisplay.textContent.includes('Âá∫Áé∞‰∫ÜÂàÜË∫´')) {
                                messageDisplay.textContent = '';
                            }
                        }, 2000);
                    }
                    break;
                    
                default:
                    // ÂÖ∂‰ªñÁâπÊÆäÈô∑Èò±‰πü‰ºöÂØºËá¥Ê∏∏ÊàèÁªìÊùü
                    gameOver();
                    break;
            }
        }

        // ÂàõÂª∫ÂàÜË£ÇÁöÑÂ∞èÈô∑Èò±
        function createSplitTraps(originalTrap) {
            const rect = originalTrap.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2 - gameContainer.getBoundingClientRect().left;
            const centerY = rect.top + rect.height / 2 - gameContainer.getBoundingClientRect().top;
            
            const directions = [
                {x: -1, y: -1}, {x: 1, y: -1}, 
                {x: -1, y: 1}, {x: 1, y: 1}
            ];
            
            directions.forEach((dir, index) => {
                setTimeout(() => {
                    const smallTrap = document.createElement('div');
                    smallTrap.className = 'trap';
                    smallTrap.style.width = '20px';
                    smallTrap.style.height = '20px';
                    smallTrap.style.left = (centerX + dir.x * 30) + 'px';
                    smallTrap.style.top = (centerY + dir.y * 30) + 'px';
                    smallTrap.style.position = 'absolute';
                    
                    gameContainer.appendChild(smallTrap);
                    gameState.traps.push(smallTrap);
                }, index * 100);
            });
        }

        // ÂàõÂª∫Áé©ÂÆ∂ÂÖãÈöÜ
        function createPlayerClone() {
            const clone = document.createElement('div');
            clone.className = 'player-clone';
            clone.innerHTML = 'üßô‚Äç‚ôÇÔ∏è';
            clone.style.position = 'absolute';
            clone.style.width = '40px';
            clone.style.height = '50px';
            clone.style.fontSize = '40px';
            clone.style.display = 'flex';
            clone.style.alignItems = 'center';
            clone.style.justifyContent = 'center';
            clone.style.zIndex = '3';
            clone.style.opacity = '0.7';
            clone.style.filter = 'hue-rotate(180deg)';
            
            // ÂÖãÈöÜÂá∫Áé∞Âú®Áé©ÂÆ∂ÈôÑËøëÁöÑÈöèÊú∫‰ΩçÁΩÆ
            const offsetX = (Math.random() - 0.5) * 200;
            const offsetY = (Math.random() - 0.5) * 200;
            clone.style.left = Math.max(0, Math.min(gameWidth - 40, gameState.player.x + offsetX)) + 'px';
            clone.style.top = Math.max(0, Math.min(gameHeight - 50, gameState.player.y + offsetY)) + 'px';
            
            gameContainer.appendChild(clone);
            
            // ÂÖãÈöÜ‰ºöË∑üÈöèÁé©ÂÆ∂ÁßªÂä®Ôºå‰ΩÜÊúâÂª∂Ëøü
            let cloneX = parseFloat(clone.style.left);
            let cloneY = parseFloat(clone.style.top);
            
            const cloneInterval = setInterval(() => {
                if (gameState.gameOver) {
                    clearInterval(cloneInterval);
                    clone.remove();
                    return;
                }
                
                // ÂÖãÈöÜÁºìÊÖ¢Ë∑üÈöèÁé©ÂÆ∂
                const dx = gameState.player.x - cloneX;
                const dy = gameState.player.y - cloneY;
                cloneX += dx * 0.1;
                cloneY += dy * 0.1;
                
                clone.style.left = cloneX + 'px';
                clone.style.top = cloneY + 'px';
            }, 50);
            
            // 10ÁßíÂêéÁßªÈô§ÂÖãÈöÜ
            setTimeout(() => {
                clearInterval(cloneInterval);
                if (clone.parentNode) {
                    clone.remove();
                }
            }, 10000);
        }

        // Âü∫‰∫éÁΩëÊ†ºÁöÑÁ¢∞ÊíûÊ£ÄÊµã
        function checkCollisions() {
            const playerRect = player.getBoundingClientRect();
            const doorRect = door.getBoundingClientRect();
            const sm = gameState.specialMechanics;
            
            // Ê£ÄÊü•ÁâπÊÆäÂÖÉÁ¥†‰∫§‰∫í
            checkSpecialElementInteractions(playerRect);
            
            // Êõ¥Êñ∞ËÆ°Êó∂Âô®
            updateTimer();
            
            // Ê£ÄÊü•ÊòØÂê¶Êª°Ë∂≥ÈÄöÂÖ≥Êù°‰ª∂
            if (!canPassLevel()) {
                return;
            }
            
            // Ê£ÄÊü•ÊòØÂê¶ÂÆåÂÖ®ËøõÂÖ•Èó®ÂÜÖÔºàÁé©ÂÆ∂ÈúÄË¶ÅÂÆåÂÖ®Âú®Èó®ÁöÑËåÉÂõ¥ÂÜÖÔºâ
            if (playerRect.left >= doorRect.left + 5 && 
                playerRect.right <= doorRect.right - 5 && 
                playerRect.bottom >= doorRect.top + 5 && 
                playerRect.top <= doorRect.bottom - 5) {
                levelComplete();
                return;
            }
            
            // ÂØπ‰∫éÁ¨¨‰∫åÂÖ≥ÔºàËø∑ÂÆ´ÂÖ≥Âç°ÔºâÔºå‰ΩøÁî®ÁΩëÊ†ºÁ¢∞ÊíûÊ£ÄÊµã
            if (gameState.currentLevel === 2) {
                checkGridCollisions();
                return;
            }
            
            // ÂÖ∂‰ªñÂÖ≥Âç°‰ΩøÁî®ÂéüÊúâÁöÑÂÉèÁ¥†Á¢∞ÊíûÊ£ÄÊµã
            checkPixelCollisions();
        }
        
        // ÁΩëÊ†ºÁ¢∞ÊíûÊ£ÄÊµãÔºàÁî®‰∫éËø∑ÂÆ´ÂÖ≥Âç°Ôºâ
        function checkGridCollisions() {
            const gridSize = 40; // ‰∏éËø∑ÂÆ´ÁîüÊàêÊó∂ÁöÑÁΩëÊ†ºÂ§ßÂ∞è‰∏ÄËá¥
            
            // ËÆ°ÁÆóÁé©ÂÆ∂Âç†Áî®ÁöÑÁΩëÊ†º‰ΩçÁΩÆÔºàÁé©ÂÆ∂Â§ßÂ∞è40x50Ôºå‰ΩøÁî®‰∏≠ÂøÉÁÇπÔºâ
            const playerCenterX = gameState.player.x + 20; // Áé©ÂÆ∂ÂÆΩÂ∫¶40Ôºå‰∏≠ÂøÉÁÇπ+20
            const playerCenterY = gameState.player.y + 25; // Áé©ÂÆ∂È´òÂ∫¶50Ôºå‰∏≠ÂøÉÁÇπ+25
            const playerGridX = Math.floor(playerCenterX / gridSize);
            const playerGridY = Math.floor(playerCenterY / gridSize);
            
            console.log(`Áé©ÂÆ∂‰ΩçÁΩÆ: (${gameState.player.x}, ${gameState.player.y}), ÁΩëÊ†º: (${playerGridX}, ${playerGridY})`);
            
            // Âè™Ê£ÄÊü•Â¢ôÂ£ÅÁ¢∞Êíû
            for (const trap of gameState.traps) {
                if (trap.className === 'maze-wall') {
                    // ËÆ°ÁÆóÂ¢ôÂ£ÅÁöÑÁΩëÊ†º‰ΩçÁΩÆ
                    const wallLeft = parseInt(trap.style.left);
                    const wallTop = parseInt(trap.style.top);
                    const wallGridX = Math.floor(wallLeft / gridSize);
                    const wallGridY = Math.floor(wallTop / gridSize);
                    
                    // Â¶ÇÊûúÁé©ÂÆ∂ÁΩëÊ†º‰ΩçÁΩÆ‰∏éÂ¢ôÂ£ÅÁΩëÊ†º‰ΩçÁΩÆÈáçÂè†ÔºåÂàôÁ¢∞Êíû
                    if (playerGridX === wallGridX && playerGridY === wallGridY) {
                        console.log(`ÁΩëÊ†ºÁ¢∞ÊíûÔºÅÁé©ÂÆ∂(${playerGridX}, ${playerGridY})ÊíûÂ¢ô(${wallGridX}, ${wallGridY})`);
                        // Â¢ôÂ£ÅÁàÜÁÇ∏ÊïàÊûú
                        trap.classList.add('exploded');
                        trap.style.background = 'radial-gradient(circle, #ff4444, #cc0000)';
                        trap.style.border = '2px solid #ff0000';
                        
                        setTimeout(() => {
                            gameOver();
                        }, 200);
                        return;
                    }
                }
            }
            
            // Ê£ÄÊü•ËæπÁïå
            if (gameState.player.x < 0 || gameState.player.x > gameWidth - 40 ||
                gameState.player.y < 0 || gameState.player.y > gameHeight - 50) {
                gameOver();
                return;
            }
        }
        
        // ÂÉèÁ¥†Á¢∞ÊíûÊ£ÄÊµãÔºàÁî®‰∫éÂÖ∂‰ªñÂÖ≥Âç°Ôºâ
        function checkPixelCollisions() {
            const playerRect = player.getBoundingClientRect();
            
            // Ê£ÄÊü•‰∏éÈùôÊÄÅÈô∑Èò±ÁöÑÁ¢∞Êíû
            for (const trap of gameState.traps) {
                const trapRect = trap.getBoundingClientRect();
                
                if (playerRect.right > trapRect.left && 
                    playerRect.left < trapRect.right && 
                    playerRect.bottom > trapRect.top && 
                    playerRect.top < trapRect.bottom) {
                    
                    // Â§ÑÁêÜÂú∞Èõ∑
                    if (trap.dataset.isMine === 'true') {
                        // Âú∞Èõ∑ÁàÜÁÇ∏ÊïàÊûú
                        trap.classList.add('exploded');
                        trap.style.background = 'radial-gradient(circle, #ff4444, #cc0000)';
                        trap.style.border = '2px solid #ff0000';
                        trap.style.borderRadius = '50%';
                        
                        // Âª∂ËøüÊ∏∏ÊàèÁªìÊùüÔºåËÆ©Áé©ÂÆ∂ÁúãÂà∞ÁàÜÁÇ∏ÊïàÊûú
                        setTimeout(() => {
                            gameOver();
                        }, 200);
                        return;
                    }
                    
                    // Â§ÑÁêÜÁâπÊÆäÈô∑Èò±
                    if (trap.dataset.trapType) {
                        // Èó™ÁÉÅÈô∑Èò±Âú®‰∏çÂèØËßÅÊó∂‰∏ç‰ºöÈÄ†Êàê‰º§ÂÆ≥
                        if (trap.dataset.trapType === 'blink' && trap.dataset.visible === 'false') {
                            continue;
                        }
                        handleSpecialTrap(trap);
                    } else {
                        gameOver();
                    }
                    return;
                }
            }
            
            // Ê£ÄÊü•‰∏éÁßªÂä®Èô∑Èò±ÁöÑÁ¢∞Êíû
            for (const trap of gameState.movingTraps) {
                const trapRect = trap.element.getBoundingClientRect();
                if (playerRect.right > trapRect.left && 
                    playerRect.left < trapRect.right && 
                    playerRect.bottom > trapRect.top && 
                    playerRect.top < trapRect.bottom) {
                    gameOver();
                    return;
                }
            }
            
            // Ê£ÄÊü•ËæπÁïå
            if (gameState.player.x < 0 || gameState.player.x > gameWidth - 40 ||
                gameState.player.y < 0 || gameState.player.y > gameHeight - 50) {
                gameOver();
                return;
            }
        }

        // ÂÖ≥Âç°ÂÆåÊàê
        function levelComplete() {
            // Èò≤Ê≠¢ÈáçÂ§çË∞ÉÁî®
            if (gameState.gameOver) return;
            gameState.gameOver = true;
            
            // Êí≠ÊîæËøáÂÖ≥Èü≥Êïà
            playSuccessSound();
            
            // Ê∑ªÂä†ËøáÂÖ≥ÁâπÊïà
            const sparkle = document.createElement('div');
            sparkle.className = 'level-complete';
            sparkle.style.left = (gameState.player.x - 30) + 'px';
            sparkle.style.top = (gameState.player.y - 25) + 'px';
            gameContainer.appendChild(sparkle);
            
            // ÁßªÈô§ÁâπÊïà
            setTimeout(() => {
                sparkle.remove();
            }, 1000);
            
            // Ëß£ÈîÅ‰∏ã‰∏ÄÂÖ≥
            if (gameState.currentLevel === gameState.maxUnlockedLevel && gameState.currentLevel < gameState.maxLevel) {
                gameState.maxUnlockedLevel = gameState.currentLevel + 1;
                saveProgress();
            }
            
            if (gameState.currentLevel === gameState.maxLevel) {
                // ÊòæÁ§∫Zack
                const zackDisplay = document.createElement('div');
                zackDisplay.className = 'zack-display';
                zackDisplay.textContent = 'üë®‚Äçüíº';
                gameContainer.appendChild(zackDisplay);
                
                messageDisplay.textContent = 'üéâ ÊÅ≠ÂñúÔºÅ‰Ω†ÊàêÂäüÊãØÊïë‰∫ÜZackÔºÅ';
                setTimeout(() => {
                    messageDisplay.textContent = 'üë®‚Äçüíº Zack: "Ë∞¢Ë∞¢‰Ω†Êïë‰∫ÜÊàëÔºÅ‰Ωú‰∏∫Â•ñÂä±Ôºå‰∏ã‰∏Ä‰ªªCEOÂ∞±ÊòØ‰Ω†‰∫ÜÔºÅ"';
                    setTimeout(() => {
                        messageDisplay.textContent = 'üèÜ Ê∏∏ÊàèÂÆåÊàêÔºÅ‰Ω†ÂèØ‰ª•ÈáçÊñ∞ÊåëÊàò‰ªªÊÑèÂÖ≥Âç°';
                        zackDisplay.remove();
                        updateProgressDisplay();
                    }, 3000);
                }, 3000);
            } else {
                const stageMessages = [
                    '‚ú® ËßâÈÜí‰πãÂÖâÊõ¥Âä†Êòé‰∫Æ...',
                    'üîÆ ËÆ∞ÂøÜÁ¢éÁâáÈÄêÊ∏êÊãºÂêà...',
                    'üëª ÂπªË±°ÂºÄÂßãÊ∂àÊï£...',
                    'üßä ÂØíÂÜ∞Êó†Ê≥ïÈòªÊå°ÂâçËøõ...',
                    'üí• Âú®Â¥©Âùè‰∏≠ÂØªÊâæÁß©Â∫è...',
                    'ü™û ÁúüÁõ∏Âú®ÈïúÂÉè‰∏≠ÊòæÁé∞...',
                    '‚ö° Êó∂Á©∫‰π±ÊµÅË¢´‰Ω†ÂæÅÊúç...',
                    'üåÄ Âæ™ÁéØÁöÑÊû∑ÈîÅÊ≠£Âú®ÊùæÂä®...',
                    'üî• ÈáçÁîüÁöÑÁÅ´ÁÑ∞ÊÑàÂèëÁÇΩÁÉ≠...'
                ];
                
                let stageIndex = Math.floor((gameState.currentLevel - 1) / 10);
                if (stageIndex >= stageMessages.length) stageIndex = stageMessages.length - 1;
                
                messageDisplay.textContent = stageMessages[stageIndex];
                // 2ÁßíÂêéËá™Âä®ËøõÂÖ•‰∏ã‰∏ÄÂÖ≥
                setTimeout(() => {
                    nextLevel();
                }, 2000);
            }
        }

        // Ê∏∏ÊàèÁªìÊùü
        function gameOver() {
            // Èò≤Ê≠¢ÈáçÂ§çË∞ÉÁî®
            if (gameState.gameOver) return;
            gameState.gameOver = true;
            
            // Â¢ûÂä†Âæ™ÁéØÊ¨°Êï∞Ôºà‰ªÖÂú®Á¨¨‰∫åÂÖ≥Ôºâ
            if (gameState.currentLevel === 2) {
                incrementLoopCount();
            }
            
            // Êí≠ÊîæÁàÜÁÇ∏Èü≥Êïà
            playExplosionSound();
            
            // Ê∑ªÂä†ÁàÜÁÇ∏ÁâπÊïà
            const explosion = document.createElement('div');
            explosion.className = 'explosion';
            explosion.style.left = (gameState.player.x - 30) + 'px';
            explosion.style.top = (gameState.player.y - 25) + 'px';
            gameContainer.appendChild(explosion);
            
            // ÈöêËóèÁé©ÂÆ∂
            player.style.display = 'none';
            
            const deathMessages = [
                'üí• ÁàÜÁÇ∏ÔºÅÂæ™ÁéØÈáçÂêØ...‰Ω†ÂèàÂõûÂà∞‰∫ÜËµ∑ÁÇπ',
                'üîÑ Êó∂Èó¥ÂÄíÊµÅ...ËøôÂ∑≤ÁªèÊòØÁ¨¨17Ê¨°Âæ™ÁéØ‰∫Ü',
                '‚ö° Âæ™ÁéØÊøÄÊ¥ª...ÁªßÁª≠ÊãØÊïëZackÁöÑ‰ΩøÂëΩ',
                'üåÄ Âèà‰∏ÄÊ¨°Âæ™ÁéØ...ZackËøòÂú®Á≠â‰Ω†',
                'üî• ‰ªéÁàÜÁÇ∏‰∏≠ÈáçÁîü...‰∏çËÉΩÊîæÂºÉÔºÅ'
            ];
            const randomMessage = deathMessages[Math.floor(Math.random() * deathMessages.length)];
            messageDisplay.textContent = randomMessage;
            
            // ÁßªÈô§ÁàÜÁÇ∏ÁâπÊïàÂπ∂ÈáçÊñ∞ÂºÄÂßãÂΩìÂâçÂÖ≥Âç°
            setTimeout(() => {
                explosion.remove();
                player.style.display = 'flex';
                restartCurrentLevel();
            }, 1500);
        }
        
        // ÈáçÊñ∞ÂºÄÂßãÂΩìÂâçÂÖ≥Âç°
        function restartCurrentLevel() {
            // ÂÖàÊ∏ÖÈô§Ê∏∏ÊàèÁä∂ÊÄÅ
            gameState.traps = [];
            gameState.movingTraps = [];
            gameState.specialTraps = [];
            gameState.gameOver = false;
            gameState.playerFrozen = false;
            gameState.freezeEndTime = 0;
            
            messageDisplay.textContent = '';
            
            // Ê∏ÖÈô§Áé©ÂÆ∂ÁöÑÁâπÊÆäÁä∂ÊÄÅ
            player.style.filter = '';
            player.style.transform = '';
            
            // Ê∏ÖÈô§‰πãÂâçÁöÑÈô∑Èò±ÔºàÂåÖÊã¨ÁâπÊÆäÈô∑Èò±ÂíåÁâπÊÆäÂÖÉÁ¥†Ôºâ
            document.querySelectorAll('.trap, .spike, .moving-trap, .hidden-mine, .maze-wall, .invisible-trap, .teleport-trap, .hunter-trap, .blink-trap, .gravity-trap, .split-trap, .mirror-trap, .freeze-trap, .bounce-trap, .shrink-trap, .speed-trap, .clone-trap, .player-clone, .collectible, .key-item, .teleporter, .switch, .moving-platform, .timer-display').forEach(el => el.remove());
            
            // ÈáçÁΩÆÁé©ÂÆ∂‰ΩçÁΩÆÔºàÂú®Ê∏ÖÈô§Èô∑Èò±‰πãÂêéÔºâ
            if (gameState.currentLevel === 2) {
                // Á¨¨‰∫åÂÖ≥ÔºöËø∑ÂÆ´Ëµ∑ÁÇπ
                gameState.player = { x: 40, y: 40 }; // ÂØπÂ∫îÁΩëÊ†º(1,1)
            } else {
                // ÂÖ∂‰ªñÂÖ≥Âç°ÔºöÈªòËÆ§‰ΩçÁΩÆ
                gameState.player = { x: 50, y: 250 };
            }
            updatePlayerPosition();
            updateDoorPosition(); // Á°Æ‰øùÈó®‰ΩçÁΩÆÊ≠£Á°Æ
            
            // ÈáçÁî®Áé∞ÊúâÁöÑÂÖ≥Âç°Â∏ÉÂ±Ä
            levelDisplay.textContent = gameState.currentLevel;
            playerSpeed = basePlayerSpeed + Math.floor(gameState.currentLevel / 20);
            
            // ÈáçÊñ∞ËÆæÁΩÆÁâπÊÆäÊú∫Âà∂
            resetSpecialMechanics();
            setupSpecialMechanics();
            
            // ÈáçÁî®Áé∞ÊúâÂ∏ÉÂ±ÄÔºåÁ°Æ‰øù‰∏çÈáçÊñ∞ÁîüÊàê
            if (gameState.currentLevel === 2) {
                // Á¨¨‰∫åÂÖ≥ÁâπÊÆäÂ§ÑÁêÜÔºåÁ°Æ‰øùËø∑ÂÆ´Â∏ÉÂ±Ä‰∏çÂèò
                createTraps(true); // Âº∫Âà∂‰ΩøÁî®Áé∞ÊúâÂ∏ÉÂ±Ä
            } else {
                createTraps(true); // ‰ΩøÁî®Áé∞ÊúâÂ∏ÉÂ±Ä
            }
            setupMovingTraps(true); // ‰ΩøÁî®Áé∞ÊúâÂ∏ÉÂ±Ä
        }

        // ‰∏ã‰∏ÄÂÖ≥
        function nextLevel() {
            gameState.currentLevel++;
            saveProgress(); // ‰øùÂ≠òÂΩìÂâçÂÖ≥Âç°ËøõÂ∫¶
            
            // ÈáçÁΩÆÊñ∞ÂÖ≥Âç°ÁöÑÂæ™ÁéØËÆ°Êï∞Âô®
            resetLoopCounter();
            
            // Ê†πÊçÆÂÖ≥Âç°ËÆæÁΩÆÁé©ÂÆ∂Ëµ∑Âßã‰ΩçÁΩÆ
            if (gameState.currentLevel === 2) {
                gameState.player = { x: 40, y: 40 }; // Ëø∑ÂÆ´Ëµ∑ÁÇπ
            } else {
                gameState.player = { x: 50, y: 250 }; // ÈªòËÆ§‰ΩçÁΩÆ
            }
            
            gameState.traps = [];
            gameState.movingTraps = [];
            gameState.specialTraps = [];
            gameState.gameOver = false;  // ÈáçÁΩÆÊ∏∏ÊàèÁä∂ÊÄÅ
            gameState.playerFrozen = false;
            gameState.freezeEndTime = 0;
            
            messageDisplay.textContent = '';
            nextBtn.classList.add('hidden');
            
            // Ê∏ÖÈô§Áé©ÂÆ∂ÁöÑÁâπÊÆäÁä∂ÊÄÅ
            player.style.filter = '';
            player.style.transform = '';
            
            // Ê∏ÖÈô§‰πãÂâçÁöÑÈô∑Èò±ÔºàÂåÖÊã¨ÁâπÊÆäÈô∑Èò±ÂíåÁâπÊÆäÂÖÉÁ¥†Ôºâ
            document.querySelectorAll('.trap, .spike, .moving-trap, .hidden-mine, .invisible-trap, .teleport-trap, .hunter-trap, .blink-trap, .gravity-trap, .split-trap, .mirror-trap, .freeze-trap, .bounce-trap, .shrink-trap, .speed-trap, .clone-trap, .player-clone, .collectible, .key-item, .teleporter, .switch, .moving-platform, .timer-display').forEach(el => el.remove());
            
            updatePlayerPosition();
            setupLevel();
            updateProgressDisplay(); // Êõ¥Êñ∞ËøõÂ∫¶ÊòæÁ§∫
            
            // ‰∏çÈúÄË¶ÅÂÜçÊ¨°Ë∞ÉÁî®gameLoop()ÔºåÂõ†‰∏∫ÂÆÉÂ∑≤ÁªèÂú®ËøêË°å
        }

        // Êõ¥Êñ∞Áé©ÂÆ∂ÁßªÂä®
        function updatePlayerMovement() {
            if (gameState.gameOver || gameState.playerFrozen) return;
            
            const sm = gameState.specialMechanics;
            let moveX = 0, moveY = 0;
            
            // Âü∫Á°ÄÁßªÂä®ËæìÂÖ•
            if (keys.ArrowUp) moveY -= playerSpeed;
            if (keys.ArrowDown) moveY += playerSpeed;
            if (keys.ArrowLeft) moveX -= playerSpeed;
            if (keys.ArrowRight) moveX += playerSpeed;
            
            // ÂèçÂêëÊéßÂà∂
            if (sm.isReversed) {
                moveX = -moveX;
                moveY = -moveY;
            }
            
            // ÈáçÂäõÁøªËΩ¨
            if (sm.isGravityFlipped) {
                moveY = -moveY;
            }
            
            // ÊªëÂÜ∞Ê®°Âºè
            if (sm.isSlippery) {
                sm.momentum.x += moveX * 0.3;
                sm.momentum.y += moveY * 0.3;
                sm.momentum.x *= 0.95; // Êë©Êì¶Âäõ
                sm.momentum.y *= 0.95;
                moveX = sm.momentum.x;
                moveY = sm.momentum.y;
            }
            
            // È£éÂäõÂΩ±Âìç
            moveX += sm.windForce.x;
            moveY += sm.windForce.y;
            
            // Â∫îÁî®ÁßªÂä®
            gameState.player.x += moveX;
            gameState.player.y += moveY;
            
            updatePlayerPosition();
        }

        // Ê∏∏Êàè‰∏ªÂæ™ÁéØ
        function gameLoop() {
            updatePlayerMovement();
            updateSpecialTraps();
            updateSpecialMechanics();
            checkCollisions();
            animationFrame = requestAnimationFrame(gameLoop);
        }
        
        // Êõ¥Êñ∞ÁâπÊÆäÊú∫Âà∂ÊïàÊûú
        function updateSpecialMechanics() {
            const sm = gameState.specialMechanics;
            
            // Êõ¥Êñ∞ÈªëÊöóÊ®°ÂºèÁöÑÂÖâÁÖß
            if (sm.isDarkMode) {
                const playerX = gameState.player.x + 20; // Áé©ÂÆ∂‰∏≠ÂøÉ
                const playerY = gameState.player.y + 25;
                gameContainer.style.setProperty('--light-x', (playerX / gameWidth * 100) + '%');
                gameContainer.style.setProperty('--light-y', (playerY / gameHeight * 100) + '%');
                gameContainer.style.setProperty('--light-radius', sm.lightRadius + 'px');
            }
            
            // Êõ¥Êñ∞ÁßªÂä®Âπ≥Âè∞
            sm.movingPlatforms.forEach(platform => {
                platform.x += platform.speedX;
                platform.y += platform.speedY;
                
                // ËæπÁïåÂèçÂºπ
                if (platform.x <= 0 || platform.x >= gameWidth - platform.width) {
                    platform.speedX = -platform.speedX;
                    platform.x = Math.max(0, Math.min(gameWidth - platform.width, platform.x));
                }
                if (platform.y <= 0 || platform.y >= gameHeight - platform.height) {
                    platform.speedY = -platform.speedY;
                    platform.y = Math.max(0, Math.min(gameHeight - platform.height, platform.y));
                }
                
                platform.element.style.left = platform.x + 'px';
                platform.element.style.top = platform.y + 'px';
                
                // Ê£ÄÊü•Áé©ÂÆ∂ÊòØÂê¶Âú®Âπ≥Âè∞‰∏ä
                const playerRect = player.getBoundingClientRect();
                const platformRect = platform.element.getBoundingClientRect();
                
                if (playerRect.right > platformRect.left && 
                    playerRect.left < platformRect.right && 
                    playerRect.bottom > platformRect.top && 
                    playerRect.top < platformRect.bottom) {
                    // Áé©ÂÆ∂Ë∑üÈöèÂπ≥Âè∞ÁßªÂä®
                    gameState.player.x += platform.speedX;
                    gameState.player.y += platform.speedY;
                    updatePlayerPosition();
                }
            });
        }

        // Ê£ÄÊü•ÁâπÊÆäÂÖÉÁ¥†‰∫§‰∫í
        function checkSpecialElementInteractions(playerRect) {
            const sm = gameState.specialMechanics;
            
            // Ê£ÄÊü•Êî∂ÈõÜÂìÅ
            sm.collectibles.forEach((collectible, index) => {
                const collectibleRect = collectible.getBoundingClientRect();
                if (playerRect.right > collectibleRect.left && 
                    playerRect.left < collectibleRect.right && 
                    playerRect.bottom > collectibleRect.top && 
                    playerRect.top < collectibleRect.bottom) {
                    collectible.remove();
                    sm.collectibles.splice(index, 1);
                    playSuccessSound();
                    messageDisplay.textContent = `üíé Êî∂ÈõÜÂà∞Ê∞¥Êô∂ÔºÅËøòÈúÄ ${sm.collectibles.length} ‰∏™`;
                }
            });
            
            // Ê£ÄÊü•Èí•Âåô
            document.querySelectorAll('.key-item').forEach(key => {
                const keyRect = key.getBoundingClientRect();
                if (playerRect.right > keyRect.left && 
                    playerRect.left < keyRect.right && 
                    playerRect.bottom > keyRect.top && 
                    playerRect.top < keyRect.bottom) {
                    key.remove();
                    sm.keys++;
                    playSuccessSound();
                    messageDisplay.textContent = `üóùÔ∏è Ëé∑ÂæóÈí•ÂåôÔºÅ(${sm.keys}/${sm.requiredKeys})`;
                }
            });
            
            // Ê£ÄÊü•‰º†ÈÄÅÈó®
            sm.teleporters.forEach(teleporter => {
                const teleporterRect = teleporter.getBoundingClientRect();
                if (playerRect.right > teleporterRect.left && 
                    playerRect.left < teleporterRect.right && 
                    playerRect.bottom > teleporterRect.top && 
                    playerRect.top < teleporterRect.bottom) {
                    // ‰º†ÈÄÅÂà∞ÈöèÊú∫‰ΩçÁΩÆ
                    gameState.player.x = 100 + Math.random() * (gameWidth - 200);
                    gameState.player.y = 50 + Math.random() * (gameHeight - 150);
                    updatePlayerPosition();
                    playSuccessSound();
                    messageDisplay.textContent = 'üåÄ ‰º†ÈÄÅÊàêÂäüÔºÅ';
                }
            });
            
            // Ê£ÄÊü•ÂºÄÂÖ≥
            sm.switches.forEach(switchEl => {
                const switchRect = switchEl.getBoundingClientRect();
                if (playerRect.right > switchRect.left && 
                    playerRect.left < switchRect.right && 
                    playerRect.bottom > switchRect.top && 
                    playerRect.top < switchRect.bottom) {
                    if (switchEl.dataset.activated === 'false') {
                        switchEl.dataset.activated = 'true';
                        switchEl.classList.add('activated');
                        playSuccessSound();
                        const activatedCount = sm.switches.filter(s => s.dataset.activated === 'true').length;
                        messageDisplay.textContent = `üîò ÂºÄÂÖ≥ÊøÄÊ¥ªÔºÅ(${activatedCount}/${sm.switches.length})`;
                    }
                }
            });
        }
        
        // Êõ¥Êñ∞ËÆ°Êó∂Âô®
        function updateTimer() {
            const sm = gameState.specialMechanics;
            if (sm.timeLimit > 0) {
                const elapsed = (Date.now() - sm.startTime) / 1000;
                const remaining = Math.max(0, sm.timeLimit - elapsed);
                
                const timerDisplay = document.getElementById('timer-display');
                if (timerDisplay) {
                    timerDisplay.textContent = `‚è∞ ${Math.ceil(remaining)}s`;
                    if (remaining <= 5) {
                        timerDisplay.classList.add('timer-warning');
                    }
                    
                    if (remaining <= 0) {
                        gameOver();
                        return;
                    }
                }
            }
        }
        
        // Ê£ÄÊü•ÊòØÂê¶ÂèØ‰ª•ÈÄöÂÖ≥
        function canPassLevel() {
            const sm = gameState.specialMechanics;
            
            // Ê£ÄÊü•Êî∂ÈõÜÂìÅ
            if (sm.collectibles.length > 0) {
                return false;
            }
            
            // Ê£ÄÊü•Èí•Âåô
            if (sm.requiredKeys > 0 && sm.keys < sm.requiredKeys) {
                return false;
            }
            
            // Ê£ÄÊü•ÂºÄÂÖ≥
            if (sm.switches.length > 0) {
                const activatedCount = sm.switches.filter(s => s.dataset.activated === 'true').length;
                if (activatedCount < sm.switches.length) {
                    return false;
                }
            }
            
            return true;
        }
        
        // Êõ¥Êñ∞ÁâπÊÆäÈô∑Èò±ÁöÑË°å‰∏∫
        function updateSpecialTraps() {
            if (gameState.gameOver) return;
            
            gameState.traps.forEach(trap => {
                const trapType = trap.dataset.trapType;
                if (!trapType) return;
                
                const playerRect = player.getBoundingClientRect();
                const trapRect = trap.getBoundingClientRect();
                
                switch(trapType) {
                    case 'invisible':
                        // ÈöêÂΩ¢Èô∑Èò±ÔºöÁé©ÂÆ∂Èù†ËøëÊó∂ÊòæÁé∞
                        const distance = Math.sqrt(
                            Math.pow(playerRect.left - trapRect.left, 2) + 
                            Math.pow(playerRect.top - trapRect.top, 2)
                        );
                        if (distance < 80 && trap.dataset.revealed === 'false') {
                            trap.dataset.revealed = 'true';
                            trap.classList.add('revealed');
                        }
                        break;
                        
                    case 'hunter':
                        // ËøΩË∏™Èô∑Èò±ÔºöË∑üÁùÄÁé©ÂÆ∂ÁßªÂä®
                        const speed = parseFloat(trap.dataset.huntSpeed) || 2;
                        const currentLeft = parseFloat(trap.style.left);
                        const currentTop = parseFloat(trap.style.top);
                        
                        const playerX = gameState.player.x + 20; // Áé©ÂÆ∂‰∏≠ÂøÉÁÇπ
                        const playerY = gameState.player.y + 25;
                        const trapX = currentLeft + 20; // Èô∑Èò±‰∏≠ÂøÉÁÇπ
                        const trapY = currentTop + 20;
                        
                        const dx = playerX - trapX;
                        const dy = playerY - trapY;
                        const magnitude = Math.sqrt(dx * dx + dy * dy);
                        
                        if (magnitude > 5) { // ÈÅøÂÖçÊäñÂä®
                            const moveX = (dx / magnitude) * speed;
                            const moveY = (dy / magnitude) * speed;
                            
                            trap.style.left = Math.max(0, Math.min(gameWidth - 40, currentLeft + moveX)) + 'px';
                            trap.style.top = Math.max(0, Math.min(gameHeight - 40, currentTop + moveY)) + 'px';
                        }
                        break;
                        
                    case 'mirror':
                        // ÈïúÂÉèÈô∑Èò±Ôºö‰∏éÁé©ÂÆ∂ÂÅöÁõ∏ÂèçÁßªÂä®
                        const centerX = gameWidth / 2;
                        const centerY = gameHeight / 2;
                        const mirrorX = centerX - (gameState.player.x - centerX);
                        const mirrorY = centerY - (gameState.player.y - centerY);
                        
                        trap.style.left = Math.max(0, Math.min(gameWidth - 40, mirrorX - 20)) + 'px';
                        trap.style.top = Math.max(0, Math.min(gameHeight - 40, mirrorY - 25)) + 'px';
                        break;
                        
                    case 'gravity':
                        // ÈáçÂäõÈô∑Èò±ÔºöÂê∏ÂºïÁé©ÂÆ∂
                        const gravityDistance = Math.sqrt(
                            Math.pow(playerRect.left - trapRect.left, 2) + 
                            Math.pow(playerRect.top - trapRect.top, 2)
                        );
                        
                        if (gravityDistance < 120) { // ÈáçÂäõËåÉÂõ¥
                            const pullForce = parseFloat(trap.dataset.pullForce) || 3;
                            const trapCenterX = trapRect.left + trapRect.width / 2 - gameContainer.getBoundingClientRect().left;
                            const trapCenterY = trapRect.top + trapRect.height / 2 - gameContainer.getBoundingClientRect().top;
                            
                            const pullX = trapCenterX - (gameState.player.x + 20);
                            const pullY = trapCenterY - (gameState.player.y + 25);
                            const pullMagnitude = Math.sqrt(pullX * pullX + pullY * pullY);
                            
                            if (pullMagnitude > 0) {
                                gameState.player.x += (pullX / pullMagnitude) * pullForce * 0.3;
                                gameState.player.y += (pullY / pullMagnitude) * pullForce * 0.3;
                                updatePlayerPosition();
                            }
                        }
                        break;
                        
                    case 'blink':
                        // Èó™ÁÉÅÈô∑Èò±ÈÄªËæëÂ∑≤ÈÄöËøáCSSÂä®ÁîªÂ§ÑÁêÜ
                        const computedStyle = window.getComputedStyle(trap);
                        trap.dataset.visible = computedStyle.opacity > 0.5 ? 'true' : 'false';
                        break;
                }
            });
        }

        // ÈîÆÁõòÊéßÂà∂
        document.addEventListener('keydown', (e) => {
            if (gameState.gameOver) return;
            
            if (e.key in keys) {
                keys[e.key] = true;
            }
        });

        document.addEventListener('keyup', (e) => {
            if (e.key in keys) {
                keys[e.key] = false;
            }
        });

        // ‰∫ã‰ª∂ÁõëÂê¨
        nextBtn.addEventListener('click', () => {
            playClickSound();
            nextLevel();
        });
        
        restartBtn.addEventListener('click', () => {
            playClickSound();
            startLevel();
        });
        
        levelSelectBtn.addEventListener('click', () => {
            playClickSound();
            createLevelButtons();
            levelSelectModal.classList.remove('hidden');
        });
        
        soundToggleBtn.addEventListener('click', toggleSound);
        
        musicToggleBtn.addEventListener('click', () => {
            playClickSound();
            toggleMusic();
        });
        
        helpBtn.addEventListener('click', () => {
            playClickSound();
            helpModal.classList.remove('hidden');
        });
        
        closeSelectBtn.addEventListener('click', () => {
            playClickSound();
            levelSelectModal.classList.add('hidden');
        });
        
        closeHelpBtn.addEventListener('click', () => {
            playClickSound();
            helpModal.classList.add('hidden');
        });
        
        resetProgressBtn.addEventListener('click', () => {
            playClickSound();
            if (confirm('Á°ÆÂÆöË¶ÅÈáçÁΩÆÊâÄÊúâËøõÂ∫¶ÂêóÔºüËøôÂ∞ÜÂà†Èô§ÊÇ®ÁöÑÊâÄÊúâÊ∏∏ÊàèËÆ∞ÂΩïÔºÅ')) {
                resetProgress();
                initGame();
                messageDisplay.textContent = 'ËøõÂ∫¶Â∑≤ÈáçÁΩÆÔºÅ';
                setTimeout(() => {
                    messageDisplay.textContent = '';
                }, 2000);
            }
        });

        // È°µÈù¢Âä†ËΩΩÊó∂Á´ãÂç≥ÈöêËóèÂÖ≥Âç°ÈÄâÊã©Âô®ÂíåÂ∏ÆÂä©Èù¢Êùø
        levelSelectModal.classList.add('hidden');
        helpModal.classList.add('hidden');
        
        // Â§ÑÁêÜÈ¶ñÊ¨°Áî®Êà∑‰∫§‰∫íÔºàÁî®‰∫éÂêØÂä®ËÉåÊôØÈü≥‰πêÔºâ
        let firstInteraction = true;
        function handleFirstInteraction() {
            if (firstInteraction && musicEnabled && backgroundMusic) {
                playBackgroundMusic();
                firstInteraction = false;
            }
        }

        // ÁõëÂê¨ÂêÑÁßçÁî®Êà∑‰∫§‰∫í‰∫ã‰ª∂
        document.addEventListener('click', handleFirstInteraction);
        document.addEventListener('keydown', handleFirstInteraction);
        document.addEventListener('touchstart', handleFirstInteraction);
        
        // ÂºÄÂßãÊ∏∏Êàè
        initGame();
        gameLoop();
    </script>
</body>
</html>